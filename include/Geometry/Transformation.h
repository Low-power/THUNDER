/*******************************************************************************
 * Author: Mingxu Hu
 * Dependency:
 * Test:
 * Execution:
 * Description:
 *
 * Manual:
 * ****************************************************************************/

#ifndef TRANSFORMATION_H
#define TRANSFORMATION_H

#include <cmath>
#include <iostream>

#include "Macro.h"
#include "Typedef.h"
#include "Error.h"

#include "Euler.h"

#include "Functions.h"

#include "Image.h"
#include "Volume.h"

#include "Symmetry.h"

/**
 * This macro performs a transformation on a volume in real space given 
 * transformation matrix which is generated by a piece of code.
 *
 * @param dst the destination volume
 * @param src the source volume
 * @param MAT code of the transformation matrix
 * @param MAT_GEN code for generating transformation matrix
 * @param r the upper boundary of radius
 */
#define VOL_TRANSFORM_RL(dst, src, MAT, MAT_GEN, r) \
    VOL_TRANSFORM(RL, dst, src, MAT, MAT_GEN, r)

/**
 * This macro performs a transformation on a volume in Fourier space given 
 * transformation matrix which is generated by a piece of code.
 *
 * @param dst the destination volume
 * @param src the source volume
 * @param MAT code of the transformation matrix
 * @param MAT_GEN code for generating transformation matrix
 * @param r the upper boundary of radius
 */
#define VOL_TRANSFORM_FT(dst, src, MAT, MAT_GEN, r) \
    VOL_TRANSFORM(FT, dst, src, MAT, MAT_GEN, r)

/**
 * This macro performs a transformation on a volume given transformation matrix
 * which is generated by a piece of code.
 *
 * @param SPACE the space in which the transformation performs (RL: real space,
 * FT: Fourier space)
 * @param dst the destination volume
 * @param src the source volume
 * @param MAT code of the transformation matrix
 * @param MAT_GEN code for generating transformation matrix
 * @param r the upper boundary of radius
 */


#define VOL_TRANSFORM(SPACE, dst, src, MAT, MAT_GEN, r) \
do \
{ \
    mat33 MAT; \
    MAT_GEN; \
    VOL_TRANSFORM_MAT(SPACE, dst, src, MAT, r); \
} while (0)

/**
 * This marco performs a transformation on a volume in real space given a
 * transformation matrix.
 *
 * @param dst the destination volume
 * @param src the source volume
 * @param mat the transformation matrix
 * @param r the upper boundary of radius
 */
//#define VOL_TRANSFORM_MAT_RL(dst, src, mat, r) \
//    VOL_TRANSFORM_MAT(RL, dst, src, mat, r)

/**
 * This marco performs a transformation on a volume in Fourier space given a
 * transformation matrix.
 *
 * @param dst the destination volume
 * @param src the source volume
 * @param mat the transformation matrix
 * @param r the upper boundary of radius
 */
#define VOL_TRANSFORM_MAT_FT(dst, src, mat, r) \
    VOL_TRANSFORM_MAT(FT, dst, src, mat, r)

/**
 * This macro performs a transformation on a volume given a transformation
 * matrix.
 *
 * @param SPACE the space in which the transformation performs (RL: real space,
 * FT: Fourier space)
 * @param dst the destination volume
 * @param src the source volume
 * @param mat the transformation matrix
 * @param r the upper boundary of radius
 */
#define VOL_TRANSFORM_MAT(SPACE, dst, src, mat, r) \
[](Volume& _dst, const Volume& _src, const mat33 _mat, const double _r)\
{ \
    SET_0_##SPACE(_dst); \
    _Pragma("omp parallel for schedule(dynamic)") \
    VOLUME_FOR_EACH_PIXEL_##SPACE(_dst) \
    { \
        vec3 newCor = {(double)i, (double)j, (double)k}; \
        vec3 oldCor = _mat * newCor; \
        if (oldCor.squaredNorm() < gsl_pow_2(_r)) \
            _dst.set##SPACE(_src.getByInterpolation##SPACE(oldCor(0), \
                                                           oldCor(1), \
                                                           oldCor(2), \
                                                           LINEAR_INTERP), \
                            i, \
                            j, \
                            k); \
    } \
}(dst, src, mat, r)

inline void VOL_TRANSFORM_MAT_RL(Volume& dst, 
                                const Volume& src, 
                                const mat33 mat, 
                                const double r)
{ 
    SET_0_RL(dst); 
    #pragma omp parallel for schedule(dynamic)
    VOLUME_FOR_EACH_PIXEL_RL(dst)
    { 
        vec3 newCor((double)i, (double)j, (double)k);
        vec3 oldCor = mat * newCor; 
        if (oldCor.squaredNorm() < gsl_pow_2(r))
            dst.setRL(src.getByInterpolationRL(oldCor(0),
                                               oldCor(1),
                                               oldCor(2),
                                               LINEAR_INTERP),
                            i, 
                            j, 
                            k); 
    } 
}

///**
// * This macro symmetrizes a symmetry unit in real space.
// *
// * @param dst the destination volume
// * @param src the source volume
// * @param sym a list of transformation matrices of a symmetry group
// * @param r the upper boundary of radius
// */
//#define SYMMETRIZE_RL(dst, src, sym, r) \
//    SYMMETRIZE(RL, dst, src, sym, r)

/**
 * This macro symmetrizes a symmetry unit in Fourier space.
 *
 * @param dst the destination volume
 * @param src the source volume
 * @param sym a list of transformation matrices of a symmetry group
 * @param r the upper boundary of radius
 */
#define SYMMETRIZE_FT(dst, src, sym, r) \
    SYMMETRIZE(FT, dst, src, sym, r)

/**
 * This macro symmetrizes a symmetry unit.
 *
 * @param SPACE the space in which the transformation performs (RL: real space,
 * FT: Fourier space)
 * @param dst the destination volume
 * @param src the source volume
 * @param sym a list of transformation matrices of a symmetry group
 * @param r the upper boundary of radius
 */
#define SYMMETRIZE(SP, dst, src, sym, r) \
[](Volume& _dst, const Volume& _src, const Symmetry& _sym, const double _r) \
{ \
    _dst = _src.copyVolume(); \
    mat33 L, R; \
    Volume se(_src.nColRL(), _src.nRowRL(), _src.nSlcRL(), SP##_SPACE); \
    for (int i = 0; i < _sym.nSymmetryElement(); i++) \
    { \
        _sym.get(L, R, i); \
        VOL_TRANSFORM_MAT_##SP(se, _src, R, _r); \
        _Pragma("omp parallel for") \
        ADD_##SP(_dst, se); \
    } \
}(dst, src, sym, r)

inline void SYMMETRIZE_RL(Volume& _dst, const Volume& _src, const Symmetry& _sym, const double _r)
{
    _dst = _src.copyVolume();
    mat33 L, R;
    Volume se(_src.nColRL(), _src.nRowRL(), _src.nSlcRL(), RL_SPACE);
    for (int i = 0; i < _sym.nSymmetryElement(); i++)
    {
        _sym.get(L, R, i);
        VOL_TRANSFORM_MAT_RL(se, _src, R, _r);
        _Pragma("omp parallel for")
        ADD_RL(_dst, se);
    }
}

#endif // TRANSFORMATION_H
