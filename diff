diff --git a/appsrc/Optimiser.cpp b/appsrc/Optimiser.cpp
index 583f266..0a84130 100644
--- a/appsrc/Optimiser.cpp
+++ b/appsrc/Optimiser.cpp
@@ -26,15 +26,33 @@ static inline void copy_string(char (&array)[N], const std::string& source)
 {
     if (source.size() + 1 >= N)
     {
-        CLOG(FATAL, "LOGGER_SYS") << "String too large to fit in parameter";
+        CLOG(FATAL, "LOGGER_SYS") << "String too large to fit in parameter. "
+                                  << "Destination length is "
+                                  << N
+                                  << ", while source length is "
+                                  << source.size() + 1;
+                                  
         return;
     }
-    memcpy(array, source.c_str(), source.size()+1);
+    memcpy(array, source.c_str(), source.size() + 1);
 }
 
 void readPara(MLOptimiserPara& dst,
               const Json::Value src)
 {
+    if (src["2D or 3D Mode"].asString() == "2D")
+    {
+        dst.mode = MODE_2D;
+    }
+    else if (src["2D or 3D Mode"].asString() == "3D")
+    {
+        dst.mode = MODE_3D;
+    }
+    else
+        REPORT_ERROR("INEXISTENT MODE");
+
+    dst.refine = src["Refine"].asBool();
+
     dst.k = src["Number of Classes"].asInt();
     dst.size = src["Size of Image"].asInt();
     dst.pixelSize = src["Pixel Size (Angstrom)"].asFloat();
@@ -52,10 +70,6 @@ void readPara(MLOptimiserPara& dst,
     dst.autoMask = src["Reference Mask"]["Automask"].asBool();
     copy_string(dst.mask, src["Reference Mask"]["Provided Mask"].asString());
 
-    dst.performSharpen = src["Sharpening"]["Perform Sharpening"].asBool();
-    dst.estBFactor = src["Sharpening"]["Auto Estimate B-Factor"].asBool();
-    dst.bFactor = src["Sharpening"]["B-Factor (Angstrom^2)"].asFloat();
-
     dst.iterMax = src["Advanced"]["Max Number of Iteration"].asInt();
     dst.pf = src["Advanced"]["Padding Factor"].asInt();
     dst.a = src["Advanced"]["MKB Kernel Radius"].asFloat();
@@ -72,6 +86,10 @@ void readPara(MLOptimiserPara& dst,
     dst.groupSig = src["Advanced"]["Grouping when Calculating Sigma"].asBool();
     dst.groupScl = src["Advanced"]["Grouping when Correcting Intensity Scale"].asBool();
     dst.zeroMask = src["Advanced"]["Mask Images with Zero Noise"].asBool();
+
+    dst.transSearchFactor = src["Professional"]["Translation Search Factor"].asFloat();
+    dst.perturbFactorL = src["Professional"]["Perturbation Factor (Large)"].asFloat();
+    dst.perturbFactorS = src["Professional"]["Perturbation Factor (Small)"].asFloat();
 };
 
 INITIALIZE_EASYLOGGINGPP
diff --git a/casesrc/app/Projector.cpp b/casesrc/app/Projector.cpp
deleted file mode 100644
index 5fc55bb..0000000
--- a/casesrc/app/Projector.cpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/*******************************************************************************
- * Author: Mingxu Hu
- * Dependecy:
- * Test:
- * Execution:
- * Description:
- * ****************************************************************************/
-
-#include <fstream>
-
-#include "Projector.h"
-#include "ImageFile.h"
-#include "FFT.h"
-
-#define PF 2
-
-using namespace std;
-
-INITIALIZE_EASYLOGGINGPP
-
-int main(int argc, char* argv[])
-{
-    loggerInit(argc, argv);
-
-    Volume obj;
-
-    std::cout << "Reading in Object" << std::endl;
-
-    ImageFile imf(argv[1], "r");
-    imf.readMetaData();
-    imf.readVolume(obj);
-
-    std::cout << "Size: " << obj.nColRL() << " x "
-                     << obj.nRowRL() << " x "
-                     << obj.nSlcRL() << std::endl;
-
-    int N = obj.nColRL();
-
-    std::cout << "Padding" << std::endl;
-
-    Volume padObj;
-    VOL_PAD_RL(padObj, obj, 2);
-    
-    std::cout << "Performing Fourier Transform" << std::endl;
-
-    FFT fft;
-    fft.fw(padObj);
-
-    Projector projector;
-    projector.setPf(PF);
-    projector.setProjectee(padObj.copyVolume());
-
-    char name[FILE_NAME_LENGTH];
-    int counter = 0;
-
-    Image image(N, N, RL_SPACE);
-    
-    ifstream fin(argv[2], ios::in);
-    char line[1024];
-    double phi, theta, psi, x, y;
-
-    ImageFile oimf;
-
-    while (fin.getline(line, sizeof(line)))
-    {
-        stringstream word(line);
-        word >> phi;
-        word >> theta;
-        word >> psi;
-        word >> x;
-        word >> y;
-
-        std::cout << "phi = " << phi
-             << ", theta = " << theta
-             << ", psi = " << psi
-             << ", x = " << x
-             << ", y = " << y
-             << std::endl;
-
-        fft.fw(image);
-        SET_0_FT(image);
-        projector.project(image, phi, theta, psi, x, y);
-        fft.bw(image);
-
-        sprintf(name, "%08d.bmp", counter);
-        image.saveRLToBMP(name);
-
-        sprintf(name, "%08d.mrc", counter);
-        oimf.readMetaData(image);
-        oimf.writeImage(name, image);
-
-        counter++;
-    }
-
-    fin.clear();
-    fin.close();
-
-    return 0;
-}
diff --git a/casesrc/case1/InitModelGen.cpp b/casesrc/case1/InitModelGen.cpp
deleted file mode 100644
index 3414dd5..0000000
--- a/casesrc/case1/InitModelGen.cpp
+++ /dev/null
@@ -1,59 +0,0 @@
-/*******************************************************************************
- * Author: Mingxu Hu
- * Dependecy:
- * Test:
- * Execution:
- * Description:
- * ****************************************************************************/
-
-#include <iostream>
-
-#include "ImageFile.h"
-#include "Volume.h"
-#include "ImageFunctions.h"
-
-#define N 128
-#define PF 2
-
-using namespace std;
-
-INITIALIZE_EASYLOGGINGPP
-
-int main(int argc, char* argv[])
-{
-    loggerInit(argc, argv);
-
-    std::cout << "Defining Sphere" << std::endl;
-    Volume sphere(N, N, N, RL_SPACE);
-    VOLUME_FOR_EACH_PIXEL_RL(sphere)
-    {
-        double ii = i * 0.8;
-        double jj = j * 0.8;
-        double kk = k * 0.8;
-        /***
-        if (NORM_3(ii, jj, kk) < N / 8)
-            sphere.setRL(1, i, j, k);
-        else
-            sphere.setRL(0, i, j, k);
-        ***/
-        if ((NORM_3(ii, jj, kk) < N / 8) ||
-            (NORM_3(ii - N / 8, jj, kk - N / 8) < N / 16) ||
-            (NORM_3(ii + N / 8, jj, kk - N / 8) < N / 16) ||
-            ((NORM(ii, jj) < N / 16) &&
-             (kk + N / 16 < 0) &&
-             (kk + 3 * N / 16 > 0)))
-            sphere.setRL(1, i, j, k);
-        else
-            sphere.setRL(0, i, j, k);
-    }
-
-    Volume padSphere;
-    VOL_PAD_RL(padSphere, sphere, PF);
-    normalise(padSphere);
-
-    ImageFile imf;
-    imf.readMetaData(padSphere);
-    imf.writeVolume("sphere.mrc", padSphere);
-
-    return 0;
-}
diff --git a/casesrc/case1/MickeyMouse.cpp b/casesrc/case1/MickeyMouse.cpp
deleted file mode 100644
index 9da4437..0000000
--- a/casesrc/case1/MickeyMouse.cpp
+++ /dev/null
@@ -1,68 +0,0 @@
-/*******************************************************************************
- * Author: Mingxu Hu
- * Dependecy:
- * Test:
- * Execution:
- * Description:
- * ****************************************************************************/
-
-#include <iostream>
-
-#include "Projector.h"
-#include "Reconstructor.h"
-#include "FFT.h"
-#include "ImageFile.h"
-#include "Particle.h"
-#include "CTF.h"
-#include "Experiment.h"
-#include "MLOptimiser.h"
-
-#define PF 2
-
-#define N 128
-#define TRANS_S 4
-
-#define PIXEL_SIZE 1.32
-
-#define MG 1000
-#define ML 100
-
-using namespace std;
-
-INITIALIZE_EASYLOGGINGPP
-
-int main(int argc, char* argv[])
-{
-    loggerInit(argc, argv);
-
-    MPI_Init(&argc, &argv);
-
-    std::cout << "Initialising Parameters" << std::endl;
-    MLOptimiserPara para;
-    para.iterMax = atoi(argv[1]);
-    para.k = 1;
-    para.size = N;
-    para.pf = PF;
-    para.a = 0.95;
-    para.alpha = 10;
-    para.pixelSize = PIXEL_SIZE;
-    para.mG = MG;
-    para.mL = ML;
-    para.transS = TRANS_S;
-    para.initRes = 60;
-    sprintf(para.sym, "C2");
-    sprintf(para.initModel, "sphere.mrc");
-    sprintf(para.db, "MickeyMouse.db");
-
-    std::cout << "Setting Parameters" << std::endl;
-    MLOptimiser opt;
-    opt.setPara(para);
-
-    std::cout << "MPISetting" << std::endl;
-    opt.setMPIEnv();
-
-    std::cout << "Run" << std::endl;
-    opt.run();
-
-    MPI_Finalize();
-}
diff --git a/casesrc/case1/MickeyMouseDataGen.cpp b/casesrc/case1/MickeyMouseDataGen.cpp
deleted file mode 100644
index a2ca728..0000000
--- a/casesrc/case1/MickeyMouseDataGen.cpp
+++ /dev/null
@@ -1,184 +0,0 @@
-/*******************************************************************************
- * Author: Mingxu Hu
- * Dependecy:
- * Test:
- * Execution:
- * Description:
- * ****************************************************************************/
-
-#include <iostream>
-
-#include "Projector.h"
-#include "Reconstructor.h"
-#include "FFT.h"
-#include "ImageFile.h"
-#include "Particle.h"
-#include "CTF.h"
-#include "Experiment.h"
-
-#define PF 2
-
-#define N 128
-#define M 5000
-#define TRANS_S 2
-
-#define PIXEL_SIZE 1.32
-#define VOLTAGE 3e5
-#define DEFOCUS_U 2e4
-#define DEFOCUS_V 2e4
-#define THETA 0
-#define CS 0
-
-using namespace std;
-
-INITIALIZE_EASYLOGGINGPP
-
-int main(int argc, char* argv[])
-{
-    loggerInit(argc, argv);
-
-    ImageFile imf;
-
-    FFT fft;
-
-    std::cout << "Defining Head" << std::endl;
-    Volume head(N, N, N, RL_SPACE);
-    VOLUME_FOR_EACH_PIXEL_RL(head)
-    {
-        double ii = i * 0.8;
-        double jj = j * 0.8;
-        double kk = k * 0.8;
-        if ((NORM_3(ii, jj, kk) < N / 8) ||
-            (NORM_3(ii - N / 8, jj, kk - N / 8) < N / 16) ||
-            (NORM_3(ii - N / 8, jj - N / 8, kk - N / 8) < N / 16) ||
-            (NORM_3(ii + N / 8, jj, kk - N / 8) < N / 16) ||
-            (NORM_3(ii + N / 8, jj + N / 8, kk - N / 8) < N / 16) ||
-            ((NORM(ii, jj) < N / 16) &&
-             (kk + N / 16 < 0) &&
-             (kk + 3 * N / 16 > 0)))
-            head.setRL(1, i, j, k);
-        else
-            head.setRL(0, i, j, k);
-    }
-
-
-/***
-    printf("head: mean = %f, stddev = %f, maxValue = %f\n",
-           gsl_stats_mean(&head(0), 1, head.sizeRL()),
-           gsl_stats_sd(&head(0), 1, head.sizeRL()),
-           head(cblas_idamax(head.sizeRL(), &head(0), 1)));
-***/
-
-    /***
-    fft.fw(head);
-    fft.bw(head);
-
-    printf("head: mean = %f, stddev = %f\n",
-           gsl_stats_mean(&head(0), 1, head.sizeRL()),
-           gsl_stats_sd(&head(0), 1, head.sizeRL()));
-    ***/
-
-    std::cout << "Padding Head" << std::endl;
-    Volume padHead;
-    VOL_PAD_RL(padHead, head, PF);
-    normalise(padHead);
-
-    imf.readMetaData(padHead);
-    imf.writeVolume("padHead.mrc", padHead);
-
-    std::cout << "Reading from Hard-disk" << std::endl;
-    ImageFile imf2("padHead.mrc", "rb");
-    imf2.readMetaData();
-    imf2.readVolume(padHead);
-
-    /***
-    std::cout << "Adding Noise" << std::endl;
-    Volume noise(PF * N, PF * N, PF * N, RL_SPACE);
-    gsl_rng* engine = get_random_engine();
-    FOR_EACH_PIXEL_RL(noise)
-        noise(i) = gsl_ran_gaussian(engine, 20);
-    ADD_RL(padHead, noise);
-    ***/
-
-    printf("padHead: mean = %f, stddev = %f, maxValue = %f\n",
-           gsl_stats_mean(&padHead(0), 1, padHead.sizeRL()),
-           gsl_stats_sd(&padHead(0), 1, padHead.sizeRL()),
-           padHead(cblas_idamax(padHead.sizeRL(), &padHead(0), 1)));
-
-    std::cout << "Fourier Transforming Head" << std::endl;
-    fft.fw(padHead);
-
-    std::cout << "Setting Projectee" << std::endl;
-    Projector projector;
-    projector.setPf(PF);
-    projector.setProjectee(padHead.copyVolume());
-
-    std::cout << "Setting CTF" << std::endl;
-    Image ctf(N, N, FT_SPACE);
-    CTF(ctf,
-        PIXEL_SIZE,
-        VOLTAGE,
-        DEFOCUS_U,
-        DEFOCUS_V,
-        THETA,
-        CS);
-
-    std::cout << "Initialising Experiment" << std::endl;
-    Experiment exp("MickeyMouse.db");
-    exp.createTables();
-    exp.appendMicrograph("", VOLTAGE, DEFOCUS_U, DEFOCUS_V, THETA, CS);
-    exp.appendGroup("");
-
-    char name[256];
-
-    Image image(N, N, FT_SPACE);
-    // Image image(N, N, RL_SPACE);
-    std::cout << "Initialising Random Sampling Points" << std::endl;
-    Symmetry sym("C2");
-    Particle par(M, TRANS_S, 0.01, &sym);
-    std::cout << "Saving Sampling Points" << std::endl;
-    save("Sampling_Points.par", par);
-
-    Coordinate5D coord;
-    gsl_rng* engine = get_random_engine();
-    for (int i = 0; i < M; i++)
-    {
-        SET_0_FT(image);
-
-        sprintf(name, "%04d.mrc", i + 1);
-        printf("%s\n", name);
-
-        par.coord(coord, i);
-        projector.project(image, coord);
-
-        FOR_EACH_PIXEL_FT(image)
-            image[i] *= REAL(ctf[i]);
-
-        Image noise(N, N, RL_SPACE);
-        FOR_EACH_PIXEL_RL(noise)
-            noise(i) = gsl_ran_gaussian(engine, 5);
-
-        fft.bw(image);
-
-        ADD_RL(image, noise);
-
-        printf("image: mean = %f, stddev = %f, maxValue = %f\n",
-               gsl_stats_mean(&image(0), 1, image.sizeRL()),
-               gsl_stats_sd(&image(0), 1, image.sizeRL()),
-               image(cblas_idamax(image.sizeRL(), &image(0), 1)));
-
-        exp.appendParticle(name, 1, 1);
-
-        imf.readMetaData(image);
-        imf.writeImage(name, image);
-
-        /***
-        sprintf(name, "Image_%04d.bmp", i + 1);
-        image.saveRLToBMP(name);
-        ***/
-
-        fft.fw(image);
-    }
-
-    return 0;
-}
diff --git a/casesrc/case2/DataGen.cpp b/casesrc/case2/DataGen.cpp
deleted file mode 100644
index 8717f80..0000000
--- a/casesrc/case2/DataGen.cpp
+++ /dev/null
@@ -1,419 +0,0 @@
-/*******************************************************************************
- * Author: Mingxu Hu
- * Dependecy:
- * Test:
- * Execution:
- * Description:
- * ****************************************************************************/
-
-#include <iostream>
-
-#include <omp_compat.h>
-
-#include <gsl/gsl_statistics.h>
-
-#include "Projector.h"
-#include "FFT.h"
-#include "ImageFile.h"
-#include "Particle.h"
-#include "CTF.h"
-#include "Experiment.h"
-#include "Spectrum.h"
-#include "Mask.h"
-
-#define PF 2
-
-#define N 380
-//#define M 40000
-#define M 5000
-#define TRANS_S 2
-
-#define PIXEL_SIZE 1.32
-#define VOLTAGE 3e5
-
-#define DEFOCUS_U_1 1e4
-#define DEFOCUS_V_1 1e4
-#define DEFOCUS_U_2 1.2e4
-#define DEFOCUS_V_2 1.2e4
-#define DEFOCUS_U_3 1.4e4
-#define DEFOCUS_V_3 1.4e4
-#define DEFOCUS_U_4 1.6e4
-#define DEFOCUS_V_4 1.6e4
-#define DEFOCUS_U_5 1.8e4
-#define DEFOCUS_V_5 1.8e4
-#define DEFOCUS_U_6 2.0e4
-#define DEFOCUS_V_6 2.0e4
-#define DEFOCUS_U_7 2.2e4
-#define DEFOCUS_V_7 2.2e4
-#define DEFOCUS_U_8 2.4e4
-#define DEFOCUS_V_8 2.4e4
-
-/***
-#define DEFOCUS_U_1 2e4
-#define DEFOCUS_V_1 2e4
-#define DEFOCUS_U_2 2.2e4
-#define DEFOCUS_V_2 2.2e4
-#define DEFOCUS_U_3 2.4e4
-#define DEFOCUS_V_3 2.4e4
-#define DEFOCUS_U_4 2.6e4
-#define DEFOCUS_V_4 2.6e4
-#define DEFOCUS_U_5 2.8e4
-#define DEFOCUS_V_5 2.8e4
-#define DEFOCUS_U_6 3.0e4
-#define DEFOCUS_V_6 3.0e4
-#define DEFOCUS_U_7 3.2e4
-#define DEFOCUS_V_7 3.2e4
-#define DEFOCUS_U_8 3.4e4
-#define DEFOCUS_V_8 3.4e4
-***/
-
-#define THETA 0
-#define CS 0
-
-#define NOISE_FACTOR 3
-
-using namespace std;
-
-INITIALIZE_EASYLOGGINGPP
-
-int main(int argc, char* argv[])
-{
-    loggerInit(argc, argv);
-
-    FFT fft;
-
-    Volume cylinder(N, N, N, RL_SPACE);
-    SET_0_RL(cylinder);
-
-    CLOG(INFO, "LOGGER_SYS") << "Generate Cylinder";
-    VOLUME_FOR_EACH_PIXEL_RL(cylinder)
-        if ((NORM(i, j) < 75.0 / PIXEL_SIZE) &&
-            (abs(k) < 70))
-            cylinder.setRL(1, i, j, k);
-
-    ImageFile imfCylinder;
-
-    CLOG(INFO, "LOGGER_SYS") << "Write Cylinder";
-    imfCylinder.readMetaData(cylinder);
-    imfCylinder.writeVolume("cylinder.mrc", cylinder);
-
-    CLOG(INFO, "LOGGER_SYS") << "Pad Cylinder";
-    Volume padCylinder;
-    VOL_PAD_RL(padCylinder, cylinder, PF);
-
-    CLOG(INFO, "LOGGER_SYS") << "Write padCylinder";
-    imfCylinder.readMetaData(padCylinder);
-    imfCylinder.writeVolume("padCylinder.mrc", padCylinder);
-
-    CLOG(INFO, "LOGGER_SYS") << "Read-in Ref";
-
-    Volume ref;
-    ImageFile imf("ref.mrc", "r");
-    imf.readMetaData();
-    imf.readVolume(ref);
-
-    CLOG(INFO, "LOGGER_SYS") << "Checkout Size";
-    if ((ref.nColRL() != N) ||
-        (ref.nRowRL() != N))
-        CLOG(INFO, "LOGGER_SYS") << "Wrong Size!";
-
-    CLOG(INFO, "LOGGER_SYS") << "Max = " << gsl_stats_max(&ref(0), 1, ref.sizeRL());
-    CLOG(INFO, "LOGGER_SYS") << "Min = " << gsl_stats_min(&ref(0), 1, ref.sizeRL());
-    CLOG(INFO, "LOGGER_SYS") << "Mean = " << gsl_stats_mean(&ref(0), 1, ref.sizeRL());
-
-    double bg = background(ref, N * 1.2 / 2, EDGE_WIDTH_RL);
-
-    CLOG(INFO, "LOGGER_SYS") << "Background of Reference = " << bg;
-
-    CLOG(INFO, "LOGGER_SYS") << "Truncated Ref";
-
-    FOR_EACH_PIXEL_RL(ref)
-        if (ref(i) < 0) ref(i) = 0;
-
-    CLOG(INFO, "LOGGER_SYS") << "Max = " << gsl_stats_max(&ref(0), 1, ref.sizeRL());
-    CLOG(INFO, "LOGGER_SYS") << "Min = " << gsl_stats_min(&ref(0), 1, ref.sizeRL());
-    CLOG(INFO, "LOGGER_SYS") << "Mean = " << gsl_stats_mean(&ref(0), 1, ref.sizeRL());
-
-    imf.readMetaData(ref);
-    imf.writeVolume("truncRef.mrc", ref);
-
-    CLOG(INFO, "LOGGER_SYS") << "Padding Head";
-    Volume padRef;
-    VOL_PAD_RL(padRef, ref, PF);
-    //normalise(padRef);
-
-    CLOG(INFO, "LOGGER_SYS") << "Writing padRef";
-    imf.readMetaData(padRef);
-    imf.writeVolume("padRef.mrc", padRef);
-
-    /***
-    CLOG(INFO, "LOGGER_SYS") << "Reading from Hard-disk";
-    ImageFile imf2("padHead.mrc", "rb");
-    imf2.readMetaData();
-    imf2.readVolume(padHead);
-    ***/
-    
-    CLOG(INFO, "LOGGER_SYS") << "Fourier Transforming Ref";
-    fft.fw(padRef);
-    fft.fw(ref);
-
-    CLOG(INFO, "LOGGER_SYS") << "Sum of ref = " << REAL(ref[0]);
-    CLOG(INFO, "LOGGER_SYS") << "Sum of padRef = " << REAL(padRef[0]);
-
-    CLOG(INFO, "LOGGER_SYS") << "Setting Projectee";
-    Projector projector;
-    projector.setPf(PF);
-    projector.setProjectee(padRef.copyVolume());
-
-    CLOG(INFO, "LOGGER_SYS") << "Setting CTF";
-    Image ctf_1(N, N, FT_SPACE);
-    CTF(ctf_1,
-        PIXEL_SIZE,
-        VOLTAGE,
-        DEFOCUS_U_1,
-        DEFOCUS_V_1,
-        THETA,
-        CS);
-    Image ctf_2(N, N, FT_SPACE);
-    CTF(ctf_2,
-        PIXEL_SIZE,
-        VOLTAGE,
-        DEFOCUS_U_2,
-        DEFOCUS_V_2,
-        THETA,
-        CS);
-    Image ctf_3(N, N, FT_SPACE);
-    CTF(ctf_3,
-        PIXEL_SIZE,
-        VOLTAGE,
-        DEFOCUS_U_3,
-        DEFOCUS_V_3,
-        THETA,
-        CS);
-    Image ctf_4(N, N, FT_SPACE);
-    CTF(ctf_4,
-        PIXEL_SIZE,
-        VOLTAGE,
-        DEFOCUS_U_4,
-        DEFOCUS_V_4,
-        THETA,
-        CS);
-    Image ctf_5(N, N, FT_SPACE);
-    CTF(ctf_5,
-        PIXEL_SIZE,
-        VOLTAGE,
-        DEFOCUS_U_5,
-        DEFOCUS_V_5,
-        THETA,
-        CS);
-    Image ctf_6(N, N, FT_SPACE);
-    CTF(ctf_6,
-        PIXEL_SIZE,
-        VOLTAGE,
-        DEFOCUS_U_6,
-        DEFOCUS_V_6,
-        THETA,
-        CS);
-    Image ctf_7(N, N, FT_SPACE);
-    CTF(ctf_7,
-        PIXEL_SIZE,
-        VOLTAGE,
-        DEFOCUS_U_7,
-        DEFOCUS_V_7,
-        THETA,
-        CS);
-    Image ctf_8(N, N, FT_SPACE);
-    CTF(ctf_8,
-        PIXEL_SIZE,
-        VOLTAGE,
-        DEFOCUS_U_8,
-        DEFOCUS_V_8,
-        THETA,
-        CS);
-
-    CLOG(INFO, "LOGGER_SYS") << "Initialising Experiment";
-    Experiment exp("C15.db");
-    exp.createTables();
-    exp.appendMicrograph("", VOLTAGE, DEFOCUS_U_1, DEFOCUS_V_1, THETA, CS);
-    exp.appendMicrograph("", VOLTAGE, DEFOCUS_U_2, DEFOCUS_V_2, THETA, CS);
-    exp.appendMicrograph("", VOLTAGE, DEFOCUS_U_3, DEFOCUS_V_3, THETA, CS);
-    exp.appendMicrograph("", VOLTAGE, DEFOCUS_U_4, DEFOCUS_V_4, THETA, CS);
-    exp.appendMicrograph("", VOLTAGE, DEFOCUS_U_5, DEFOCUS_V_5, THETA, CS);
-    exp.appendMicrograph("", VOLTAGE, DEFOCUS_U_6, DEFOCUS_V_6, THETA, CS);
-    exp.appendMicrograph("", VOLTAGE, DEFOCUS_U_7, DEFOCUS_V_7, THETA, CS);
-    exp.appendMicrograph("", VOLTAGE, DEFOCUS_U_8, DEFOCUS_V_8, THETA, CS);
-
-    exp.appendGroup("");
-    /***
-    exp.appendGroup("");
-    exp.appendGroup("");
-    exp.appendGroup("");
-    exp.appendGroup("");
-    exp.appendGroup("");
-    exp.appendGroup("");
-    exp.appendGroup("");
-    ***/
-
-    CLOG(INFO, "LOGGER_SYS") << "Initialising Random Sampling Points";
-    Symmetry sym("C15");
-    Particle par(M, TRANS_S, 0.01, &sym);
-    std::cout << "Saving Sampling Points" << std::endl;
-    save("Sampling_Points.par", par);
-
-    Image image(N, N, FT_SPACE);
-    SET_0_FT(image);
-    
-    Coordinate5D coord;
-    par.coord(coord, 0);
-    
-    projector.project(image, coord);
-    fft.bw(image);
-
-    double std = gsl_stats_sd(&image(0), 1, image.sizeRL());
-
-    #pragma omp parallel for
-    for (int i = 0; i < M; i++)
-    {
-        // CLOG(INFO, "LOGGER_SYS") << "Power Spectrum";
-
-        FFT fftThread;
-
-        gsl_rng* engine = get_random_engine();
-
-        char name[256];
-        Coordinate5D coord;
-
-        Image image(N, N, FT_SPACE);
-        SET_0_FT(image);
-
-        sprintf(name, "%05d.mrc", i + 1);
-        printf("%s\n", name);
-
-        par.coord(coord, i);
-        projector.project(image, coord);
-
-        /***
-        vec ps = vec::Zero(N);
-        powerSpectrum(ps, image, N / 2 - 1);
-        ***/
-
-        if (i % 8 == 0)
-        {
-            FOR_EACH_PIXEL_FT(image)
-                image[i] *= REAL(ctf_1[i]);
-        }
-        else if (i % 8 == 1)
-        {
-            FOR_EACH_PIXEL_FT(image)
-                image[i] *= REAL(ctf_2[i]);
-        }
-        else if (i % 8 == 2)
-        {
-            FOR_EACH_PIXEL_FT(image)
-                image[i] *= REAL(ctf_3[i]);
-        }
-        else if (i % 8 == 3)
-        {
-            FOR_EACH_PIXEL_FT(image)
-                image[i] *= REAL(ctf_4[i]);
-        }
-        else if (i % 8 == 4)
-        {
-            FOR_EACH_PIXEL_FT(image)
-                image[i] *= REAL(ctf_5[i]);
-        }
-        else if (i % 8 == 5)
-        {
-            FOR_EACH_PIXEL_FT(image)
-                image[i] *= REAL(ctf_6[i]);
-        }
-        else if (i % 8 == 6)
-        {
-            FOR_EACH_PIXEL_FT(image)
-                image[i] *= REAL(ctf_7[i]);
-        }
-        else
-        {
-            FOR_EACH_PIXEL_FT(image)
-                image[i] *= REAL(ctf_8[i]);
-        }
-
-        /***
-        Image noise(N, N, FT_SPACE);
-        SET_0_FT(noise);
-        IMAGE_FOR_EACH_PIXEL_FT(noise)
-            if (QUAD(i, j) < pow(N / 2 - 1, 2))
-                noise.setFT(COMPLEX(gsl_ran_gaussian(engine, 1 * sqrt(ps(AROUND(NORM(i, j))))),
-                                    gsl_ran_gaussian(engine, 1 * sqrt(ps(AROUND(NORM(i, j)))))),
-                            i,
-                            j);
-                            ***/
-
-        //ADD_FT(image, noise);
-
-        fftThread.bw(image);
-
-        Image noise(N, N, RL_SPACE);
-        FOR_EACH_PIXEL_RL(noise)
-            noise(i) = gsl_ran_gaussian(engine, NOISE_FACTOR * std);
-
-        ADD_RL(image, noise);
-
-        /***
-        printf("image: mean = %f, stddev = %f, maxValue = %f\n",
-               gsl_stats_mean(&image(0), 1, image.sizeRL()),
-               gsl_stats_sd(&image(0), 1, image.sizeRL()),
-               image(cblas_idamax(image.sizeRL(), &image(0), 1)));
-        ***/
-        
-        if (i % 8 == 0)
-        {
-            #pragma omp critical
-            exp.appendParticle(name, 1, 1);
-        }
-        else if (i % 8 == 1)
-        {
-            #pragma omp critical
-            exp.appendParticle(name, 1, 2);
-        }
-        else if (i % 8 == 2)
-        {
-            #pragma omp critical
-            exp.appendParticle(name, 1, 3);
-        }
-        else if (i % 8 == 3)
-        {
-            #pragma omp critical
-            exp.appendParticle(name, 1, 4);
-        }
-        else if (i % 8 == 4)
-        {
-            #pragma omp critical
-            exp.appendParticle(name, 1, 5);
-        }
-        else if (i % 8 == 5)
-        {
-            #pragma omp critical
-            exp.appendParticle(name, 1, 6);
-        }
-        else if (i % 8 == 6)
-        {
-            #pragma omp critical
-            exp.appendParticle(name, 1, 7);
-        }
-        else
-        {
-            #pragma omp critical
-            exp.appendParticle(name, 1, 8);
-        }
-
-        ImageFile imfThread;
-
-        imfThread.readMetaData(image);
-        imfThread.writeImage(name, image);
-
-        fftThread.fw(image);
-    }
-    
-    return 0;
-}
diff --git a/casesrc/case2/ModelGen.cpp b/casesrc/case2/ModelGen.cpp
deleted file mode 100644
index e7ab116..0000000
--- a/casesrc/case2/ModelGen.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-/*******************************************************************************
- * Author: Mingxu Hu
- * Dependecy:
- * Test:
- * Execution:
- * Description:
- * ****************************************************************************/
-
-#include <iostream>
-
-#include "ImageFile.h"
-#include "Volume.h"
-
-#define N 380
-
-using namespace std;
-
-INITIALIZE_EASYLOGGINGPP
-
-int main(int argc, char* argv[])
-{
-    loggerInit(argc, argv);
-
-    std::cout << "Read-in Volume" << std::endl;
-    Volume vol;
-    ImageFile imf("ref.mrc", "r");
-    imf.readVolume(vol);
-
-    return 0;
-}
diff --git a/casesrc/case2/Run.cpp b/casesrc/case2/Run.cpp
deleted file mode 100644
index 8acca30..0000000
--- a/casesrc/case2/Run.cpp
+++ /dev/null
@@ -1,86 +0,0 @@
-/*******************************************************************************
- * Author: Mingxu Hu
- * Dependecy:
- * Test:
- * Execution:
- * Description:
- * ****************************************************************************/
-
-#include <iostream>
-
-#include "Projector.h"
-#include "Reconstructor.h"
-#include "FFT.h"
-#include "ImageFile.h"
-#include "Particle.h"
-#include "CTF.h"
-#include "Experiment.h"
-#include "MLOptimiser.h"
-
-#define PF 2
-
-#define N 380
-#define TRANS_S 10
-
-//#define PIXEL_SIZE 1.32
-#define PIXEL_SIZE 1.30654
-
-#define MG 1000
-#define ML 100
-
-using namespace std;
-
-INITIALIZE_EASYLOGGINGPP
-
-int main(int argc, char* argv[])
-{
-    loggerInit(argc, argv);
-
-    MPI_Init(&argc, &argv);
-
-    std::cout << "Initialising Parameters" << std::endl;
-    MLOptimiserPara para;
-    para.iterMax = atoi(argv[1]);
-    para.k = 1;
-    para.size = N;
-    para.pf = PF;
-    //para.a = 0.95;
-    para.a = 1.9;
-    para.alpha = 10;
-    para.pixelSize = PIXEL_SIZE;
-    //para.maskRadius = 250;
-    para.maskRadius = 130;
-    para.mG = MG;
-    para.mL = ML;
-    para.transS = TRANS_S;
-    //para.initRes = 20;
-    para.initRes = 40;
-    //para.ignoreRes = 200;
-    para.ignoreRes = 200;
-    //para.sclCorRes = 40;
-    para.sclCorRes = 80;
-    //para.globalSearchRes = 15;
-    //para.globalSearchRes = 10;
-    //para.globalSearchRes = 40;
-    para.globalSearchRes = 12;
-    sprintf(para.sym, "C15");
-    // sprintf(para.initModel, "padCylinder.mrc");
-    sprintf(para.initModel, "padRef.mrc");
-    sprintf(para.db, "C15.db");
-    para.groupSig = true;
-    para.groupScl = false;
-    //para.groupScl = true;
-    para.zeroMask = false;
-
-    std::cout << "Setting Parameters" << std::endl;
-    MLOptimiser opt;
-    opt.setPara(para);
-
-    std::cout << "MPISetting" << std::endl;
-    opt.setMPIEnv();
-
-    std::cout << "Run" << std::endl;
-    opt.run();
-
-    MPI_Finalize();
-}
diff --git a/include/Config.h b/include/Config.h
index 22fbcc6..4f10671 100644
--- a/include/Config.h
+++ b/include/Config.h
@@ -31,6 +31,8 @@
 
 #define NOISE_ZERO_MEAN
 
+#define RECONSTRUCTOR_ASSERT_CHECK
+
 //#define RECONSTRUCTOR_MKB_KERNEL
 
 #define RECONSTRUCTOR_TRILINEAR_KERNEL
@@ -47,13 +49,17 @@
 
 #define RECONSTRUCTOR_SYMMETRIZE_DURING_RECONSTRUCT
 
-//#define RECONSTRUCTOR_WIENER_FILTER_FSC
+#define RECONSTRUCTOR_WIENER_FILTER_FSC
 
 #ifdef RECONSTRUCTOR_WIENER_FILTER_FSC
 #define RECONSTRUCTOR_WIENER_FILTER_FSC_FREQ_AVG
 #endif
 
-#define RECONSTRUCTOR_WIENER_FITLER_CONST
+//#define RECONSTRUCTOR_WIENER_FITLER_CONST
+
+//#define RECONSTRUCTOR_REMOVE_NEG
+
+//#define PROJECTOR_REMOVE_NEG
 
 #ifdef NOISE_ZERO_MEAN
 #define RECONSTRUCTOR_ZERO_MASK
@@ -64,18 +70,19 @@
 #endif
 
 #ifdef NOISE_ZERO_MEAN
-#define OPTIMISER_ADJUST_2D_IMAGE_NOISE_ZERO_MEAN
+//#define OPTIMISER_ADJUST_2D_IMAGE_NOISE_ZERO_MEAN
 #endif
 
 #define OPTIMISER_RECENTRE_IMAGE_EACH_ITERATION
 
-//#define OPTIMISER_COMPRESS_WEIGHTING
+//#define OPTIMISER_DYNAMIC_NUM_SAMPLE
 
 //#define OPTIMISER_SIGMA_MASK
 //#define OPTIMISER_SCALE_MASK
+#define OPTIMISER_NORM_MASK
 
 #ifdef OPTIMISER_RECENTRE_IMAGE_EACH_ITERATION
-#define PARTICLE_CAL_VARI_TRANS_ZERO_MEAN
+//#define PARTICLE_CAL_VARI_TRANS_ZERO_MEAN
 #endif
 
 #define PARTICLE_TRANS_INIT_GAUSSIAN
diff --git a/include/Error/Error.h b/include/Error/Error.h
deleted file mode 100644
index 102f817..0000000
--- a/include/Error/Error.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*******************************************************************************
- * Author: Mingxu Hu
- * Dependency:
- * Test:
- * Execution:
- * Description:
- *
- * Manual:
- * ****************************************************************************/
-
-#ifndef ERROR_H
-#define ERROR_H
-
-#include <cstdlib>
-#include <iostream>
-#include <string>
-#include <stdexcept>
-
-#define REPORT_ERROR(ErrMsg) throw Error(ErrMsg, __FILE__, __LINE__)
-
-class Error : public std::exception
-{
-    private:
-
-        std::string _errMsg;
-        std::string _file;
-        mutable std::string _totalMsg;
-
-        int _line;
-
-    public:
-
-        Error(const std::string& errMsg,
-              const std::string& file,
-              const int line);
-
-        friend std::ostream& operator<<(std::ostream& os, const Error& error);
-
-        const char* what() const throw();
-
-        ~Error() throw() {}
-};
-
-#endif // ERROR_H
diff --git a/include/FFT.h b/include/FFT.h
index b4a8bdd..8e24f7b 100644
--- a/include/FFT.h
+++ b/include/FFT.h
@@ -18,10 +18,10 @@
 #include <omp_compat.h>
 
 #include "Complex.h"
-#include "Error.h"
 
 #include "Image.h"
 #include "Volume.h"
+#include "ImageFunctions.h"
 
 /**
  * This macro checks whether the source and destination of Fourier transform are
@@ -34,12 +34,12 @@
 { \
     if (src == NULL) \
     { \
-        CLOG(FATAL, "LOGGER_FFT") << "FFT Needs Input Data."; \
+        REPORT_ERROR("FFT Needs Input Data."); \
         abort(); \
     } \
     if (dst == NULL) \
     { \
-        CLOG(FATAL, "LOGGER_FFT") << "FFT Needs Ouput Space."; \
+        REPORT_ERROR("FFT Needs Output Data."); \
         abort(); \
     } \
 }
@@ -341,27 +341,47 @@ class FFT
         void bwMT(Volume& vol);
 
         void fwCreatePlan(const int nCol,
+                          const int nRow);
+
+        void fwCreatePlan(const int nCol,
                           const int nRow,
                           const int nSlc);
 
         void bwCreatePlan(const int nCol,
+                          const int nRow);
+
+        void bwCreatePlan(const int nCol,
                           const int nRow,
                           const int nSlc);
 
         void fwCreatePlanMT(const int nCol,
+                            const int nRow);
+
+        void fwCreatePlanMT(const int nCol,
                             const int nRow,
                             const int nSlc);
 
         void bwCreatePlanMT(const int nCol,
+                            const int nRow);
+
+        void bwCreatePlanMT(const int nCol,
                             const int nRow,
                             const int nSlc);
 
+        void fwExecutePlan(Image& img);
+
         void fwExecutePlan(Volume& vol);
 
+        void bwExecutePlan(Image& img);
+
         void bwExecutePlan(Volume& vol);
 
+        void fwExecutePlanMT(Image& img);
+
         void fwExecutePlanMT(Volume& vol);
 
+        void bwExecutePlanMT(Image& img);
+
         void bwExecutePlanMT(Volume& vol);
 
         void fwDestroyPlan();
diff --git a/include/Functions/DirectionalStat.h b/include/Functions/DirectionalStat.h
index d8979cf..52181f7 100644
--- a/include/Functions/DirectionalStat.h
+++ b/include/Functions/DirectionalStat.h
@@ -16,39 +16,141 @@
 
 #include <gsl/gsl_statistics.h>
 #include <gsl/gsl_math.h>
+#include <gsl/gsl_sf_bessel.h>
 
+#include "Config.h"
+#include "Macro.h"
 #include "Typedef.h"
 #include "Random.h"
 
-
-
 /**
  * Probabilty Density Function of Angular Central Gaussian Distribution
  *
- * @param x a quaternion
+ * @param x   a quaternion
  * @param sig a symmetric positive definite parameter matrix
  */
 double pdfACG(const vec4& x,
               const mat44& sig);
 
+/**
+ * Probability Density Function of Angular Central Gaussian Distribution
+ *
+ * paramter matrxix:
+ * k0 0  0  0
+ * 0  k1 0  0
+ * 0  0  k1 0
+ * 0  0  0  k1 
+ *
+ * @param x q quaterion
+ * @param k0 the first paramter
+ * @param k1 the second parameter
+ */
 double pdfACG(const vec4& x,
               const double k0,
               const double k1);
 
+/**
+ * Sample from an Angular Central Gaussian Distribution
+ *
+ * @param dst the destination table
+ * @param src the symmetric positive definite parameter matrix
+ * @param n   the number of samples
+ */
 void sampleACG(mat4& dst,
                const mat44& src,
                const int n);
 
+/**
+ * Sample from an Angular Central Gaussian Distribution
+ *
+ * paramter matrxix:
+ * k0 0  0  0
+ * 0  k1 0  0
+ * 0  0  k1 0
+ * 0  0  0  k1 
+ *
+ * @param dst the destination table
+ * @param k0  the first parameter
+ * @param k1  the second parameter
+ * @param n   the number of samples
+ */
 void sampleACG(mat4& dst,
                const double k0,
                const double k1,
                const int n);
 
+/**
+ * Paramter Matrix Inference from Data Assuming the Distribution Follows an
+ * Angular Central Gaussian Distribution
+ *
+ * @param dst the paramter matrix
+ * @param src the data
+ */
 void inferACG(mat44& dst,
               const mat4& src);
 
+/**
+ * Parameter Inference from Data Assuming the Distribution Follows an Angular
+ * Central Gaussian Distribution
+ *
+ * @param k0  the first parameter
+ * @param k1  the second paramter
+ * @param src the data
+ */
 void inferACG(double& k0,
               double& k1,
               const mat4& src);
 
+/**
+ * Probabilty Density Function of von Mises Distribution M(mu, kappa)
+ *
+ * @param x     the orientation in unit vector
+ * @param mu    the mode of the von Mises distribution in unit vector
+ * @param kappa the concnetration parameter of the von Mises distribution
+ */
+double pdfVMS(const vec2& x,
+              const vec2& mu,
+              const double kappa);
+
+/**
+ * Sample from von Mises Distribution M(mu, kappa), the algorithm is from Best &
+ * Fisher (1979)
+ *
+ * @param dst   the destination table
+ * @param mu    the mode of the von Mises distribution
+ * @param kappa the concentration parameter of the von Mises distribution
+ * @param n     number of sample
+ */
+void sampleVMS(mat2& dst,
+               const vec2& mu,
+               const double kappa,
+               const double n);
+
+void sampleVMS(mat4& dst,
+               const vec4& mu,
+               const double kappa,
+               const double n);
+
+/**
+ * Mode and Concentration Paramter Inference from Data Assuming the Distribution
+ * Follows a von Mises Distribution
+ *
+ * @param mu    the mode of the von Mises distribution
+ * @param kappa the concentration paramter of the von Mises distribution
+ * @param src    the data
+ */
+void inferVMS(vec2& mu,
+              double& kappa,
+              const mat2& src);
+
+void inferVMS(double& kappa,
+              const mat2& src);
+
+void inferVMS(vec4& mu,
+              double& kappa,
+              const mat4& src);
+
+void inferVMS(double& kappa,
+              const mat4& src);
+
 #endif // DIRECTIONAL_STAT_H
diff --git a/include/Functions/Mask.h b/include/Functions/Mask.h
index e193430..d491d57 100644
--- a/include/Functions/Mask.h
+++ b/include/Functions/Mask.h
@@ -83,6 +83,10 @@ double background(const Volume& vol,
 double background(const Volume& vol,
                   const Volume& alpha);
 
+void softMask(Image& mask,
+              const double r,
+              const double ew);
+
 /**
  * This function applys a soft mask on an image. The soft mask is calculated
  * from the source image with a certain radius and edge width.
@@ -172,6 +176,10 @@ void softMask(Image& dst,
               const double bgMean,
               const double bgStd);
 
+void softMask(Volume& mask,
+              const double r,
+              const double ew);
+
 /**
  * This function applys a soft mask on a volume. The soft mask is calculated
  * from the source volume with a certain radius and edge width.
diff --git a/include/Functions/Random.h b/include/Functions/Random.h
index 7a88864..b3de806 100644
--- a/include/Functions/Random.h
+++ b/include/Functions/Random.h
@@ -25,8 +25,6 @@
 
 #include "Logging.h"
 
-
-
 gsl_rng* get_random_engine();
 
 #endif // RANDOM_H
diff --git a/include/Functions/Spectrum.h b/include/Functions/Spectrum.h
index 510f08c..77f6894 100644
--- a/include/Functions/Spectrum.h
+++ b/include/Functions/Spectrum.h
@@ -15,7 +15,6 @@
 #include <gsl/gsl_randist.h>
 #include <gsl/gsl_fit.h>
 
-#include "Error.h"
 #include "Typedef.h"
 
 #include "Image.h"
@@ -154,6 +153,11 @@ void FRC(vec& dst,
          const Image& A,
          const Image& B);
 
+void FRC(vec& dst,
+         const Volume& A,
+         const Volume& B,
+         const int k);
+
 /** 
  * This functions calculates the FSC (Fourier Shell Coefficient) between two
  * volumes.
diff --git a/include/Geometry/Euler.h b/include/Geometry/Euler.h
index 5280d28..bb968d7 100644
--- a/include/Geometry/Euler.h
+++ b/include/Geometry/Euler.h
@@ -22,9 +22,10 @@
 /**
  * This function calculates phi and theta given a certain direction indicated by
  * a 3-vector.
- * @param phi phi
+ *
+ * @param phi   phi
  * @param theta theta
- * @param src 3-vector indicating the direction
+ * @param src   3-vector indicating the direction
  */
 void angle(double& phi,
            double& theta,
@@ -32,10 +33,11 @@ void angle(double& phi,
 
 /**
  * This function calculates phi, theta and psi given the rotation matrix.
- * @param phi phi
+ *
+ * @param phi   phi
  * @param theta theta
- * @param psi psi
- * @param src the rotation matrix
+ * @param psi   psi
+ * @param src   the rotation matrix
  */
 void angle(double& phi,
            double& theta,
@@ -45,10 +47,11 @@ void angle(double& phi,
 /**
  * This function calculates phi, theta and psi given the quaternion indicated
  * by a 4-vector.
- * @param phi phi
+ *
+ * @param phi   phi
  * @param theta theta
- * @param psi psi
- * @param src the quaternion
+ * @param psi   psi
+ * @param src   the quaternion
  */
 void angle(double& phi,
            double& theta,
@@ -57,10 +60,11 @@ void angle(double& phi,
 
 /**
  * This function calculate the quaternion given phi, theta and psi.
- * @param dst the quaternion to be calculated
- * @param phi phi
+ *
+ * @param dst   the quaternion to be calculated
+ * @param phi   phi
  * @param theta theta
- * @param psi psi
+ * @param psi   psi
  */
 void quaternoin(vec4& dst,
                 const double phi,
@@ -68,7 +72,16 @@ void quaternoin(vec4& dst,
                 const double psi);
 
 /**
+ * This function calculates the rotation matrix given the a unit vector.
+ *
+ * @param dst the rotation matrix
+ * @param vec the unit vector
+ */
+void rotate2D(mat22& dst, const vec2& vec);
+
+/**
  * This function calculates the rotation matrix given phi in 2D.
+ *
  * @param dst the rotation matrix
  * @param phi phi
  */
@@ -77,9 +90,10 @@ void rotate2D(mat22& dst, const double phi);
 /**
  * This function calculates the direction vector given phi and theta. The 2-norm
  * of this direction vector is 1.
- * @param dst the direction vector
- * @param phi phi
- * @param theta
+ *
+ * @param dst   the direction vector
+ * @param phi   phi
+ * @param theta theta
  */
 void direction(vec3& dst,
                const double phi,
@@ -87,10 +101,11 @@ void direction(vec3& dst,
 
 /**
  * This function calculates the rotation matrix given phi, theta and psi.
- * @param dst the rotation matrix
- * @param phi phi
+ *
+ * @param dst   the rotation matrix
+ * @param phi   phi
  * @param theta theta
- * @param psi psi
+ * @param psi   psi
  */
 void rotate3D(mat33& dst,
               const double phi,
@@ -99,6 +114,7 @@ void rotate3D(mat33& dst,
 
 /**
  * This function calculates the rotation matrix given a quaternion.
+ *
  * @param dst the rotation matrix
  * @param src the quaternion
  */
@@ -107,6 +123,7 @@ void rotate3D(mat33& dst,
 
 /**
  * This function calculates the rotation matrix of rotation along X-axis of phi.
+ *
  * @param dst the rotation matrix
  * @param phi phi
  */
@@ -114,6 +131,7 @@ void rotate3DX(mat33& dst, const double phi);
 
 /**
  * This function calculates the rotation matrix of rotation along Y-axis of phi.
+ *
  * @param dst the rotation matrix
  * @param phi phi
  */
@@ -121,6 +139,7 @@ void rotate3DY(mat33& dst, const double phi);
 
 /**
  * This function calculates the rotation matrix of rotation along Z-axis of phi.
+ *
  * @param dst the rotation matrix
  * @param phi phi
  */
@@ -129,6 +148,7 @@ void rotate3DZ(mat33& dst, const double phi);
 /**
  * This function calculates the rotation matrix for aligning a direction vector
  * to Z-axis.
+ *
  * @param dst the rotation matrix
  * @param vec the direction vector
  */
@@ -138,7 +158,8 @@ void alignZ(mat33& dst,
 /**
  * This function calculates the rotation matrix of rotation along a certain axis
  * (X, Y or Z) of phi.
- * @param dst the rotation matrix
+ *
+ * @param dst  the rotation matrix
  * @param axis a character indicating which axis the rotation is along
  */
 void rotate3D(mat33& dst,
@@ -148,8 +169,9 @@ void rotate3D(mat33& dst,
 /**
  * This function calculates the rotation matrix of rotation along a certain axis
  * given by a direction vector of phi.
- * @param dst the rotation matrix
- * @param phi phi
+ *
+ * @param dst  the rotation matrix
+ * @param phi  phi
  * @param axis the direction vector indicating the axis
  */
 void rotate3D(mat33& dst,
@@ -159,7 +181,8 @@ void rotate3D(mat33& dst,
 /**
  * This function calculates the transformation matrix of reflection against a
  * certain plane given by its normal vector.
- * @param dst the rotation matrix
+ *
+ * @param dst   the rotation matrix
  * @param plane the normal vector the reflection plane
  */
 void reflect3D(mat33& dst,
@@ -168,6 +191,7 @@ void reflect3D(mat33& dst,
 /**
  * This function calculates the singular matrix of translation of a certain
  * vector.
+ *
  * @param dst the singular matrix
  * @param vec the translation vector
  */
@@ -176,16 +200,25 @@ void translate3D(mat44& dst,
 
 /**
  * This function calculates the transformation matrix of scaling.
+ *
  * @param dst the transformation matrix
  * @param vec a 3-vector of which vec[0] indicates the scale factor along X
- * axis, vec[1] indicates the scale factor along Y axis and vec[2] indicates the
- * scale factor along Z axis
+ *            axis, vec[1] indicates the scale factor along Y axis and vec[2]
+ *            indicates the scale factor along Z axis
  */
 void scale3D(mat33& dst,
              const vec3& vec);
 
-void randQuaternion(vec4& quat);
+/**
+ * This function generates a random unit quaternion.
+ */
+//void randQuaternion(vec4& quat);
+
+void randRotate2D(mat22& rot);
 
+/**
+ * This function generates a random 3D rotation matrix.
+ */
 void randRotate3D(mat33& rot);
 
 #endif // EULER_H 
diff --git a/include/Geometry/Symmetry.h b/include/Geometry/Symmetry.h
index ac310e8..c59b589 100644
--- a/include/Geometry/Symmetry.h
+++ b/include/Geometry/Symmetry.h
@@ -17,21 +17,17 @@
 
 #include "Macro.h"
 #include "Typedef.h"
-#include "Error.h"
 #include "Logging.h"
 
-#include "Euler.h"
 #include "PointGroup.h"
 #include "SymmetryOperation.h"
 #include "SymmetryFunctions.h"
 
-
-
 /**
  * Maximum ID Length of Symmetry
  * Example: C5, C4H, O, I, D2V
  */
-#define SYM_ID_LENGTH 4
+#define SYM_ID_LENGTH 5
 
 /**
  * This macros determines whether A and B matrix is equal with tolerence of 1e4.
diff --git a/include/Geometry/SymmetryFunctions.h b/include/Geometry/SymmetryFunctions.h
index 4509d0b..087d43f 100644
--- a/include/Geometry/SymmetryFunctions.h
+++ b/include/Geometry/SymmetryFunctions.h
@@ -13,10 +13,8 @@
 
 #include <cstdlib>
 
-
 #include "Macro.h"
 #include "Typedef.h"
-#include "Error.h"
 #include "Logging.h"
 
 #include "Euler.h"
@@ -24,8 +22,6 @@
 #include "SymmetryOperation.h"
 #include "Utils.h"
 
-
-
 /**
  * This function translates a string indicating the symmetry group to the code
  * of symmetry group and the order in that group.
diff --git a/include/Geometry/SymmetryOperation.h b/include/Geometry/SymmetryOperation.h
index a64fa36..a37a625 100644
--- a/include/Geometry/SymmetryOperation.h
+++ b/include/Geometry/SymmetryOperation.h
@@ -15,10 +15,8 @@
 
 #include "Macro.h"
 #include "Typedef.h"
-#include "Error.h"
 #include "Utils.h"
 
-
 /**
  * @ingroup SymmetryOperation
  * @brief Symmetry Operation of Rotation
diff --git a/include/Geometry/Transformation.h b/include/Geometry/Transformation.h
index 71fa946..070be95 100644
--- a/include/Geometry/Transformation.h
+++ b/include/Geometry/Transformation.h
@@ -17,7 +17,6 @@
 #include "Config.h"
 #include "Macro.h"
 #include "Typedef.h"
-#include "Error.h"
 
 #include "Euler.h"
 
diff --git a/include/Image/Image.h b/include/Image/Image.h
index f72e4f0..436cc9f 100644
--- a/include/Image/Image.h
+++ b/include/Image/Image.h
@@ -17,7 +17,6 @@
 #include "Config.h"
 #include "Macro.h"
 #include "Typedef.h"
-#include "Error.h"
 #include "Complex.h"
 #include "Logging.h"
 
@@ -64,7 +63,19 @@
     for (int j = -r; j < r; j++) \
         for (int i = 0; i <= r; i++)
 
-inline bool conjHalf(int& iCol, int& iRow)
+inline bool conjHalf(int& iCol,
+                     int& iRow)
+{
+    if (iCol >= 0) return false;
+
+    iCol *= -1;
+    iRow *= -1;
+
+    return true;
+};
+
+inline bool conjHalf(double& iCol,
+                     double& iRow)
 {
     if (iCol >= 0) return false;
 
@@ -229,6 +240,26 @@ class Image : public ImageBase
                    int iCol,
                    int iRow);
 
+        void setFTHalf(const Complex value,
+                       const int iCol,
+                       const int iRow);
+
+        void addFT(const Complex value,
+                   int iCol,
+                   int iRow);
+
+        void addFTHalf(const Complex value,
+                       const int iCol,
+                       const int iRow);
+
+        void addFT(const double value,
+                   int iCol,
+                   int iRow);
+
+        void addFTHalf(const double value,
+                       const int iCol,
+                       const int iRow);
+
         /**
          * This function gets the value of an irregular pixel by bi-linear
          * interpolation in real space.
@@ -247,6 +278,18 @@ class Image : public ImageBase
         Complex getBiLinearFT(const double iCol,
                               const double iRow) const;
 
+        Complex getByInterpolationFT(double iCol,
+                                     double iRow,
+                                     const int interp) const;
+
+        void addFT(const Complex value,
+                   double iCol,
+                   double iRow);
+
+        void addFT(const double value,
+                   double iCol,
+                   double iRow);
+
         void clear()
         {
             ImageBase::clear();
@@ -261,6 +304,15 @@ class Image : public ImageBase
                  + (i >= 0 ? i : i + _nCol);
         }
 
+        inline int iFT(int i,
+                       int j) const
+        {
+            if (i >= 0)
+                return iFTHalf(i, j);
+            else
+                return iFTHalf(-i, -j);
+        }
+
         inline int iFT(bool& conj,
                        int i,
                        int j) const
@@ -299,6 +351,17 @@ class Image : public ImageBase
          */
         void coordinatesInBoundaryFT(const int iCol,
                                      const int iRow) const;
+
+        Complex getFTHalf(const double w[2][2],
+                          const int x0[2]) const;
+
+        void addFTHalf(const Complex value,
+                       const double w[2][2],
+                       const int x0[2]);
+
+        void addFTHalf(const double value,
+                       const double w[2][2],
+                       const int x0[2]);
 };
 
 #endif // IMAGE_H
diff --git a/include/Image/ImageBase.h b/include/Image/ImageBase.h
index b5a622a..5d4bb43 100644
--- a/include/Image/ImageBase.h
+++ b/include/Image/ImageBase.h
@@ -122,6 +122,14 @@
     FOR_EACH_PIXEL_FT(base) \
         (base)[i] *= a
 
+#define COPY_RL(a, b) \
+    FOR_EACH_PIXEL_RL(a) \
+        (a)(i) = b(i)
+
+#define COPY_FT(a, b) \
+    FOR_EACH_PIXEL_FT(a) \
+        (a)[i] = b[i]
+
 /**
  * This macro adds each pixel from B to A respectively in real space.
  * @param a Image / Volume A
@@ -158,6 +166,10 @@
     FOR_EACH_PIXEL_FT(a) \
         (a)[i] -= (b)[i]
 
+#define MUL_RL(a, b) \
+    FOR_EACH_PIXEL_RL(a) \
+        (a)(i) *= (b)(i)
+
 /**
  * This macro multiplys each pixel of A with the pixel of B respectively in Fourier space.
  * @param a Image / Volume A
@@ -167,6 +179,10 @@
     FOR_EACH_PIXEL_FT(a) \
         (a)[i] *= (b)[i]
 
+#define DIV_RL(a, b) \
+    FOR_EACH_PIXEL_RL(a) \
+        (a)(i) /= (b)(i)
+
 /**
  * This macro divides each pixel of A with the pixel of B respectively in Fourier space.
  * @param a Image / Volume A
diff --git a/include/Image/ImageFile.h b/include/Image/ImageFile.h
index 16b8a14..aab7d48 100644
--- a/include/Image/ImageFile.h
+++ b/include/Image/ImageFile.h
@@ -46,7 +46,6 @@ struct ImageMetaData
 #include <cstdio>
 #include <iostream>
 
-#include "Error.h"
 #include "Logging.h"
 
 #include "MRCHeader.h"
diff --git a/include/Image/ImageFunctions.h b/include/Image/ImageFunctions.h
index 2e64252..2f7e3a3 100644
--- a/include/Image/ImageFunctions.h
+++ b/include/Image/ImageFunctions.h
@@ -95,6 +95,20 @@ inline void VOL_REPLACE_FT(Volume& dst, const Volume& src)
         dst.setFT(src.getFT(i, j, k), i, j, k); 
 }
 
+inline void IMG_PAD_RL(Image& dst,
+                       const Image& src,
+                       const int pf)
+{
+    dst.alloc(pf * src.nColRL(),
+              pf * src.nRowRL(),
+              RL_SPACE);
+
+    SET_0_RL(dst);
+
+    IMAGE_FOR_EACH_PIXEL_RL(src)
+        dst.setRL(src.getRL(i, j), i, j);
+}
+
 /**
  * This function pads a volume in real space.
  *
@@ -102,7 +116,9 @@ inline void VOL_REPLACE_FT(Volume& dst, const Volume& src)
  * @param src the source volume
  * @param pf  the padding factor
  */
-inline void VOL_PAD_RL(Volume& dst, const Volume& src, const int pf) 
+inline void VOL_PAD_RL(Volume& dst,
+                       const Volume& src,
+                       const int pf) 
 { 
     dst.alloc(pf * src.nColRL(), 
               pf * src.nRowRL(), 
@@ -117,6 +133,20 @@ inline void VOL_PAD_RL(Volume& dst, const Volume& src, const int pf)
         dst.setRL(src.getRL(i, j, k), i, j, k); 
 }
 
+inline void IMG_PAD_FT(Image& dst,
+                       const Image& src,
+                       const int pf)
+{
+    dst.alloc(pf * src.nColRL(),
+              pf * src.nRowRL(),
+              FT_SPACE);
+
+    SET_0_FT(dst);
+
+    IMAGE_FOR_EACH_PIXEL_FT(src)
+        dst.setFT(src.getFT(i, j), i, j);
+}
+
 /**
  * This function pads a volume in Fourier space.
  *
@@ -124,7 +154,9 @@ inline void VOL_PAD_RL(Volume& dst, const Volume& src, const int pf)
  * @param src the source volume
  * @param pf  the padding factor
  */
-inline void VOL_PAD_FT(Volume& dst, const Volume& src, const int pf) 
+inline void VOL_PAD_FT(Volume& dst,
+                       const Volume& src,
+                       const int pf) 
 { 
     dst.alloc(pf * src.nColRL(), 
               pf * src.nRowRL(), 
@@ -451,6 +483,15 @@ void meanStddev(double& mean,
                 double& stddev,
                 const Image& src);
 
+double centreStddev(const double mean,
+                    const Image& src,
+                    const double r);
+
+void centreMeanStddev(double& mean,
+                      double& stddev,
+                      const Image& src,
+                      const double r);
+
 /**
  * This function calculates the standard deviation of the background when the
  * mean value is given.
diff --git a/include/Image/Volume.h b/include/Image/Volume.h
index 9bcc94e..4408a9e 100644
--- a/include/Image/Volume.h
+++ b/include/Image/Volume.h
@@ -1,4 +1,4 @@
-/*******************************************************************************
+ /*******************************************************************************
  * Author: Mingxu Hu
  * Dependency:
  * Test:
@@ -19,7 +19,6 @@
 #include "Config.h"
 #include "Macro.h"
 #include "Typedef.h"
-#include "Error.h"
 #include "Complex.h"
 #include "Logging.h"
 
diff --git a/include/Logging.h b/include/Logging.h
index 4c7640a..2e32615 100644
--- a/include/Logging.h
+++ b/include/Logging.h
@@ -17,11 +17,18 @@
 
 #include "Macro.h"
 
-
-// Compatibility settings for
 namespace el = easyloggingpp;
+
 #define INITIALIZE_EASYLOGGINGPP _INITIALIZE_EASYLOGGINGPP
 
+#define REPORT_ERROR(msg) CLOG(FATAL, "LOGGER_SYS") << __FILE__ \
+                                                    << ", " \
+                                                    << __LINE__ \
+                                                    << ", " \
+                                                    << __FUNCTION__ \
+                                                    << ": " \
+                                                    << msg;
+
 void loggerInit(int argc, const char* const * argv);
 
 #endif // LOGGING_H
diff --git a/include/ML/MLModel.h b/include/ML/MLModel.h
index 409d723..82a273e 100644
--- a/include/ML/MLModel.h
+++ b/include/ML/MLModel.h
@@ -73,6 +73,10 @@ class MLModel : public Parallel
 {
     private:
 
+        int _mode;
+
+        bool _refine;
+
         /**
          * references in Fourier space
          */
@@ -95,7 +99,7 @@ class MLModel : public Parallel
         /**
          * tau^2
          * each column stands for the power spectrum of a certain reference
-         * (_rU * _pf / 2 - 1) x _k
+         * (_rU * _pf - 1) x _k
          */
         mat _tau;
 
@@ -259,6 +263,8 @@ class MLModel : public Parallel
          */
         MLModel()
         {
+            _mode = MODE_3D;
+            _refine = true;
             _r = 1;
             _rU = 1;
             _rPrev = 1;
@@ -293,6 +299,7 @@ class MLModel : public Parallel
         /**
          * This function initialises the MLModel object.
          *
+         * @param mode      2D or 3D mode
          * @param k         number of references
          * @param size      size of references before padding
          * @param r         radius of calculating FSC and SNR before padding
@@ -302,7 +309,9 @@ class MLModel : public Parallel
          * @param alpha     smoothness parameter of modified Kaiser-Bessel function
          * @param sym       the symmetry information
          */
-        void init(const int k,
+        void init(const int mode,
+                  const bool refine,
+                  const int k,
                   const int size,
                   const int r,
                   const int pf,
@@ -311,6 +320,14 @@ class MLModel : public Parallel
                   const double alpha,
                   const Symmetry* sym);
 
+        int mode() const;
+
+        void setMode(const int mode);
+
+        bool refine() const;
+
+        void setRefine(const bool refine);
+
         /**
          * This function initialises projectors and reconstructors.
          */
@@ -693,11 +710,6 @@ class MLModel : public Parallel
          */
         void setIncreaseR(const bool increaseR);
 
-        void sharpenUp(const bool fscWeighting);
-
-        void sharpenUp(const double bFactor,
-                       const bool fscWeighting);
-
         /**
          * This function update the frequency for reconstruction and calculating
          * FSC, SNR by the frequency before padding (in pixel).
diff --git a/include/ML/MLOptimiser.h b/include/ML/MLOptimiser.h
index 830fbbc..a30f9d3 100644
--- a/include/ML/MLOptimiser.h
+++ b/include/ML/MLOptimiser.h
@@ -11,11 +11,6 @@
 #ifndef ML_OPTIMISER_H
 #define ML_OPTIMISER_H
 
-#define SCAN_SOFT_PROCESS
-#define DEEP_SOFT_PROCESS
-
-#define DYNAMIC_NUM_SAMPLE
-
 #include <cstdlib>
 #include <sstream>
 #include <string>
@@ -55,16 +50,6 @@
 #define MIN_N_PHASE_PER_ITER 10
 #define MAX_N_PHASE_PER_ITER 100
 
-#define PERTURB_FACTOR_L 100
-#define PERTURB_FACTOR_S 0.01
-
-//#define GEN_MASK_RES 30
-
-#define TRANS_SEARCH_FACTOR 1
-
-//#define SOLVENT_FLATTEN_LOOSE_FACTOR 2
-#define SOLVENT_FLATTEN_LOOSE_FACTOR 1.5
-
 #define SWITCH_FACTOR 3
 
 #define N_SAVE_IMG 20
@@ -90,6 +75,16 @@ inline void PROCESS_LOGW_HARD(vec& _logW)
 struct MLOptimiserPara
 {
     /**
+     * 2D or 3D mode
+     */
+    int mode;
+
+    /**
+     * refine or not
+     */
+    bool refine;
+
+    /**
      * number of classes
      */
     int k;
@@ -242,8 +237,16 @@ struct MLOptimiserPara
      */
     bool zeroMask;
 
+    double transSearchFactor;
+
+    double perturbFactorL;
+
+    double perturbFactorS;
+
     MLOptimiserPara()
     {
+        mode = MODE_3D;
+        refine = true;
         autoSelection = false;
         localCTF = false;
         performMask = true;
@@ -253,9 +256,13 @@ struct MLOptimiserPara
         bFactor = 200;
         pf = 2;
         a = 1.9;
-        alpha = 10;
+        alpha = 15;
         thresCutoffFSC = 0.5;
         thresReportFSC = 0.143;
+        thresSclCorFSC = 0.75;
+        transSearchFactor = 1;
+        perturbFactorL = 2;
+        perturbFactorS = 0.5;
     }
 };
 
@@ -434,6 +441,11 @@ class MLOptimiser : public Parallel
         double _stdStdN;
 
         /**
+         * images distribution over classes
+         */
+        vec _cDistr;
+
+        /**
          * whether to generate mask or not
          */
         bool _genMask;
@@ -645,6 +657,8 @@ class MLOptimiser : public Parallel
          */
         void refreshRotationChange();
 
+        void refreshClassDistr();
+
         /**
          * re-calculate the rotation and translation variance
          */
@@ -675,6 +689,8 @@ class MLOptimiser : public Parallel
 
         void reMaskImg();
 
+        void normCorrection();
+
         /**
          * re-calculate sigma
          *
diff --git a/include/Macro.h b/include/Macro.h
index 8a94a5d..8bfbf07 100644
--- a/include/Macro.h
+++ b/include/Macro.h
@@ -35,6 +35,14 @@
  */
 #define MODE_3D 1
 
+#define IF_MODE_2D if (_mode == MODE_2D)
+
+#define IF_MODE_3D if (_mode == MODE_3D)
+
+#define NT_MODE_2D if (_mode != MODE_2D)
+
+#define NT_MODE_3D if (_mode != MODE_3D)
+
 /**
  * 1 KB
  */
diff --git a/include/Particle.h b/include/Particle.h
index cc73210..78482b8 100644
--- a/include/Particle.h
+++ b/include/Particle.h
@@ -34,7 +34,21 @@ class Particle
     private:
 
         /**
-         * numer of particles in this particle filter
+         * MODE_2D: the reference is a 2D image, and the perturbation in
+         * rotation is in 2D
+         *
+         * MODE_3D: the reference is a 3D volume, and the perturbation in
+         * rotation is in 2D
+         */
+        int _mode;
+
+        /**
+         * number of classes in this particle filter
+         */
+        int _m;
+
+        /**
+         * number of particles in this particle filter
          */
         int _n;
 
@@ -53,8 +67,17 @@ class Particle
         double _transQ;
 
         /**
-         * a table storing the rotation information with each row storing a
-         * quaternion
+         * a vector storing the class of each particle
+         */
+        uvec _c;
+
+        /**
+         * MODE_2D: a table storing the rotation information as the first and
+         * second elements stand for a unit vector in circle and the other two
+         * elements are zero
+         *
+         * MODE_3D: a table storing the rotation information with each row
+         * storing a quaternion
          */
         mat4 _r;
 
@@ -75,6 +98,11 @@ class Particle
         const Symmetry* _sym;
 
         /**
+         * concnetration paramter of von Mises distribution of rotation (kappa)
+         */
+        double _k;
+
+        /**
          * concentration parameter of Angular Central Gaussian distribution of
          * rotation
          */
@@ -102,12 +130,29 @@ class Particle
         double _rho;
 
         /**
-         * quaternion of the previous most likely rotation
+         * the previous most likely class
+         */
+        int _topCPrev;
+
+        /**
+         * the most likely class
+         * it will be refreshed by resampling
+         */
+        int _topC;
+
+        /**
+         * MODE_2D: the first element stands for the previous most likely
+         * rotation
+         *
+         * MODE_3D: quaternion of the previous most likely rotation
          */
         vec4 _topRPrev;
 
         /**
-         * quaternion of the most likely rotation
+         * MODE_2D: the first element stands for the most likely rotation
+         *
+         * MODE_3D: quaternion of the most likely rotation
+         *
          * it will be refreshed by resampling
          */
         vec4 _topR;
@@ -123,10 +168,18 @@ class Particle
          */
         vec2 _topT;
 
+        /**
+         * default initialiser
+         */
         void defaultInit()
         {
+            _mode = MODE_3D;
+
+            _m = 1;
+
             _sym = NULL;
 
+            _k = 0;
             _k0 = 0;
             _k1 = 0;
             _s0 = 0;
@@ -155,7 +208,9 @@ class Particle
          * @param transQ the re-center threshold of translation
          * @param sym    symmetry of resampling space
          */
-        Particle(const int n,
+        Particle(const int mode,
+                 const int m,
+                 const int n,
                  const double transS,
                  const double transQ = 0.01,
                  const Symmetry* sym = NULL);
@@ -172,7 +227,8 @@ class Particle
          * @param transQ the re-center threshold of translation
          * @param sym    symmetry of resampling space
          */
-        void init(const double transS,
+        void init(const int mode,
+                  const double transS,
                   const double transQ = 0.01,
                   const Symmetry* sym = NULL);
 
@@ -184,7 +240,9 @@ class Particle
          * @param transQ the re-center threshold of translation
          * @param sym    symmetry of resampling space
          */
-        void init(const int n,
+        void init(const int mode,
+                  const int n,
+                  const int k,
                   const double transS,
                   const double transQ = 0.01,
                   const Symmetry* sym = NULL);
@@ -202,22 +260,37 @@ class Particle
          *
          * @param n number of particles in this particle filter
          */
-        void reset(const int n);
+        void reset(const int m,
+                   const int n);
 
         /**
          * This function resets the particles in this particle filter to a
          * uiform distribution in rotation with nR sampling points, and 2D
          * Gaussian distribution in translation with nT sampling points. The
-         * total number of particles in this particle will be nR x nT. The
-         * sampling points for the iR-th rotation and the iT-th translation will
-         * be at (iR * nT + iT) index of the particles in this particle filter.
+         * total number of particles in this particle will be k x nR x nT. The
+         * sampling points for the iR-th rotation and the iT-th translation of
+         * the k-th clas will be at (k * nR * nT + iR * nT + iT) index of the
+         * particles in this particle filter.
          *
+         * @param m  the number of classes in this particle filter
          * @param nR the number of rotation in this particle filter
          * @param nT the number of translation in this particle filter
          */
-        void reset(const int nR,
+        void reset(const int m,
+                   const int nR,
                    const int nT);
 
+        int mode() const;
+
+        void setMode(const int mode);
+
+        /**
+         * This function returns the number of classes in this particle fitler.
+         */
+        int m() const;
+
+        void setM(const int m);
+
         /**
          * This function returns the number of particles in this particle
          * filter.
@@ -257,6 +330,10 @@ class Particle
          */
         void setTransQ(const double transQ);
 
+        uvec c() const;
+
+        void setC(const uvec& c);
+
         /**
          * This function returns the table storing the rotation information
          * with each row storing a quaternion.
@@ -339,6 +416,10 @@ class Particle
                   double& s0,
                   double& s1) const;
 
+        double compressTrans() const;
+
+        double compressPerDim() const;
+
         double compress() const;
 
         /**
@@ -384,9 +465,36 @@ class Particle
                    const int i) const;
 
         /**
-         * This function returns the rotation matrix of the i-th particle.
+         * This function returns the class of the i-th particle.
          *
-         * @param dst the rotation matrix
+         * @param dst the class
+         * @param i   the index of particle
+         */
+        void c(int& dst,
+               const int i) const;
+
+        /**
+         * This function sets the class of the i-th particle.
+         *
+         * @param src the class
+         * @param i   the index of particle
+         */
+        void setC(const int src,
+                  const int i);
+
+        /**
+         * This function returns the 2D rotation matrix of the i-th particle.
+         *
+         * @param dst the 2D rotation matrix
+         * @param i   the index of particle
+         */
+        void rot(mat22& dst,
+                 const int i) const;
+
+        /**
+         * This function returns the 3D rotation matrix of the i-th particle.
+         *
+         * @param dst the 3D rotation matrix
          * @param i   the index of particle
          */
         void rot(mat33& dst,
@@ -502,9 +610,13 @@ class Particle
          * most likely translation.
          */
         double diffTopT();
+
+        void rank1st(int& cls) const;
         
         void rank1st(vec4& quat) const;
 
+        void rank1st(mat22& rot) const;
+
         void rank1st(mat33& rot) const;
 
         void rank1st(vec2& tran) const;
@@ -512,21 +624,31 @@ class Particle
         /**
          * This function reports the 1-st rank coordinate by parameters.
          * 
+         * @param cls  the class of the most likely rotation
          * @param quat the quaternion of the most likely rotation
          * @param tran the translation of the most likely coordinate
          */
-        void rank1st(vec4& quat,
+        void rank1st(int& cls,
+                     vec4& quat,
+                     vec2& tran) const;
+
+        void rank1st(int& cls,
+                     mat22& rot,
                      vec2& tran) const;
 
         /**
          * This function reports the 1-st rank coordinates by parameters.
          * 
+         * @param cls  the class of the most likely rotation
          * @param rot  the rotation matrix of the most likely rotation
          * @param tran the translation of the most likely coordinate
          */
-        void rank1st(mat33& rot,
+        void rank1st(int& cls,
+                     mat33& rot,
                      vec2& tran) const;
 
+        void rand(int& cls) const;
+
         void rand(vec4& quat) const;
 
         void rand(mat33& rot) const;
@@ -539,7 +661,12 @@ class Particle
          * @param quat the quaternion of the rotation
          * @param tran the translation
          */
-        void rand(vec4& quat,
+        void rand(int& cls,
+                  vec4& quat,
+                  vec2& tran) const;
+
+        void rand(int& cls,
+                  mat22& rot,
                   vec2& tran) const;
 
         /**
@@ -548,7 +675,8 @@ class Particle
          * @param rot  the rotation matrix of the rotation
          * @param tran the translation
          */
-        void rand(mat33& rot,
+        void rand(int& cls,
+                  mat33& rot,
                   vec2& tran) const;
 
         /**
@@ -572,7 +700,8 @@ class Particle
 
         /**
          * This function symmetrises the particles in this particle filter
-         * according to the symmetry information.
+         * according to the symmetry information. This operation will be only
+         * performed in 3D mode.
          */
         void symmetrise();
 
@@ -593,7 +722,7 @@ class Particle
  *
  * @param particle the particle filter
  */
-void display(const Particle& particle);
+void display(const Particle& par);
 
 /**
  * This function save this particle filter to a file.
diff --git a/include/Postprocess.h b/include/Postprocess.h
index bdaa43f..388aa0d 100644
--- a/include/Postprocess.h
+++ b/include/Postprocess.h
@@ -44,14 +44,18 @@ class Postprocess
 
         Volume _mapI;
 
-        /***
         Volume _mapARFMask;
 
         Volume _mapBRFMask;
-        ***/
 
         Volume _mask;
 
+        vec _FSCUnmask;
+
+        vec _FSCMask;
+
+        vec _FSCRFMask;
+
         vec _FSC;
         
         int _res;
@@ -74,6 +78,10 @@ class Postprocess
          */
         void maskAB();
 
+        void maskABRF();
+
+        void randomPhaseAB(const int randomPhaseThres);
+
         void mergeAB();
 
         int maxR();
diff --git a/include/Projector.h b/include/Projector.h
index fd91fb0..e5cd649 100644
--- a/include/Projector.h
+++ b/include/Projector.h
@@ -14,7 +14,7 @@
 #include "Config.h"
 #include "Macro.h"
 #include "Complex.h"
-#include "Error.h"
+#include "Logging.h"
 
 #include "Euler.h"
 
@@ -31,6 +31,8 @@ class Projector
 
     private:
 
+        int _mode;
+
         /**
          * Only the signal beyond the max radius in frequnecy will be processed.
          * Max radius must be smaller than half of the shortest dimension of the
@@ -50,9 +52,14 @@ class Projector
         int _pf;
 
         /**
+         * the image to be projected
+         */
+        Image _projectee2D;
+
+        /**
          * the volume to be projected
          */
-        Volume _projectee;
+        Volume _projectee3D;
 
     public:
 
@@ -80,10 +87,20 @@ class Projector
         }
 
         /**
+         * If there is an image to be projected, return false, otherwise return
+         * true.
+         */
+        bool isEmpty2D() const;
+
+        /**
          * If there is a volume to be projected, return false, otherwise return
          * true.
          */
-        bool isEmpty() const;
+        bool isEmpty3D() const;
+
+        int mode() const;
+
+        void setMode(const int mode);
 
         /**
          * This function returns the max radius for processing signal in Fourier
@@ -126,7 +143,20 @@ class Projector
         /**
          * This function returns a constant reference to the projectee.
          */
-        const Volume& projectee() const;
+        const Image& projectee2D() const;
+
+        /**
+         * This function returns a constant reference to the projectee.
+         */
+        const Volume& projectee3D() const;
+
+        /**
+         * This function sets the projectee. Moreover, it automatically sets the
+         * max radius of processing signal.
+         *
+         * @param src the image to be projected
+         */
+        void setProjectee(Image src);
 
         /**
          * This function sets the projectee. Moreover, it automatically sets the
@@ -136,6 +166,9 @@ class Projector
          */
         void setProjectee(Volume src);
 
+        void project(Image& dst,
+                     const mat22& mat) const;
+
         /**
          * This function projects given the rotation matrix.
          * 
@@ -145,6 +178,13 @@ class Projector
         void project(Image& dst,
                      const mat33& mat) const;
 
+        void project(Image& dst,
+                     const mat22& mat,
+                     const int* iCol,
+                     const int* iRow,
+                     const int* iPxl,
+                     const int nPxl) const;
+
         /**
          * This function projects given the rotation matrix and pre-determined
          * pixel indices.
@@ -164,11 +204,20 @@ class Projector
                      const int nPxl) const;
 
         void project(Complex* dst,
+                     const mat22& mat,
+                     const int* iCol,
+                     const int* iRow,
+                     const int nPxl) const;
+
+        void project(Complex* dst,
                      const mat33& mat,
                      const int* iCol,
                      const int* iRow,
                      const int nPxl) const;
 
+        void projectMT(Image& dst,
+                       const mat22& mat) const;
+
         /**
          * This function projects given the rotation matrix using multiple
          * threads.
@@ -179,6 +228,13 @@ class Projector
         void projectMT(Image& dst,
                        const mat33& mat) const;
 
+        void projectMT(Image& dst,
+                       const mat22& mat,
+                       const int* iCol,
+                       const int* iRow,
+                       const int* iPxl,
+                       const int nPxl) const;
+
         /**
          * This function projects given the rotation matrix and pre-determined
          * pixel indices using multiple threads.
@@ -198,116 +254,20 @@ class Projector
                        const int nPxl) const;
 
         void projectMT(Complex* dst,
-                       const mat33& mat,
+                       const mat22& mat,
                        const int* iCol,
                        const int* iRow,
                        const int nPxl) const;
 
-        /**
-         * This function projects given three Euler angles.
-         *
-         * @param dst   the destination image
-         * @param phi   phi
-         * @param theta theta
-         * @param psi   psi
-         */
-        void project(Image& dst,
-                     const double phi,
-                     const double theta,
-                     const double psi) const;
-
-        /**
-         * This function projects given three Euler angles using multiple
-         * threads.
-         *
-         * @param dst   the destination image
-         * @param phi   phi
-         * @param theta theta
-         * @param psi   psi
-         */
-        void projectMT(Image& dst,
-                       const double phi,
-                       const double theta,
-                       const double psi) const;
-
-        /**
-         * This function projects given three Euler angles, and then translate
-         * given a vector.
-         *
-         * @param dst   the destination image
-         * @param phi   phi
-         * @param theta theta
-         * @param psi   psi
-         * @param x     x
-         * @param y     y
-         */
-        void project(Image& dst,
-                     const double phi,
-                     const double theta,
-                     const double psi,
-                     const double x,
-                     const double y) const;
-
-        void project(Image& dst,
-                     const double phi,
-                     const double theta,
-                     const double psi,
-                     const double x,
-                     const double y,
-                     const int* iCol,
-                     const int* iRow,
-                     const int* iPxl,
-                     const int nPxl) const;
-
-        /**
-         * This function projects given three Euler angles, and then translate
-         * given a vector using multiple threads.
-         *
-         * @param dst   the destination image
-         * @param phi   phi
-         * @param theta theta
-         * @param psi   psi
-         * @param x     x
-         * @param y     y
-         */
-        void projectMT(Image& dst,
-                       const double phi,
-                       const double theta,
-                       const double psi,
-                       const double x,
-                       const double y) const;
-
-        void projectMT(Image& dst,
-                       const double phi,
-                       const double theta,
-                       const double psi,
-                       const double x,
-                       const double y,
+        void projectMT(Complex* dst,
+                       const mat33& mat,
                        const int* iCol,
                        const int* iRow,
-                       const int* iPxl,
                        const int nPxl) const;
 
-        /**
-         * This function projects given a 5D coordinate.
-         *
-         * @param dst          the destination image
-         * @param coordinate5D the 5D coordiante, containing three Euler angles
-         *                     and a translation vector
-         */
         void project(Image& dst,
-                     const Coordinate5D& coordinate5D) const;
-
-        /**
-         * This function projects given a 5D coordinate using multiple threads.
-         *
-         * @param dst          the destination image
-         * @param coordinate5D the 5D coordiante, containing three Euler angles
-         *                     and a translation vector
-         */
-        void projectMT(Image& dst,
-                       const Coordinate5D& coordinate5D) const;
-
+                     const mat22& rot,
+                     const vec2& t) const;
         /**
          * This function projects given a rotation matrix and a translation
          * vector.
@@ -321,6 +281,14 @@ class Projector
                      const vec2& t) const;
 
         void project(Image& dst,
+                     const mat22& rot,
+                     const vec2& t,
+                     const int* iCol,
+                     const int* iRow,
+                     const int* iPxl,
+                     const int nPxl) const;
+
+        void project(Image& dst,
                      const mat33& rot,
                      const vec2& t,
                      const int* iCol,
@@ -329,6 +297,15 @@ class Projector
                      const int nPxl) const;
 
         void project(Complex* dst,
+                     const mat22& rot,
+                     const vec2& t,
+                     const int nCol,
+                     const int nRow,
+                     const int* iCol,
+                     const int* iRow,
+                     const int nPxl) const;
+
+        void project(Complex* dst,
                      const mat33& rot,
                      const vec2& t,
                      const int nCol,
@@ -337,6 +314,10 @@ class Projector
                      const int* iRow,
                      const int nPxl) const;
 
+        void projectMT(Image& dst,
+                       const mat22& rot,
+                       const vec2& t) const;
+
         /**
          * This function projects given a rotation matrix and a translation
          * vector using multiple threads.
@@ -350,6 +331,14 @@ class Projector
                        const vec2& t) const;
 
         void projectMT(Image& dst,
+                       const mat22& rot,
+                       const vec2& t,
+                       const int* iCol,
+                       const int* iRow,
+                       const int* iPxl,
+                       const int nPxl) const;
+
+        void projectMT(Image& dst,
                        const mat33& rot,
                        const vec2& t,
                        const int* iCol,
@@ -358,6 +347,15 @@ class Projector
                        const int nPxl) const;
 
         void projectMT(Complex* dst,
+                       const mat22& rot,
+                       const vec2& t,
+                       const int nCol,
+                       const int nRow,
+                       const int* iCol,
+                       const int* iRow,
+                       const int nPxl) const;
+
+        void projectMT(Complex* dst,
                        const mat33& rot,
                        const vec2& t,
                        const int nCol,
diff --git a/include/Reconstructor.h b/include/Reconstructor.h
index 3288a3a..2ef67a6 100644
--- a/include/Reconstructor.h
+++ b/include/Reconstructor.h
@@ -15,6 +15,7 @@
 #include <mpi.h>
 
 #include <boost/function.hpp>
+#include <boost/bind.hpp>
 
 #include "omp_compat.h"
 
@@ -79,8 +80,12 @@ class Reconstructor : public Parallel
 {
     private:
 
+        int _mode;
+
         int _calMode;
 
+        bool _MAP;
+
         /**
          * The real size of the 3D Fourier reconstructor space that is used to
          * determine the size (PAD_SIZE) of Volume in 3 dimensions(xyz).
@@ -89,6 +94,14 @@ class Reconstructor : public Parallel
          */
         int _size;
 
+        Image _F2D;
+
+        Image _W2D;
+
+        Image _C2D;
+
+        Image _T2D;
+
         /**
          * The 3D grid volume used to save the accumulation of the pixels 
          * values of 2D Fourier transforms of inserting images in 3D Fourier
@@ -101,7 +114,7 @@ class Reconstructor : public Parallel
          * _F volumes of all nodes, which the 3D Fourier transform of the 
          * model is obtained. This volume is initialised to be all zero.
          */
-        Volume _F;
+        Volume _F3D;
         
         /**
          * The 3D grid volume used to save the balancing weights factors of 
@@ -116,7 +129,7 @@ class Reconstructor : public Parallel
          * get the 3D Fourier transform of the model. This volume initialised
          * to be all one.
          */
-        Volume _W;
+        Volume _W3D;
         
         
         /**
@@ -130,9 +143,9 @@ class Reconstructor : public Parallel
          * by the divion of _W and _C, with which _C can be approximately equal
          * to 1. This volume initialised to be all zero.
          */
-        Volume _C;
+        Volume _C3D;
 
-        Volume _T;
+        Volume _T3D;
 
         /**
          * The vector to save the rotate matrixs of each insertion with image 
@@ -145,9 +158,13 @@ class Reconstructor : public Parallel
          * that matrix can be the same because of the multiple possibility of
          * 5D coordinates in a single image. 
          */
-        vector<mat33> _rot;
+        /***
+        vector<mat33> _rot3D;
+
+        vector<mat33> _rot2D;
 
         vector<const Image*> _ctf;
+        ***/
 
         //vector<vec> _sig;
 
@@ -217,8 +234,12 @@ class Reconstructor : public Parallel
 
         void defaultInit()
         {
+            _mode = MODE_3D;
+
             _calMode = POST_CAL_MODE;
 
+            _MAP = true;
+
             _pf = 2;
             _sym = NULL;
             _a = 1.9;
@@ -252,7 +273,8 @@ class Reconstructor : public Parallel
          * @param alpha The smoothness parameter of modified Kaiser-Bessel 
          *              Kernel. By default is 15.
          */
-        Reconstructor(const int size,
+        Reconstructor(const int mode,
+                      const int size,
                       const int pf = 2,
                       const Symmetry* sym = NULL,
                       const double a = 1.9,
@@ -274,7 +296,8 @@ class Reconstructor : public Parallel
          * @param alpha The smoothness parameter of modified Kaiser-Bessel 
          *              kernel. By default is 15.
          */
-        void init(const int size,
+        void init(const int mode,
+                  const int size,
                   const int pf = 2,
                   const Symmetry* sym = NULL,
                   const double a = 1.9,
@@ -282,6 +305,14 @@ class Reconstructor : public Parallel
 
         void reset();
 
+        int mode() const;
+
+        void setMode(const int mode);
+
+        bool MAP() const;
+
+        void setMAP(const bool MAP);
+
         /** 
          * set the symmetry mark of the model to be reconstructed. 
          *
@@ -321,6 +352,12 @@ class Reconstructor : public Parallel
                        const int* iPxl,
                        const int* iSig);
 
+        void insert(const Image& src,
+                    const Image& ctf,
+                    const mat22& rot,
+                    const vec2& t,
+                    const double w);
+
         /**
          * Insert a 2D Fourier transform of image pixel data with associated
          * 3D rotated matrix, 2D translation vector and weight into member 
@@ -341,21 +378,30 @@ class Reconstructor : public Parallel
                     const Image& ctf,
                     const mat33& rot,
                     const vec2& t,
-                    const double w,
-                    const vec* sig = NULL);
+                    const double w);
+
+        void insertP(const Image& src,
+                     const Image& ctf,
+                     const mat22& rot,
+                     const vec2& t,
+                     const double w);
 
         void insertP(const Image& src,
                      const Image& ctf,
                      const mat33& rot,
                      const vec2& t,
-                     const double w,
-                     const vec* sig = NULL);
+                     const double w);
+
+        void reconstruct(Image& dst);
 
         /**
          * reconstruct a 3D model and save it into a volume.
+         *
+         * MODE_2D: the volume will be a special one with nSlc = 1
+         * MODE_3D: the regular volume
          * 
          * @param dst The destination volume that reconstructor object saves the
-         * result of reconstruction into.
+         *            result of reconstruction into.
          */
         void reconstruct(Volume& dst);
 
@@ -365,12 +411,6 @@ class Reconstructor : public Parallel
          * The size of the reconstructor area that is used to determine the
          * size of Volume in 3 dimension xyz.
          */
-        void allReduceW();
-
-        /**
-         * The size of the reconstructor area that is used to determine the
-         * size of Volume in 3 dimension xyz.
-         */
         void allReduceF();
 
         void allReduceT();
diff --git a/src/Database.cpp b/src/Database.cpp
index e102f13..e552c48 100644
--- a/src/Database.cpp
+++ b/src/Database.cpp
@@ -6,9 +6,7 @@
  * Description:
  * ****************************************************************************/
 
-#include <Error.h>
 #include "Database.h"
-#include "Utils.h"
 
 Database::Database() : _mode(PARTICLE_MODE)
 {
diff --git a/src/Error/Error.cpp b/src/Error/Error.cpp
deleted file mode 100644
index 5bf1970..0000000
--- a/src/Error/Error.cpp
+++ /dev/null
@@ -1,40 +0,0 @@
-/*******************************************************************************
- * Author: Mingxu Hu
- * Dependency:
- * Test:
- * Execution:
- * Description:
- *
- * Manual:
- * ****************************************************************************/
-
-#include "Error.h"
-#include <sstream>
-
-Error::Error(const std::string& errMsg,
-             const std::string& file,
-             const int line)
-{
-    _errMsg = errMsg;
-    _file = file;
-    _line = line;
-}
-
-std::ostream& operator<<(std::ostream& os, const Error& error)
-{
-    os << "ERROR: " << error._errMsg << std::endl
-       << "File: " << error._file <<std::endl
-       << "Line: " << error._line <<std::endl;
-    return os;
-}
-
-const char* Error::what() const throw()
-{
-    if (_totalMsg.empty())
-    {
-        std::stringstream ss;
-        ss << *this;
-        _totalMsg = ss.str();
-    }
-    return _totalMsg.c_str();
-}
diff --git a/src/FFT.cpp b/src/FFT.cpp
index 2ecfe6c..5f31e8e 100644
--- a/src/FFT.cpp
+++ b/src/FFT.cpp
@@ -51,7 +51,6 @@ void FFT::bw(Image& img)
     CHECK_SPACE_VALID(_dstR, _srcC);
     ***/
 
-
     #pragma omp critical
     bwPlan = fftw_plan_dft_c2r_2d(img.nRowRL(),
                                   img.nColRL(),
@@ -68,22 +67,27 @@ void FFT::bw(Image& img)
 
 void FFT::fw(Volume& vol)
 {
-    /***
-    vol.alloc(FT_SPACE);
-    _dstC = (fftw_complex*)&vol[0];
-    _srcR = &vol(0);
-
-    CHECK_SPACE_VALID(_dstC, _srcR);
-    ***/
     FW_EXTRACT_P(vol);
 
-    #pragma omp critical
-    fwPlan = fftw_plan_dft_r2c_3d(vol.nRowRL(),
-                                  vol.nColRL(),
-                                  vol.nSlcRL(),
-                                  _srcR,
-                                  _dstC,
-                                  FFTW_ESTIMATE);
+    if (vol.nSlcRL() == 1)
+    {
+        #pragma omp critical
+        fwPlan = fftw_plan_dft_r2c_2d(vol.nRowRL(),
+                                      vol.nColRL(),
+                                      _srcR,
+                                      _dstC,
+                                      FFTW_ESTIMATE);
+    }
+    else
+    {
+        #pragma omp critical
+        fwPlan = fftw_plan_dft_r2c_3d(vol.nRowRL(),
+                                      vol.nColRL(),
+                                      vol.nSlcRL(),
+                                      _srcR,
+                                      _dstC,
+                                      FFTW_ESTIMATE);
+    }
 
     fftw_execute(fwPlan);
 
@@ -92,21 +96,27 @@ void FFT::fw(Volume& vol)
 
 void FFT::bw(Volume& vol)
 {
-    /***
-    vol.alloc(RL_SPACE);
-    _dstR = &vol(0);
-    _srcC = (fftw_complex*)&vol[0];
-    CHECK_SPACE_VALID(_dstR, _srcC);
-    ***/
     BW_EXTRACT_P(vol);
 
-    #pragma omp critical
-    bwPlan = fftw_plan_dft_c2r_3d(vol.nRowRL(),
-                                  vol.nColRL(),
-                                  vol.nSlcRL(),
-                                  _srcC,
-                                  _dstR,
-                                  FFTW_ESTIMATE);
+    if (vol.nSlcRL() == 1)
+    {
+        #pragma omp critical
+        fwPlan = fftw_plan_dft_r2c_2d(vol.nRowRL(),
+                                      vol.nColRL(),
+                                      _srcR,
+                                      _dstC,
+                                      FFTW_ESTIMATE);
+    }
+    else
+    {
+        #pragma omp critical
+        bwPlan = fftw_plan_dft_c2r_3d(vol.nRowRL(),
+                                      vol.nColRL(),
+                                      vol.nSlcRL(),
+                                      _srcC,
+                                      _dstR,
+                                      FFTW_ESTIMATE);
+    }
 
     fftw_execute(bwPlan);
 
@@ -170,22 +180,23 @@ void FFT::bwMT(Image& img)
 
 void FFT::fwMT(Volume& vol)
 {
-    /***
-    vol.alloc(FT_SPACE);
-    _dstC = (fftw_complex*)&vol[0];
-    _srcR = &vol(0);
-    CHECK_SPACE_VALID(_dstC, _srcR);
-    ***/
     FW_EXTRACT_P(vol);
 
     fftw_plan_with_nthreads(omp_get_max_threads());
 
-    fwPlan = fftw_plan_dft_r2c_3d(vol.nRowRL(),
-                                  vol.nColRL(),
-                                  vol.nSlcRL(),
-                                  _srcR,
-                                  _dstC,
-                                  FFTW_ESTIMATE);
+    if (vol.nSlcRL() == 1)
+        fwPlan = fftw_plan_dft_r2c_2d(vol.nRowRL(),
+                                      vol.nColRL(),
+                                      _srcR,
+                                      _dstC,
+                                      FFTW_ESTIMATE);
+    else
+        fwPlan = fftw_plan_dft_r2c_3d(vol.nRowRL(),
+                                      vol.nColRL(),
+                                      vol.nSlcRL(),
+                                      _srcR,
+                                      _dstC,
+                                      FFTW_ESTIMATE);
 
     fftw_plan_with_nthreads(1);
 
@@ -196,22 +207,23 @@ void FFT::fwMT(Volume& vol)
 
 void FFT::bwMT(Volume& vol)
 {
-    /****
-    vol.alloc(RL_SPACE);
-    _dstR = &vol(0);
-    _srcC = (fftw_complex*)&vol[0];
-    CHECK_SPACE_VALID(_dstR, _srcC);
-    ***/
     BW_EXTRACT_P(vol);
 
     fftw_plan_with_nthreads(omp_get_max_threads());
 
-    bwPlan = fftw_plan_dft_c2r_3d(vol.nRowRL(),
-                                  vol.nColRL(),
-                                  vol.nSlcRL(),
-                                  _srcC,
-                                  _dstR,
-                                  FFTW_ESTIMATE);
+    if (vol.nSlcRL() == 1)
+        bwPlan = fftw_plan_dft_c2r_2d(vol.nRowRL(),
+                                      vol.nColRL(),
+                                      _srcC,
+                                      _dstR,
+                                      FFTW_ESTIMATE);
+    else
+        bwPlan = fftw_plan_dft_c2r_3d(vol.nRowRL(),
+                                      vol.nColRL(),
+                                      vol.nSlcRL(),
+                                      _srcC,
+                                      _dstR,
+                                      FFTW_ESTIMATE);
 
     fftw_plan_with_nthreads(1);
 
@@ -224,14 +236,27 @@ void FFT::bwMT(Volume& vol)
 }
 
 void FFT::fwCreatePlan(const int nCol,
+                       const int nRow)
+{
+    //fwCreatePlan(nCol, nRow, 1);
+
+    _srcR = (double*)fftw_malloc(nCol * nRow * sizeof(double));
+    _dstC = (fftw_complex*)fftw_malloc((nCol / 2 + 1) * nRow * sizeof(Complex));
+
+    fwPlan = fftw_plan_dft_r2c_2d(nRow,
+                                  nCol,
+                                  _srcR,
+                                  _dstC,
+                                  FFTW_ESTIMATE);
+
+    fftw_free(_srcR);
+    fftw_free(_dstC);
+}
+
+void FFT::fwCreatePlan(const int nCol,
                        const int nRow,
                        const int nSlc)
 {
-    /***
-    _srcR = fftw_alloc_real(nCol * nRow * nSlc);
-    _dstC = fftw_alloc_complex((nCol / 2 + 1) * nRow * nSlc);
-    ***/
-
     _srcR = (double*)fftw_malloc(nCol * nRow * nSlc * sizeof(double));
     _dstC = (fftw_complex*)fftw_malloc((nCol / 2 + 1) * nRow * nSlc * sizeof(Complex));
 
@@ -240,21 +265,35 @@ void FFT::fwCreatePlan(const int nCol,
                                   nSlc,
                                   _srcR,
                                   _dstC,
-                                  FFTW_MEASURE);
+                                  FFTW_ESTIMATE);
 
     fftw_free(_srcR);
     fftw_free(_dstC);
 }
 
 void FFT::bwCreatePlan(const int nCol,
+                       const int nRow)
+{
+    // bwCreatePlan(nCol, nRow, 1);
+
+    _srcC = (fftw_complex*)fftw_malloc((nCol / 2 + 1) * nRow * sizeof(Complex));
+    _dstR = (double*)fftw_malloc(nCol * nRow * sizeof(double));
+
+    #pragma omp critical
+    bwPlan = fftw_plan_dft_c2r_2d(nRow,
+                                  nCol,
+                                  _srcC,
+                                  _dstR,
+                                  FFTW_ESTIMATE);
+
+    fftw_free(_srcC);
+    fftw_free(_dstR);
+}
+
+void FFT::bwCreatePlan(const int nCol,
                        const int nRow,
                        const int nSlc)
 {
-    /***
-    _srcC = fftw_alloc_complex((nCol / 2 + 1) * nRow * nSlc);
-    _dstR = fftw_alloc_real(nCol * nRow * nSlc);
-    ***/
-
     _srcC = (fftw_complex*)fftw_malloc((nCol / 2 + 1) * nRow * nSlc * sizeof(Complex));
     _dstR = (double*)fftw_malloc(nCol * nRow * nSlc * sizeof(double));
 
@@ -264,13 +303,35 @@ void FFT::bwCreatePlan(const int nCol,
                                   nSlc,
                                   _srcC,
                                   _dstR,
-                                  FFTW_MEASURE);
+                                  FFTW_ESTIMATE);
 
     fftw_free(_srcC);
     fftw_free(_dstR);
 }
 
 void FFT::fwCreatePlanMT(const int nCol,
+                         const int nRow)
+{
+    //fwCreatePlanMT(nCol, nRow, 1);
+
+    _srcR = (double*)fftw_malloc(nCol * nRow * sizeof(double));
+    _dstC = (fftw_complex*)fftw_malloc((nCol / 2 + 1) * nRow * sizeof(Complex));
+
+    fftw_plan_with_nthreads(omp_get_max_threads());
+
+    fwPlan = fftw_plan_dft_r2c_2d(nRow,
+                                  nCol,
+                                  _srcR,
+                                  _dstC,
+                                  FFTW_ESTIMATE);
+
+    fftw_plan_with_nthreads(1);
+
+    fftw_free(_srcR);
+    fftw_free(_dstC);
+}
+
+void FFT::fwCreatePlanMT(const int nCol,
                          const int nRow,
                          const int nSlc)
 {
@@ -284,7 +345,7 @@ void FFT::fwCreatePlanMT(const int nCol,
                                   nSlc,
                                   _srcR,
                                   _dstC,
-                                  FFTW_MEASURE);
+                                  FFTW_ESTIMATE);
 
     fftw_plan_with_nthreads(1);
 
@@ -293,6 +354,28 @@ void FFT::fwCreatePlanMT(const int nCol,
 }
 
 void FFT::bwCreatePlanMT(const int nCol,
+                         const int nRow)
+{
+    //bwCreatePlanMT(nCol, nRow, 1);
+
+    _srcC = (fftw_complex*)fftw_malloc((nCol / 2 + 1) * nRow * sizeof(Complex));
+    _dstR = (double*)fftw_malloc(nCol * nRow * sizeof(double));
+ 
+    fftw_plan_with_nthreads(omp_get_max_threads());
+
+    bwPlan = fftw_plan_dft_c2r_2d(nRow,
+                                  nCol,
+                                  _srcC,
+                                  _dstR,
+                                  FFTW_ESTIMATE);
+
+    fftw_plan_with_nthreads(1);
+
+    fftw_free(_srcC);
+    fftw_free(_dstR);
+}
+
+void FFT::bwCreatePlanMT(const int nCol,
                          const int nRow,
                          const int nSlc)
 {
@@ -306,7 +389,7 @@ void FFT::bwCreatePlanMT(const int nCol,
                                   nSlc,
                                   _srcC,
                                   _dstR,
-                                  FFTW_MEASURE);
+                                  FFTW_ESTIMATE);
 
     fftw_plan_with_nthreads(1);
 
@@ -314,6 +397,16 @@ void FFT::bwCreatePlanMT(const int nCol,
     fftw_free(_dstR);
 }
 
+void FFT::fwExecutePlan(Image& img)
+{
+    FW_EXTRACT_P(img);
+
+    fftw_execute_dft_r2c(fwPlan, _srcR, _dstC);
+
+    _srcR = NULL;
+    _dstC = NULL;
+}
+
 void FFT::fwExecutePlan(Volume& vol)
 {
     FW_EXTRACT_P(vol);
@@ -324,6 +417,20 @@ void FFT::fwExecutePlan(Volume& vol)
     _dstC = NULL;
 }
 
+void FFT::bwExecutePlan(Image& img)
+{
+    BW_EXTRACT_P(img);
+
+    fftw_execute_dft_c2r(bwPlan, _srcC, _dstR);
+
+    SCALE_RL(img, 1.0 / img.sizeRL());
+
+    _srcC = NULL;
+    _dstR = NULL;
+
+    img.clearFT();
+}
+
 void FFT::bwExecutePlan(Volume& vol)
 {
     BW_EXTRACT_P(vol);
@@ -338,6 +445,16 @@ void FFT::bwExecutePlan(Volume& vol)
     vol.clearFT();
 }
 
+void FFT::fwExecutePlanMT(Image& img)
+{
+    FW_EXTRACT_P(img);
+
+    fftw_execute_dft_r2c(fwPlan, _srcR, _dstC);
+
+    _srcR = NULL;
+    _dstC = NULL;
+}
+
 void FFT::fwExecutePlanMT(Volume& vol)
 {
     FW_EXTRACT_P(vol);
@@ -348,6 +465,21 @@ void FFT::fwExecutePlanMT(Volume& vol)
     _dstC = NULL;
 }
 
+void FFT::bwExecutePlanMT(Image& img)
+{
+    BW_EXTRACT_P(img);
+
+    fftw_execute_dft_c2r(bwPlan, _srcC, _dstR);
+
+    #pragma omp parallel for
+    SCALE_RL(img, 1.0 / img.sizeRL());
+
+    _srcC = NULL;
+    _dstR = NULL;
+
+    img.clearFT();
+}
+
 void FFT::bwExecutePlanMT(Volume& vol)
 {
     BW_EXTRACT_P(vol);
diff --git a/src/Functions/DirectionalStat.cpp b/src/Functions/DirectionalStat.cpp
index 0f6d96d..48af737 100644
--- a/src/Functions/DirectionalStat.cpp
+++ b/src/Functions/DirectionalStat.cpp
@@ -13,19 +13,8 @@
 double pdfACG(const vec4& x,
               const mat44& sig)
 {
-    /***
-    std::cout << sig.determinant() << std::endl;
-    std::cout << sig.inverse() << std::endl;
-    ***/
-    /***
-    std::cout << pow(sig.determinant(), -0.5) << std::endl;
-    std::cout << pow(x.transpose() * sig.inverse() * x, -2) << std::endl;
-    ***/
     return pow(sig.determinant(), -0.5)
          * pow(x.transpose() * sig.inverse() * x, -2);
-    /***
-    return 1;
-    ***/
 }
 
 double pdfACG(const vec4& x,
@@ -104,11 +93,6 @@ void inferACG(mat44& dst,
             // get the factor
             double u = src.row(i) * A.inverse() * src.row(i).transpose();
 
-            /***
-            std::cout << tensor << std::endl << std::endl;
-            std::cout << u << std::endl << std::endl;
-            ***/
-
             B += tensor / u;
 
             nf += 1.0 / u;
@@ -120,7 +104,7 @@ void inferACG(mat44& dst,
         for (int i = 1; i < 4; i++)
             for (int j = 0; j < i; j++)
                 B(i, j) = B(j, i);
-    } while ((abs((A - B).array())).sum() > 0.001);
+    } while ((abs((A - B).array())).sum() > 1e-5);
 
     dst = A;
 }
@@ -137,3 +121,124 @@ void inferACG(double& k0,
     k0 = eigenSolver.eigenvalues().maxCoeff();
     k1 = eigenSolver.eigenvalues().minCoeff();
 }
+
+double pdfVMS(const vec2& x,
+              const vec2& mu,
+              const double kappa)
+{
+    return exp(kappa * x.dot(mu)) / (2 * M_PI * gsl_sf_bessel_I0(kappa));
+}
+
+void sampleVMS(mat2& dst,
+               const vec2& mu,
+               const double kappa,
+               const double n)
+{
+    gsl_rng* engine = get_random_engine();
+
+    if (kappa < 1e-1)
+    {
+        for (int i = 0; i < n; i++)
+            gsl_ran_dir_2d(engine, &dst(i, 0), &dst(i, 1));
+    }
+    else
+    {
+        double a = 1 + sqrt(1 + 4 * gsl_pow_2(kappa));
+        double b = (a - sqrt(2 * a)) / (2 * kappa);
+        double r = (1 + gsl_pow_2(b)) / (2 * b);
+
+        for (int i = 0; i < n; i++)
+        {
+            double f;
+
+            while (true)
+            {
+                double z = cos(M_PI * gsl_rng_uniform(engine));
+
+                f = (1 + r * z) / (r + z);
+
+                double c = kappa * (r - f);
+
+                double u2 = gsl_rng_uniform(engine);
+
+                if (c * (2 - c) > u2) break;
+
+                if (log(c / u2) + 1 - c >= 0) break;
+            }
+
+            double delta0 = sqrt((1 - f) * (f + 1)) * mu(1);
+            double delta1 = sqrt((1 - f) * (f + 1)) * mu(0);
+
+            if (gsl_rng_uniform(engine) > 0.5)
+            {
+                dst(i, 0) = mu(0) * f + delta0;
+                dst(i, 1) = mu(1) * f - delta1;
+            }
+            else
+            {
+                dst(i, 0) = mu(0) * f - delta0;
+                dst(i, 1) = mu(1) * f + delta1;
+            }
+        }
+    }
+}
+
+void sampleVMS(mat4& dst,
+               const vec4& mu,
+               const double kappa,
+               const double n)
+{
+    dst = mat4::Zero(dst.rows(), 4);
+
+    mat2 dst2D = dst.leftCols<2>();
+
+    sampleVMS(dst2D, vec2(mu(0), mu(1)), kappa, n);
+
+    dst.leftCols<2>() = dst2D;
+}
+
+void inferVMS(vec2& mu,
+              double& kappa,
+              const mat2& src)
+{
+    mu = vec2::Zero();
+
+    for (int i = 0; i < src.rows(); i++)
+    {
+        mu(0) += src(i, 0);
+        mu(1) += src(i, 1);
+    }
+
+    double R = mu.norm() / src.rows();
+
+    mu /= mu.norm();
+
+    kappa = R * (2 - gsl_pow_2(R)) / (1 - gsl_pow_2(R));
+}
+
+void inferVMS(double& kappa,
+              const mat2& src)
+{
+    vec2 mu;
+
+    inferVMS(mu, kappa, src);
+}
+
+void inferVMS(vec4& mu,
+              double& kappa,
+              const mat4& src)
+{
+    vec2 mu2D;
+
+    inferVMS(mu2D, kappa, src.leftCols<2>());
+
+    mu = vec4(mu2D(0), mu2D(1), 0, 0);
+}
+
+void inferVMS(double& kappa,
+              const mat4& src)
+{
+    vec4 mu;
+
+    inferVMS(mu, kappa, src);
+}
diff --git a/src/Functions/Mask.cpp b/src/Functions/Mask.cpp
index d69291a..b8fd59b 100644
--- a/src/Functions/Mask.cpp
+++ b/src/Functions/Mask.cpp
@@ -180,6 +180,23 @@ void directSoftMask(Image& dst,
 }
 ***/
 
+void softMask(Image& mask,
+              const double r,
+              const double ew)
+{
+    IMAGE_FOR_EACH_PIXEL_RL(mask)
+    {
+        double u = NORM(i, j);
+
+        if (u > r + ew)
+            mask.setRL(0, i, j);
+        else if (u >= r)
+            mask.setRL(0.5 + 0.5 * cos((u - r) / ew * M_PI), i, j);
+        else
+            mask.setRL(1, i, j);
+    }
+}
+
 void softMask(Image& dst,
               const Image& src,
               const double r,
@@ -256,11 +273,18 @@ void softMask(Image& dst,
               const Image& alpha,
               const double bg)
 {
+    FOR_EACH_PIXEL_RL(src)
+    {
+        double w = 1 - alpha.iGetRL(i);
+        dst(i) = bg * w + src.iGetRL(i) * (1 - w);
+    }
+    /***
     IMAGE_FOR_EACH_PIXEL_RL(src)
     {
         double w = 1 - alpha.getRL(i, j); // portion of background
         dst.setRL(bg * w + src.getRL(i, j) * (1 - w), i, j);
     }
+    ***/
 }
 
 void softMask(Image& dst,
@@ -281,6 +305,12 @@ void softMask(Image& dst,
     }
 }
 
+void softMask(Volume& mask,
+              const double r,
+              const double ew)
+{
+    //TODO
+}
 void softMask(Volume& dst,
               const Volume& src,
               const double r,
@@ -329,11 +359,19 @@ void softMask(Volume& dst,
               const double bg)
 {
     #pragma omp parallel for
+    FOR_EACH_PIXEL_RL(src)
+    {
+        double w = 1 - alpha.iGetRL(i); // portion of background
+        dst(i) = bg * w + src.iGetRL(i) * (1 - w);
+    }
+    /***
+    #pragma omp parallel for
     VOLUME_FOR_EACH_PIXEL_RL(src)
     {
         double w = 1 - alpha.getRL(i, j, k); // portion of background
         dst.setRL(bg * w + src.getRL(i, j, k) * (1 - w), i, j, k);
     }
+    ***/
 }
 
 void regionBgSoftMask(Image& dst,
diff --git a/src/Functions/Random.cpp b/src/Functions/Random.cpp
index dec19a7..6d054cd 100644
--- a/src/Functions/Random.cpp
+++ b/src/Functions/Random.cpp
@@ -18,71 +18,85 @@
 #include <stdint.h>
 #include <unistd.h>
 
-namespace {
+namespace
+{
     class ThreadLocalRNG
     {
-    private:
-        pthread_key_t key;
-
-        static void deallocate(void* p)
-        {
-            if (p)
-                gsl_rng_free(static_cast<gsl_rng*>(p));
-        }
-
-    public:
-        ThreadLocalRNG()
-        {
-            int rc = pthread_key_create(&key, &ThreadLocalRNG::deallocate);
-            if (rc)
-                CLOG(FATAL, "LOGGER_SYS") << __FUNCTION__ << ": " << strerror(rc);
-        }
-        ~ThreadLocalRNG()
-        {
-            pthread_key_delete(key);
-        }
-        gsl_rng* get()
-        {
-            gsl_rng* engine = static_cast<gsl_rng*>(pthread_getspecific(key));
-            if (engine)
+        private:
+
+            pthread_key_t key;
+
+            static void deallocate(void* p)
+            {
+                if (p) gsl_rng_free(static_cast<gsl_rng*>(p));
+            }
+
+        public:
+
+            ThreadLocalRNG()
+            {
+                int rc = pthread_key_create(&key,
+                                            &ThreadLocalRNG::deallocate);
+
+                if (rc) CLOG(FATAL, "LOGGER_SYS") << __FUNCTION__ 
+                                                  << ": "
+                                                  << strerror(rc);
+            }
+
+            ~ThreadLocalRNG()
+            {
+                pthread_key_delete(key);
+            }
+
+            gsl_rng* get()
+            {
+                gsl_rng* engine = static_cast<gsl_rng*>(pthread_getspecific(key));
+
+                if (engine) return engine;
+
+                engine = gsl_rng_alloc(gsl_rng_mt19937);
+
+                if (!engine) CLOG(FATAL, "LOGGER_SYS") << "Failure to allocate Random Engine";
+
+                unsigned long seed;
+
+                (void)(seed_from_urandom(&seed) || seed_from_time(&seed));
+
+                gsl_rng_set(engine, seed);
+
+                int rc = pthread_setspecific(key, engine);
+                if (rc) CLOG(FATAL, "LOGGER_SYS") << __FUNCTION__
+                                                  << ": "
+                                                  << strerror(rc);
+
                 return engine;
-            engine = gsl_rng_alloc(gsl_rng_mt19937);
-            if (!engine)
-                CLOG(FATAL, "LOGGER_SYS") << "Failure to allocate Random Engine";
-            unsigned long seed;
-            (void)(seed_from_urandom(&seed) || seed_from_time(&seed));
-            gsl_rng_set(engine, seed);
-            int rc = pthread_setspecific(key, engine);
-            if (rc)
-                CLOG(FATAL, "LOGGER_SYS") << __FUNCTION__ << ": " << strerror(rc);
-            return engine;
-        }
-
-        static bool seed_from_time(unsigned long* out)
-        {
-            *out = 0xc96a3ea3d89ceb52UL;
-            struct timeval tm;
-            gettimeofday(&tm, NULL);
-            *out ^= (unsigned long)tm.tv_sec;
-            *out ^= (unsigned long)tm.tv_usec << 7;
-            *out ^= (unsigned long)(uintptr_t)&tm;
-            *out ^= (unsigned long)getpid() << 3;
-            return true;
-        }
-
-        static bool seed_from_urandom(unsigned long* out)
-        {
-            int fd = open("/dev/urandom", O_RDONLY);
-            if (fd < 0) return false;
-
-            if (read(fd, out, sizeof(*out)) != sizeof(*out))
+            }
+
+            static bool seed_from_time(unsigned long* out)
             {
+                *out = 0xc96a3ea3d89ceb52UL;
+                struct timeval tm;
+                gettimeofday(&tm, NULL);
+                *out ^= (unsigned long)tm.tv_sec;
+                *out ^= (unsigned long)tm.tv_usec << 7;
+                *out ^= (unsigned long)(uintptr_t)&tm;
+                *out ^= (unsigned long)getpid() << 3;
+                return true;
+            }
+
+            static bool seed_from_urandom(unsigned long* out)
+            {
+                int fd = open("/dev/urandom", O_RDONLY);
+                if (fd < 0) return false;
+
+                if (read(fd, out, sizeof(*out)) != sizeof(*out))
+                {
+                    close(fd);
+                    return false;
+                }
                 close(fd);
-                return false;
+                return true;
             }
-            close(fd);
-            return true;
-        }
     };
 }
 
diff --git a/src/Functions/Spectrum.cpp b/src/Functions/Spectrum.cpp
index 638e037..8929a7b 100644
--- a/src/Functions/Spectrum.cpp
+++ b/src/Functions/Spectrum.cpp
@@ -215,6 +215,43 @@ void FRC(vec& dst,
     }
 }
 
+void FRC(vec& dst,
+         const Volume& A,
+         const Volume& B,
+         const int k)
+{
+    vec vecS = vec::Zero(dst.size());
+    vec vecA = vec::Zero(dst.size());
+    vec vecB = vec::Zero(dst.size());
+
+    for (int j = -A.nRowRL() / 2; j < A.nRowRL() / 2; j++)
+        for (int i = 0; i <= A.nColRL() / 2; i++)
+        {
+            int u = AROUND(NORM(i, j));
+            if (u < dst.size())
+            {
+                vecS[u] += REAL(A.getFT(i, j, k) * CONJUGATE(B.getFT(i, j, k)));
+                vecA[u] += ABS2(A.getFT(i, j, k));
+                vecB[u] += ABS2(B.getFT(i, j, k));
+            }
+        }
+
+    /***
+    std::cout << "vecS = " << vecS << std::endl;
+    std::cout << "vecA = " << vecA << std::endl;
+    std::cout << "vecB = " << vecB << std::endl;
+    ***/
+
+    for (int i = 0; i < dst.size(); i++)
+    {
+        double AB = sqrt(vecA(i) * vecB(i));
+        if (AB == 0)
+            dst(i) = 0;
+        else
+            dst(i) = vecS(i) / AB;
+    }
+}
+
 void FSC(vec& dst,
          const Volume& A,
          const Volume& B)
@@ -276,17 +313,17 @@ void randomPhase(Volume& dst,
 {
     gsl_rng* engine = get_random_engine();
 
+    #pragma omp parallel for schedule(dynamic)
     VOLUME_FOR_EACH_PIXEL_FT(dst)
     {
         int u = AROUND(NORM_3(i, j, k));
 
         if (u > r)
-        {
-            double norm = ABS(src.getFT(i, j, k));
-            double phase = gsl_ran_flat(engine, 0, 2 * M_PI);
-
-            dst.setFT(gsl_complex_polar(norm, phase), i, j, k);
-        }
+            dst.setFT(src.getFT(i, j, k)
+                    * COMPLEX_POLAR(gsl_ran_flat(engine, 0, 2 * M_PI)),
+                      i,
+                      j,
+                      k);
         else
             dst.setFT(src.getFT(i, j, k), i, j, k);
     }
diff --git a/src/Geometry/Euler.cpp b/src/Geometry/Euler.cpp
index 2f7dd71..fc39b84 100644
--- a/src/Geometry/Euler.cpp
+++ b/src/Geometry/Euler.cpp
@@ -70,6 +70,19 @@ void quaternoin(vec4& dst,
     dst(3) = sin((phi + psi) / 2) * cos(theta / 2);
 }
 
+void rotate2D(mat22& dst, const vec2& vec)
+{
+    /***
+    vec(0) = cos(phi);
+    vec(1) = sin(phi);
+    ***/
+
+    dst(0, 0) = vec(0);
+    dst(0, 1) = -vec(1);
+    dst(1, 0) = vec(1);
+    dst(1, 1) = vec(0);
+}
+
 void rotate2D(mat22& dst, const double phi)
 {
     double sine = sin(phi);
@@ -277,6 +290,7 @@ void scale3D(mat33& dst,
     dst(2, 2) = vec(2);
 }
 
+/***
 void randQuaternion(vec4& quat)
 {
     gsl_rng* engine = get_random_engine();
@@ -286,12 +300,30 @@ void randQuaternion(vec4& quat)
 
     quat /= quat.norm();
 }
+***/
+
+void randRotate2D(mat22& rot)
+{
+    gsl_rng* engine = get_random_engine();
+
+    vec2 vec(gsl_ran_gaussian(engine, 1),
+             gsl_ran_gaussian(engine, 1));
+
+    vec /= vec.norm();
+    
+    rotate2D(rot, vec);
+}
 
 void randRotate3D(mat33& rot)
 {
-    vec4 quat;
+    gsl_rng* engine = get_random_engine();
+
+    vec4 vec(gsl_ran_gaussian(engine, 1),
+             gsl_ran_gaussian(engine, 1),
+             gsl_ran_gaussian(engine, 1),
+             gsl_ran_gaussian(engine, 1));
 
-    randQuaternion(quat);
+    vec /= vec.norm();
 
-    rotate3D(rot, quat);
+    rotate3D(rot, vec);
 }
diff --git a/src/Geometry/SymmetryFunctions.cpp b/src/Geometry/SymmetryFunctions.cpp
index 04be298..e7959b6 100644
--- a/src/Geometry/SymmetryFunctions.cpp
+++ b/src/Geometry/SymmetryFunctions.cpp
@@ -103,6 +103,9 @@ void symmetryGroup(int& pgGroup,
                 pgGroup = PG_I4; break;
             case '5':
                 pgGroup = PG_I5; break;
+            default:
+                REPORT_ERROR("INVALID POINT GROUP");
+                abort();
         }
         pgOrder = -1;
     }
@@ -125,11 +128,14 @@ void symmetryGroup(int& pgGroup,
                 pgGroup = PG_I4H; break;
             case '5':
                 pgGroup = PG_I5H; break;
+            default:
+                REPORT_ERROR("INVALID POINT GROUP");
+                abort();
         }
         pgOrder = -1;
     }
     else
-        CLOG(FATAL, "LOGGER_SYS") << "Invalid Symmetry Index";
+        REPORT_ERROR("INVALID SYMMTRY INDEX");
 }
 
 void fillSymmetryEntry(vector<SymmetryOperation>& entry,
@@ -301,11 +307,13 @@ void fillSymmetryEntry(vector<SymmetryOperation>& entry,
             break;
 
         case PG_I5H:
-            CLOG(FATAL, "LOGGER_SYS") << "PG_I5H Not Implemented";
+            REPORT_ERROR("PG_I5H IS NOT IMPLEMENTED");
+            abort();
             break;
 
         default:
-            CLOG(FATAL, "LOGGER_SYS") << "Symmetry Point Group is Not Known";
+            REPORT_ERROR("SYMMETRY POINT GROUP IS NOT KNOWN");
+            abort();
             break;
     }
 }
diff --git a/src/Image/Image.cpp b/src/Image/Image.cpp
index f6887ed..a0e225b 100644
--- a/src/Image/Image.cpp
+++ b/src/Image/Image.cpp
@@ -107,10 +107,10 @@ void Image::saveRLToBMP(const char* filename) const
     BMP bmp;
 
     if (bmp.open(filename, "wb") == 0)
-        CLOG(FATAL, "LOGGER_SYS") << "Fail to Open Bitcamp File.";
+        REPORT_ERROR("FAILING TO OPEN BITCAMP FILE");
 
     if (bmp.createBMP(image, nColBMP, nRowBMP) == false)
-        CLOG(FATAL, "LOGGER_SYS") << "Fail to Create BMP Image.";
+        REPORT_ERROR("FAILING TO CREATE BMP FILE");
 
     bmp.close();
 
@@ -165,9 +165,9 @@ void Image::saveFTToBMP(const char* filename, double c) const
     BMP bmp;
 
     if (bmp.open(filename, "wb") == 0)
-        CLOG(FATAL, "LOGGER_SYS") << "Fail to Open Bitcamp File.";
+        REPORT_ERROR("FAILING TO OPEN BITCAMP FILE");
     if (bmp.createBMP(image, nColBMP, nRowBMP) == false)
-        CLOG(FATAL, "LOGGER_SYS") << "Fail to Create BMP Image.";
+        REPORT_ERROR("FAILING TO CREATE BMP FILE");
 
     bmp.close();
 
@@ -232,6 +232,58 @@ void Image::setFT(const Complex value,
     _dataFT[index] = conj ? CONJUGATE(value) : value;
 }
 
+void Image::setFTHalf(const Complex value,
+                      const int iCol,
+                      const int iRow)
+{
+#ifndef IMG_VOL_BOUNDARY_NO_CHECK
+    coordinatesInBoundaryFT(iCol, iRow);
+#endif
+
+    _dataFT[iFTHalf(iCol, iRow)] = value;
+}
+
+void Image::addFT(const Complex value,
+                  int iCol,
+                  int iRow)
+{
+    bool conj;
+    int index = iFT(conj, iCol, iRow);
+
+    Complex val = conj ? CONJUGATE(value) : value;
+
+    #pragma omp atomic
+    _dataFT[index].dat[0] += val.dat[0];
+    #pragma omp atomic
+    _dataFT[index].dat[1] += val.dat[1];
+}
+
+void Image::addFTHalf(const Complex value,
+                      const int iCol,
+                      const int iRow)
+{
+    #pragma omp atomic
+    _dataFT[iFTHalf(iCol, iRow)].dat[0] += value.dat[0];
+    #pragma omp atomic
+    _dataFT[iFTHalf(iCol, iRow)].dat[1] += value.dat[1];
+}
+
+void Image::addFT(const double value,
+                  int iCol,
+                  int iRow)
+{
+    #pragma omp atomic
+    _dataFT[iFT(iCol, iRow)].dat[0] += value;
+}
+
+void Image::addFTHalf(const double value,
+                      const int iCol,
+                      const int iRow)
+{
+    #pragma omp atomic
+    _dataFT[iFTHalf(iCol, iRow)].dat[0] += value;
+}
+
 double Image::getBiLinearRL(const double iCol,
                             const double iRow) const
 {
@@ -268,12 +320,68 @@ Complex Image::getBiLinearFT(const double iCol,
     return result;
 }
 
+Complex Image::getByInterpolationFT(double iCol,
+                                    double iRow,
+                                    const int interp) const
+{
+    bool conj = conjHalf(iCol, iRow);
+
+    if (interp == NEAREST_INTERP)
+    {
+        Complex result = getFTHalf(AROUND(iCol), AROUND(iRow));
+
+        return conj ? CONJUGATE(result) : result;
+    }
+
+    double w[2][2];
+    int x0[2];
+    double x[2] = {iCol, iRow};
+
+    WG_BI_INTERP(w, x0, x, interp);
+
+    Complex result = getFTHalf(w, x0);
+
+    return conj ? CONJUGATE(result) : result;
+}
+
+void Image::addFT(const Complex value,
+                  double iCol,
+                  double iRow)
+{
+    bool conj = conjHalf(iCol, iRow);
+
+    double w[2][2];
+    int x0[2];
+    double x[2] = {iCol, iRow};
+
+    WG_BI_INTERP(w, x0, x, LINEAR_INTERP);
+
+    addFTHalf(conj ? CONJUGATE(value) : value,
+              w,
+              x0);
+}
+
+void Image::addFT(const double value,
+                  double iCol,
+                  double iRow)
+{
+    conjHalf(iCol, iRow);
+
+    double w[2][2];
+    int x0[2];
+    double x[2] = {iCol, iRow};
+
+    WG_BI_INTERP(w, x0, x, LINEAR_INTERP);
+
+    addFTHalf(value, w, x0);
+}
+
 void Image::coordinatesInBoundaryRL(const int iCol,
                                     const int iRow) const
 {
     if ((iCol < -_nCol / 2) || (iCol >= _nCol / 2) ||
         (iRow < -_nRow / 2) || (iRow >= _nRow / 2))
-        CLOG(FATAL, "LOGGER_SYS") << "Accessing Value out of Boundary";
+        REPORT_ERROR("ACCESSING VALUE OUT OF BOUNDARY");
 }
 
 void Image::coordinatesInBoundaryFT(const int iCol,
@@ -281,5 +389,35 @@ void Image::coordinatesInBoundaryFT(const int iCol,
 {
     if ((iCol < -_nCol / 2) || (iCol > _nCol / 2) ||
         (iRow < -_nRow / 2) || (iRow >= _nRow / 2))
-        CLOG(FATAL, "LOGGER_SYS") << "Accessing Value out of Boundary";
+        REPORT_ERROR("ACCESSING VALUE OUT OF BOUNDARY");
+}
+
+Complex Image::getFTHalf(const double w[2][2],
+                         const int x0[2]) const
+{
+    Complex result = COMPLEX(0, 0);
+    FOR_CELL_DIM_2 result += getFTHalf(x0[0] + i,
+                                       x0[1] + j)
+                           * w[i][j];
+    return result;
+}
+
+void Image::addFTHalf(const Complex value,
+                      const double w[2][2],
+                      const int x0[2])
+{
+    FOR_CELL_DIM_2 addFTHalf(value * w[i][j],
+                             x0[0] + i,
+                             x0[1] + j);
+                             
+}
+
+void Image::addFTHalf(const double value,
+                      const double w[2][2],
+                      const int x0[2])
+{
+    FOR_CELL_DIM_2 addFTHalf(value * w[i][j],
+                             x0[0] + i,
+                             x0[1] + j);
+                             
 }
diff --git a/src/Image/ImageFunctions.cpp b/src/Image/ImageFunctions.cpp
index 60ff618..27bc84c 100644
--- a/src/Image/ImageFunctions.cpp
+++ b/src/Image/ImageFunctions.cpp
@@ -390,6 +390,34 @@ void meanStddev(double& mean,
     stddev = gsl_stats_sd_m(&src.iGetRL(0), 1, src.sizeRL(), mean);
 }
 
+double centreStddev(const double mean,
+                    const Image& src,
+                    const double r)
+{
+    vector<double> centre;
+
+    IMAGE_FOR_EACH_PIXEL_RL(src)
+        if (QUAD(i, j) < gsl_pow_2(r))
+            centre.push_back(src.getRL(i, j));
+
+    return gsl_stats_sd_m(&centre[0], 1, centre.size(), mean);
+}
+
+void centreMeanStddev(double& mean,
+                      double& stddev,
+                      const Image& src,
+                      const double r)
+{
+    vector<double> centre;
+
+    IMAGE_FOR_EACH_PIXEL_RL(src)
+        if (QUAD(i, j) < gsl_pow_2(r))
+            centre.push_back(src.getRL(i, j));
+
+    mean = gsl_stats_mean(&centre[0], 1, centre.size());
+    stddev = gsl_stats_sd_m(&centre[0], 1, centre.size(), mean);
+}
+
 double bgStddev(const double mean,
                 const Image& src,
                 const double r)
@@ -397,7 +425,7 @@ double bgStddev(const double mean,
     vector<double> bg;
 
     IMAGE_FOR_EACH_PIXEL_RL(src)
-        if (NORM(i, j) > r)
+        if (QUAD(i, j) > gsl_pow_2(r))
             bg.push_back(src.getRL(i, j));
 
     return gsl_stats_sd_m(&bg[0], 1, bg.size(), mean);
@@ -411,7 +439,7 @@ void bgMeanStddev(double& mean,
     vector<double> bg;
 
     IMAGE_FOR_EACH_PIXEL_RL(src)
-        if (NORM(i, j) > r)
+        if (QUAD(i, j) > gsl_pow_2(r))
             bg.push_back(src.getRL(i, j));
 
     mean = gsl_stats_mean(&bg[0], 1, bg.size());
diff --git a/src/Image/Volume.cpp b/src/Image/Volume.cpp
index 50b5e44..ea809fd 100644
--- a/src/Image/Volume.cpp
+++ b/src/Image/Volume.cpp
@@ -20,29 +20,8 @@ Volume::Volume(const int nCol,
     alloc(nCol, nRow, nSlc, space);
 }
 
-/***
-Volume::Volume(BOOST_RV_REF(Volume) that) : ImageBase(BOOST_MOVE_BASE(ImageBase, that)),
-                                            _nCol(that._nCol),
-                                            _nRow(that._nRow),
-                                            _nSlc(that._nSlc)
-{
-    that._nCol = 0;
-    that._nRow = 0;
-    that._nSlc = 0;
-}
-***/
-
 Volume::~Volume() {}
 
-/***
-Volume& Volume::operator=(BOOST_RV_REF(Volume) that)
-{
-    if (this != &that) swap(that);
-
-    return *this;
-}
-***/
-
 void Volume::swap(Volume& that)
 {
     ImageBase::swap(that);
diff --git a/src/ML/MLModel.cpp b/src/ML/MLModel.cpp
index afc0278..a11e4b7 100644
--- a/src/ML/MLModel.cpp
+++ b/src/ML/MLModel.cpp
@@ -14,7 +14,9 @@ MLModel::~MLModel()
     clear();
 }
 
-void MLModel::init(const int k,
+void MLModel::init(const int mode,
+                   const bool refine,
+                   const int k,
                    const int size,
                    const int r,
                    const int pf,
@@ -23,6 +25,8 @@ void MLModel::init(const int k,
                    const double alpha,
                    const Symmetry* sym)
 {
+    _mode = mode;
+    _refine = refine;
     _k = k;
     _size = size;
     _r = r;
@@ -36,6 +40,26 @@ void MLModel::init(const int k,
     _tau = mat::Constant(1, _k, DBL_MAX);
 }
 
+int MLModel::mode() const
+{
+    return _mode;
+}
+
+void MLModel::setMode(const int mode)
+{
+    _mode = mode;
+}
+
+bool MLModel::refine() const
+{
+    return _refine;
+}
+
+void MLModel::setRefine(const bool refine)
+{
+    _refine = refine;
+}
+
 void MLModel::initProjReco()
 {
     ALOG(INFO, "LOGGER_INIT") << "Appending Projectors and Reconstructors";
@@ -177,8 +201,6 @@ int MLModel::res() const
 
 void MLModel::setRes(const int res)
 {
-    //if (_resT < _res) _resT = _res;
-
     _res = res;
 }
 
@@ -216,7 +238,7 @@ void MLModel::BcastFSC()
 {
     MLOG(INFO, "LOGGER_COMPARE") << "Setting Size of _FSC";
 
-    _FSC.resize(_rU * _pf, _k);
+    _FSC.resize(_rU, _k);
 
     MPI_Barrier(MPI_COMM_WORLD);
 
@@ -226,15 +248,43 @@ void MLModel::BcastFSC()
     {
         IF_MASTER
         {
-            MLOG(INFO, "LOGGER_COMPARE") << "Allocating A and B in Fourier Space with Size: "
-                                         << _size * _pf
-                                         << " X "
-                                         << _size * _pf
-                                         << " X "
-                                         << _size * _pf;
+            Volume A, B;
 
-            Volume A(_size * _pf, _size * _pf, _size * _pf, FT_SPACE);
-            Volume B(_size * _pf, _size * _pf, _size * _pf, FT_SPACE);
+            if (_mode == MODE_2D)
+            {
+                MLOG(INFO, "LOGGER_COMPARE") << "Allocating A and B in Fourier Space with Size: "
+                                              << _size 
+                                              << " X "
+                                              << _size;
+
+                A.alloc(_size, _size, 1, FT_SPACE);
+                B.alloc(_size, _size, 1, FT_SPACE);
+            }
+            else if (_mode == MODE_3D)
+            {
+                MLOG(INFO, "LOGGER_COMPARE") << "Allocating A and B in Fourier Space with Size: "
+                                             << _size
+                                             << " X "
+                                             << _size
+                                             << " X "
+                                             << _size;
+
+                A.alloc(_size, _size, _size, FT_SPACE);
+                B.alloc(_size, _size, _size, FT_SPACE);
+            }
+            else
+                REPORT_ERROR("INEXISTENT MODE");
+
+#ifdef VERBOSE_LEVEL_1
+            MLOG(INFO, "LOGGER_COMPARE") << "Size of Hemisphere A of Reference "
+                                         << l
+                                         << " to be Received: "
+                                         << A.sizeFT();
+            MLOG(INFO, "LOGGER_COMPARE") << "Size of Hemisphere A of Reference "
+                                         << l
+                                         << " to be Received: "
+                                         << B.sizeFT();
+#endif
 
             MLOG(INFO, "LOGGER_COMPARE") << "Receiving Reference " << l << " from Hemisphere A";
 
@@ -254,51 +304,83 @@ void MLModel::BcastFSC()
                            l,
                            MPI_COMM_WORLD);
 
-            MLOG(INFO, "LOGGER_COMPARE") << "Calculating FSC of Reference " << l;
+#ifdef VERBOSE_LEVEL_1
+                MLOG(INFO, "LOGGER_COMPARE") << "Zero, REAL = "
+                                             << REAL(A[0])
+                                             << ", IMAG = "
+                                             << IMAG(A[0]);
+                MLOG(INFO, "LOGGER_COMPARE") << "Zero, REAL = "
+                                             << REAL(B[0])
+                                             << ", IMAG = "
+                                             << IMAG(B[0]);
+#endif
 
-            /***
-            Volume aA = A.copyVolume();
-            Volume aB = B.copyVolume();
+            vec fsc(_rU);
 
-            FFT fft;
-            fft.bwMT(aA);
-            fft.bwMT(aB);
+            if (_mode == MODE_2D)
+            {
+                MLOG(INFO, "LOGGER_COMPARE") << "Calculating FRC of Reference " << l;
 
-            Volume bA;
-            Volume bB;
+                FRC(fsc, A, B, 0);
 
-            VOL_EXTRACT_RL(bA, aA, 1.0 / _pf);
-            VOL_EXTRACT_RL(bB, aB, 1.0 / _pf);
+                _FSC.col(l) = fsc;
+            }
+            else if (_mode == MODE_3D)
+            {
+                MLOG(INFO, "LOGGER_COMPARE") << "Calculating FSC of Reference " << l;
 
-            fft.fwMT(bA);
-            fft.fwMT(bB);
+                /***
+                FFT fft;
 
-            vec fsc(_rU);
-            FSC(fsc, bA, bB);
+                fft.bwMT(A);
+                fft.bwMT(B);
 
-            for (int i = 0; i < _rU * _pf; i++)
-                _FSC(i, l) = fsc(i / _pf);
-            ***/
+                Volume tmpA(_size, _size, _size, RL_SPACE);
+                Volume tmpB(_size, _size, _size, RL_SPACE);
+
+                VOL_EXTRACT_RL(tmpA, A, 1.0 / _pf);
+                VOL_EXTRACT_RL(tmpB, B, 1.0 / _pf);
+
+                fft.fwMT(tmpA);
+                fft.fwMT(tmpB);
+
+                FSC(fsc, tmpA, tmpB);
+                ***/
+
+                FSC(fsc, A, B);
+
+                /***
+                for (int i = 0; i < _rU * _pf; i++)
+                    _FSC(i, l) = fsc(i / _pf);
 
-            vec fsc(_rU * _pf);
-            FSC(fsc, A, B);
-            _FSC.col(l) = fsc;
+                fft.fwMT(A);
+                fft.fwMT(B);
+                A.clearRL();
+                B.clearRL();
+                ***/
+                _FSC.col(l) = fsc;
+            }
+            else
+                REPORT_ERROR("INEXISTENT MODE");
 
-            MLOG(INFO, "LOGGER_COMPARE") << "Averaging A and B Below a Certain Resolution";
+            MLOG(INFO, "LOGGER_COMPARE") << "Averaging A and B";
 
+            /***
             double r = GSL_MIN_DBL(resA2P(1.0 / A_B_AVERAGE_THRES,
                                           _size,
                                           _pixelSize) * _pf,
                                    (_r - 1) * _pf);
+                                   ***/
 
             //double r = (_r - 1) * _pf;
 
+            //double r = _rU * _pf;
+
             /***
             double r = GSL_MIN_DBL((resA2P(1.0 / A_B_AVERAGE_THRES,
                                            _size,
                                            _pixelSize) + 1) * _pf,
                                    //_rU * _pf);
-                                   ***/
 
             MLOG(INFO, "LOGGER_COMPARE") << "Averaging A and B Belower Resolution "
                                          << 1.0 / resP2A(r, _size * _pf, _pixelSize)
@@ -312,6 +394,23 @@ void MLModel::BcastFSC()
                     A.setFT(avg, i, j, k);
                     B.setFT(avg, i, j, k);
                 }
+            ***/
+
+            #pragma omp parallel for
+            FOR_EACH_PIXEL_FT(A)
+            {
+                Complex avg = (A[i] + B[i]) / 2;
+                A[i] = avg;
+                B[i] = avg;
+            }
+
+            /***
+            vec tau(_rU * _pf);
+            Image tmp(_size * _pf, _size * _pf, FT_SPACE);
+            SLC_EXTRACT_FT(tmp, A, 0);
+            powerSpectrum(tau, tmp, _rU * _pf);
+            _tau.col(l) = tau;
+            ***/
 
             MLOG(INFO, "LOGGER_COMPARE") << "Sending Reference "
                                          << l
@@ -324,6 +423,10 @@ void MLModel::BcastFSC()
                             l,
                             MPI_COMM_WORLD);
 
+            MLOG(INFO, "LOGGER_COMPARE") << "Reference "
+                                         << l
+                                         << " Sent to Hemisphere A";
+
             MLOG(INFO, "LOGGER_COMPARE") << "Sending Reference "
                                          << l
                                          << " to Hemisphere B";
@@ -334,6 +437,10 @@ void MLModel::BcastFSC()
                             HEMI_B_LEAD,
                             l,
                             MPI_COMM_WORLD);
+
+            MLOG(INFO, "LOGGER_COMPARE") << "Reference "
+                                         << l
+                                         << " Sent to Hemisphere B";
         }
         else
         {
@@ -343,10 +450,31 @@ void MLModel::BcastFSC()
                 ALOG(INFO, "LOGGER_COMPARE") << "Sending Reference "
                                              << l
                                              << " from Hemisphere A";
-                BLOG(INFO, "LOGGER_COMPARE") << "Snding Reference "
+
+                BLOG(INFO, "LOGGER_COMPARE") << "Sending Reference "
                                              << l
                                              << " from Hemisphere B";
 
+#ifdef VERBOSE_LEVEL_1
+                ALOG(INFO, "LOGGER_COMPARE") << "Size of Reference "
+                                             << l
+                                             << " to be Sent: "
+                                             << _ref[l].sizeFT();
+                BLOG(INFO, "LOGGER_COMPARE") << "Size of Reference "
+                                             << l
+                                             << " to be Sent: "
+                                             << _ref[l].sizeFT();
+
+                ALOG(INFO, "LOGGER_COMPARE") << "Zero, REAL = "
+                                             << REAL(_ref[l][0])
+                                             << ", IMAG = "
+                                             << IMAG(_ref[l][0]);
+                BLOG(INFO, "LOGGER_COMPARE") << "Zero, REAL = "
+                                             << REAL(_ref[l][0])
+                                             << ", IMAG = "
+                                             << IMAG(_ref[l][0]);
+#endif
+
                 MPI_Ssend_Large(&_ref[l][0],
                                 _ref[l].sizeFT(),
                                 MPI_DOUBLE_COMPLEX,
@@ -370,17 +498,17 @@ void MLModel::BcastFSC()
 
         if (isA())
         {
-            ALOG(INFO, "LOGGER_COMPARE") << "Broadcasting Reference from A_LEAD";
+            ALOG(INFO, "LOGGER_COMPARE") << "Broadcasting Reference " << l << " from A_LEAD";
             MPI_Bcast_Large(&_ref[l][0],
                             _ref[l].sizeFT(),
                             MPI_DOUBLE_COMPLEX,
                             0,
-                           _hemi);
+                            _hemi);
         }
 
         if (isB())
         {
-            BLOG(INFO, "LOGGER_COMPARE") << "Broadcasting Reference from B_LEAD";
+            BLOG(INFO, "LOGGER_COMPARE") << "Broadcasting Reference " << l << " from B_LEAD";
             MPI_Bcast_Large(&_ref[l][0],
                             _ref[l].sizeFT(),
                             MPI_DOUBLE_COMPLEX,
@@ -389,6 +517,10 @@ void MLModel::BcastFSC()
         }
 
         MPI_Barrier(MPI_COMM_WORLD);
+
+#ifdef VERBOSE_LEVEL_1
+        MLOG(INFO, "LOGGER_COMPARE") << "Reference " << l << " Broadcasted from A_LEAD and B_LEAD";
+#endif
     }
 
     MLOG(INFO, "LOGGER_COMPARE") << "Broadcasting FSC from MASTER";
@@ -400,13 +532,24 @@ void MLModel::BcastFSC()
               MPI_COMM_WORLD);
 
     MPI_Barrier(MPI_COMM_WORLD);
+
+    MLOG(INFO, "LOGGER_COMPARE") << "FSC Broadcasted from MASTER";
 }
 
 void MLModel::lowPassRef(const double thres,
                          const double ew)
 {
     FOR_EACH_CLASS
-        lowPassFilter(_ref[l], _ref[l], thres, ew);
+    {
+        if (_mode == MODE_2D)
+        {
+            //TODO
+        }
+        else if (_mode == MODE_3D)
+            lowPassFilter(_ref[l], _ref[l], thres, ew);
+        else
+            REPORT_ERROR("INEXISTENT MODE");
+    }
 }
 
 mat MLModel::fsc() const
@@ -439,6 +582,8 @@ void MLModel::refreshSNR()
 
 void MLModel::refreshTau()
 {
+    // TODO
+
     /***
     _tau.resize(_rU * _pf - 1, _k);
 
@@ -450,6 +595,7 @@ void MLModel::refreshTau()
     }
     ***/
 
+    /***
     _tau.resize(maxR() * _pf - 1, _k);
 
     FOR_EACH_CLASS
@@ -458,6 +604,7 @@ void MLModel::refreshTau()
         powerSpectrum(ps, _ref[l], maxR() * _pf - 1);
         _tau.col(l) = ps / 2;
     }
+    ***/
 }
 
 void MLModel::refreshSig(const vec& sig)
@@ -487,7 +634,7 @@ int MLModel::resolutionP(const int i,
                          const double thres,
                          const bool inverse) const
 {
-    return resP(_FSC.col(i), thres, _pf, 1, inverse);
+    return resP(_FSC.col(i), thres, 1, 1, inverse);
 }
 
 int MLModel::resolutionP(const double thres,
@@ -523,7 +670,24 @@ void MLModel::refreshProj()
 {
     FOR_EACH_CLASS
     {
-        _proj[l].setProjectee(_ref[l].copyVolume());
+        if (_mode == MODE_2D)
+        {
+            _proj[l].setMode(MODE_2D);
+
+            Image tmp(_size, _size, FT_SPACE);
+            SLC_EXTRACT_FT(tmp, _ref[l], 0);
+
+            _proj[l].setProjectee(tmp.copyImage());
+        }
+        else if (_mode == MODE_3D)
+        {
+            _proj[l].setMode(MODE_3D);
+
+            _proj[l].setProjectee(_ref[l].copyVolume());
+        }
+        else
+            REPORT_ERROR("INEXISTENT MODE");
+
         _proj[l].setMaxRadius(_r);
         _proj[l].setPf(_pf);
 
@@ -550,7 +714,8 @@ void MLModel::refreshReco()
                                  << l
                                  << " Initialising";
 
-        _reco[l]->init(_size,
+        _reco[l]->init(_mode,
+                       _size,
                        _pf,
                        _sym,
                        _a,
@@ -582,7 +747,7 @@ void MLModel::resetReco()
     {
         _reco[l]->reset();
 
-        _reco[l]->setFSC(_FSC.col(l));
+        _reco[l]->setFSC(_FSC.col(l).head(_res));
 
         _reco[l]->setMaxRadius(_rU);
     }
@@ -650,10 +815,6 @@ void MLModel::updateR(const double thres)
 void MLModel::elevateR(const double thres)
 {
     /***
-    double areaTtl = M_PI * gsl_pow_2(maxR());
-    double areaGlb = M_PI * gsl_pow_2(_rGlobal);
-    ***/
-
     FOR_EACH_CLASS
         if (_FSC.col(l)(_pf * _rU - 1) > thres)
         {
@@ -666,12 +827,12 @@ void MLModel::elevateR(const double thres)
             
             if (_searchType == SEARCH_TYPE_GLOBAL)
             {
-                _r = GSL_MIN_INT(_rU, _r + AROUND((double)_rGlobal / 4));
+                _r = GSL_MIN_INT(_rU, _r + AROUND((double)_rGlobal / 3));
                 //_r = GSL_MIN_INT(_rU, _r + AROUND(areaGlb / (2 * M_PI * _r) / 4));
             }
             else
             {
-                _r = GSL_MIN_INT(_rU, _r + AROUND((double)maxR() / 8));
+                _r = GSL_MIN_INT(_rU, _r + AROUND((double)maxR() / 6));
                 //_r = GSL_MIN_INT(_rU, _r + AROUND(areaTtl / (2 * M_PI * _r) / 16));
             }
 
@@ -681,14 +842,9 @@ void MLModel::elevateR(const double thres)
             return;
         }
 
-    /***
-    _r = GSL_MAX_INT(_r,
-                     GSL_MIN_INT(resolutionP(thres, true) + 1,
-                                 _r + AROUND((double)_size / 16)));
-                                 ***/
-
     MLOG(INFO, "LOGGER_SYS") << "Elevating Cutoff Frequency When FSC at Upper Boundary Frequency Below "
                              << thres;
+                             ***/
 
     if (_searchType == SEARCH_TYPE_GLOBAL)
     {
@@ -699,7 +855,7 @@ void MLModel::elevateR(const double thres)
                                      ***/
         _r = GSL_MAX_INT(_r,
                          GSL_MIN_INT(resolutionP(thres, false) + 1,
-                                     _r + AROUND((double)_rGlobal / 4)));
+                                     _r + AROUND((double)_rGlobal / 3)));
     }
     else
     {
@@ -710,7 +866,7 @@ void MLModel::elevateR(const double thres)
                                      ***/
         _r = GSL_MAX_INT(_r,
                          GSL_MIN_INT(resolutionP(thres, false) + 1,
-                                     _r + AROUND((double)maxR() / 8)));
+                                     _r + AROUND((double)maxR() / 6)));
     }
 
     if (_searchType == SEARCH_TYPE_GLOBAL)
@@ -879,7 +1035,12 @@ int MLModel::searchType()
         // beteween iterations still gets room for improvement.
         IF_MASTER
             if ((_r == _rGlobal) && _increaseR)
-                _searchType = SEARCH_TYPE_LOCAL;
+            {
+                if (_refine)
+                    _searchType = SEARCH_TYPE_LOCAL;
+                else
+                    _searchType = SEARCH_TYPE_STOP;
+            }
     }
 
     MPI_Barrier(MPI_COMM_WORLD);
@@ -903,79 +1064,14 @@ void MLModel::setIncreaseR(const bool increaseR)
     _increaseR = increaseR;
 }
 
-void MLModel::sharpenUp(const bool fscWeighting)
-{
-    MLOG(INFO, "LOGGER_SYS") << "Averaging Reference(s) from Two Hemispheres";
-
-    avgHemi();
-
-    MLOG(INFO, "LOGGER_SYS") << "Shapening Merged Reference(s)";
-
-    IF_MASTER
-    {
-        FOR_EACH_CLASS
-        {
-            if (fscWeighting)
-                fscWeightingFilter(_ref[l], _ref[l], _FSC.col(l));
-
-            /***
-            sharpen(_ref[l],
-                    _ref[l],
-                    (double)_resT / _size,
-                    EDGE_WIDTH_FT / _size,
-                    _rT * _pf,
-                    (AROUND(resA2P(1.0 / A_B_AVERAGE_THRES,
-                                  _size,
-                                  _pixelSize)) + 1) * _pf);
-                                  ***/
-        }
-    }
-}
-
-void MLModel::sharpenUp(const double bFactor,
-                        const bool fscWeighting)
-{
-    MLOG(INFO, "LOGGER_SYS") << "Averaging Reference(s) from Two Hemispheres";
-
-    avgHemi();
-
-    MLOG(INFO, "LOGGER_SYS") << "Shapening Merged Reference(s)";
-
-    IF_MASTER
-    {
-        FOR_EACH_CLASS
-        {
-            MLOG(INFO, "LOGGER_SYS") << "Shapening Merged Reference " << l;
-
-            MLOG(INFO, "LOGGER_SYS") << "FSC Weighting Reference " << l;
-
-            if (fscWeighting)
-                fscWeightingFilter(_ref[l], _ref[l], _FSC.col(l));
-
-            MLOG(INFO, "LOGGER_SYS") << "B-Factor and Low-Pass Filter Reference "
-                                     << l;
-
-            MLOG(INFO, "LOGGER_SYS") << "B-Factor is : "
-                                     << bFactor * gsl_pow_2(_pixelSize)
-                                     << " Angtrom^2";
-
-            sharpen(_ref[l],
-                    _ref[l],
-                    (double)_resT / _size,
-                    (double)EDGE_WIDTH_FT / _size,
-                    bFactor);
-        }
-    }
-}
-
 void MLModel::updateRU()
 {
     _rUPrev = _rU;
 
     _rU = GSL_MIN_INT(_r
                     + ((_searchType == SEARCH_TYPE_GLOBAL)
-                     ? AROUND((double)_rGlobal / 4)
-                     : AROUND((double)maxR() / 4)),
+                     ? AROUND((double)_rGlobal / 3)
+                     : AROUND((double)maxR() / 3)),
                       maxR());
 
     MLOG(INFO, "LOGGER_SYS") << "Resetting Frequency Boundary of Reconstructor to "
@@ -1043,15 +1139,29 @@ void MLModel::avgHemi()
     {
         IF_MASTER
         {
-            MLOG(INFO, "LOGGER_COMPARE") << "Allocating A and B in Fourier Space with Size: "
-                                         << _size * _pf
-                                         << " X "
-                                         << _size * _pf
-                                         << " X "
-                                         << _size * _pf;
-
-            Volume A(_size * _pf, _size * _pf, _size * _pf, FT_SPACE);
-            Volume B(_size * _pf, _size * _pf, _size * _pf, FT_SPACE);
+            Volume A, B;
+            if (_mode == MODE_2D)
+            {
+                MLOG(INFO, "LOGGER_COMPARE") << "Allocating A and B in Fourier Space with Size: "
+                                             << _size
+                                             << " X "
+                                             << _size;
+
+                A.alloc(_size, _size, 1, FT_SPACE);
+                B.alloc(_size, _size, 1, FT_SPACE);
+            }
+            else if (_mode == MODE_3D)
+            {
+                MLOG(INFO, "LOGGER_COMPARE") << "Allocating A and B in Fourier Space with Size: "
+                                             << _size
+                                             << " X "
+                                             << _size
+                                             << " X "
+                                             << _size;
+
+                Volume A(_size, _size, _size, FT_SPACE);
+                Volume B(_size, _size, _size, FT_SPACE);
+            }
 
             MLOG(INFO, "LOGGER_COMPARE") << "Receiving Reference " << l << " from Hemisphere A";
 
diff --git a/src/ML/MLOptimiser.cpp b/src/ML/MLOptimiser.cpp
index 5916704..225151f 100644
--- a/src/ML/MLOptimiser.cpp
+++ b/src/ML/MLOptimiser.cpp
@@ -66,14 +66,32 @@ void MLOptimiser::setPara(const MLOptimiserPara& para)
 
 void MLOptimiser::init()
 {
+    if (_para.mode == MODE_2D)
+    {
+        MLOG(INFO, "LOGGER_INIT") << "The Program is Running under 2D Mode";
+    }
+    else if (_para.mode == MODE_3D)
+    {
+        MLOG(INFO, "LOGGER_INIT") << "The Program is Running under 3D Mode";
+    }
+    else
+        REPORT_ERROR("INEXISTENT MODE");
+
     MLOG(INFO, "LOGGER_INIT") << "Setting MPI Environment of _model";
     _model.setMPIEnv(_commSize, _commRank, _hemi);
 
     MLOG(INFO, "LOGGER_INIT") << "Setting up Symmetry";
     _sym.init(_para.sym);
 
+    MLOG(INFO, "LOGGER_INIT") << "Number of Class(es): " << _para.k;
+
+    MLOG(INFO, "LOGGER_INIT") << "Initialising Class Distribution";
+    _cDistr.resize(_para.k);
+
     MLOG(INFO, "LOGGER_INIT") << "Passing Parameters to _model";
-    _model.init(_para.k,
+    _model.init(_para.mode,
+                _para.refine,
+                _para.k,
                 _para.size,
                 0,
                 _para.pf,
@@ -82,6 +100,7 @@ void MLOptimiser::init()
                 _para.alpha,
                 &_sym);
 
+
     /***
     MLOG(INFO, "LOGGER_INIT") << "Initialising Upper Boundary of Reconstruction";
 
@@ -93,12 +112,13 @@ void MLOptimiser::init()
                               << _para.ignoreRes
                               << " Angstrom will be Ingored during Comparison";
 
-    _rL = 2.5;
+                              ***/
+    _rL = 0;
+    //_rL = 2.5;
 
     MLOG(INFO, "LOGGER_INIT") << "Information Under "
                               << _rL
                               << " (Pixel) will be Ingored during Comparison";
-                              ***/
 
     MLOG(INFO, "LOGGER_INIT") << "Information Under "
                               << _para.sclCorRes
@@ -295,16 +315,19 @@ void MLOptimiser::init()
 struct Sp
 {
     double _w;
+    unsigned int _k;
     unsigned int _iR;
     unsigned int _iT;
 
-    Sp() : _w(-DBL_MAX), _iR(0), _iT(0) {};
+    Sp() : _w(-DBL_MAX), _k(0), _iR(0), _iT(0) {};
 
     Sp(const double w,
+       const unsigned int k,
        const unsigned int iR,
        const unsigned int iT)
     {
         _w = w;
+        _k = k;
         _iR = iR;
         _iT = iT;
     };
@@ -331,9 +354,22 @@ void MLOptimiser::expectation()
 
     int nPer = 0;
 
-    int nSampleMax = _para.mG / (1 + _sym.nSymmetryElement());
+    int nSampleMax = _para.k * _para.mG;
+    /***
+    if (_para.mode == MODE_2D)
+    {
+        nSampleMax = _para.k * _para.mG;
+    }
+    else if (_para.mode == MODE_3D)
+    {
+        nSampleMax = _para.k * _para.mG / (1 + _sym.nSymmetryElement());
+
+    }
+    else
+        REPORT_ERROR("INEXISTENT MODE");
+        ***/
 
-#ifdef DYNAMIC_NUM_SAMPLE
+#ifdef OPTIMISER_DYNAMIC_NUM_SAMPLE
     int nSampleWholeSpace = 0;
 
     int nSampleMin = _para.mL;
@@ -343,30 +379,35 @@ void MLOptimiser::expectation()
     {
         // initialse a particle filter
 
-        int nR = _para.mS / (1 + _sym.nSymmetryElement());
+        int nR;
+        if (_para.mode == MODE_2D)
+        { 
+            nR = _para.mS;
+        }
+        else if (_para.mode == MODE_3D)
+        {
+            nR = _para.mS / (1 + _sym.nSymmetryElement());
+        }
+        else
+            REPORT_ERROR("INEXISTENT MODE");
 
         int nT = GSL_MAX_INT(30,
                              AROUND(M_PI
                                   * gsl_pow_2(_para.transS
                                             * gsl_cdf_chisq_Qinv(0.5, 2))
-                                  * TRANS_SEARCH_FACTOR));
+                                  * _para.transSearchFactor));
+                                  //* TRANS_SEARCH_FACTOR));
 
-#ifdef DYNAMIC_NUM_SAMPLE
-        nSampleWholeSpace = _para.mS * nT;
+#ifdef OPTIMISER_DYNAMIC_NUM_SAMPLE
+        nSampleWholeSpace = _para.k * _para.mS * nT;
 #endif
 
-        /***
-        int nT = GSL_MAX_INT(30,
-                             AROUND(M_PI
-                                  * gsl_pow_2(_para.transS)
-                                  * TRANS_SEARCH_FACTOR));
-                                  ***/
-
         Particle par;
-        par.init(_para.transS, TRANS_Q, &_sym);
-        par.reset(nR, nT);
+        par.init(_para.mode, _para.transS, TRANS_Q, &_sym);
+        par.reset(_para.k, nR, nT);
 
-        mat33 rot;
+        mat22 rot2D;
+        mat33 rot3D;
         vec2 t;
 
         // generate "translations"
@@ -394,151 +435,116 @@ void MLOptimiser::expectation()
         FOR_EACH_2D_IMAGE
             omp_init_lock(&mtx[l]);
 
-        #pragma omp parallel for schedule(dynamic) private(rot)
-        for (unsigned int m = 0; m < (unsigned int)nR; m++)
+        for (unsigned int t = 0; t < (unsigned int)_para.k; t++)
         {
-            Image imgRot(size(), size(), FT_SPACE);
-            Image imgAll(size(), size(), FT_SPACE);
-
-            // perform projection
-
-            par.rot(rot, m * nT);
-
-            //_model.proj(0).project(imgRot, rot);
-            //_model.proj(0).projectMT(imgRot, rot);
-            _model.proj(0).project(imgRot, rot, _iCol, _iRow, _iPxl, _nPxl);
-
-            for (unsigned int n = 0; n < (unsigned int)nT; n++)
+            #pragma omp parallel for schedule(dynamic) private(rot2D, rot3D)
+            for (unsigned int m = 0; m < (unsigned int)nR; m++)
             {
-                // perform translation
+                Image imgRot(size(), size(), FT_SPACE);
+                Image imgAll(size(), size(), FT_SPACE);
 
-                /***
-                #pragma omp parallel for schedule(dynamic)
-                IMAGE_FOR_EACH_PIXEL_FT(imgAll)
-                ***/
+                // perform projection
 
-                //#pragma omp parallel for schedule(dynamic)
-                /***
-                IMAGE_FOR_PIXEL_R_FT(_r)
+                if (_para.mode == MODE_2D)
                 {
-                    if (QUAD(i, j) < gsl_pow_2(_r))
-                    {
-                        int index = imgAll.iFTHalf(i, j);
-                        imgAll[index] = imgRot[index] * trans[n][index];
-                    }
+                    par.rot(rot2D, t * nR * nT + m * nT);
+
+                    _model.proj(t).project(imgRot, rot2D, _iCol, _iRow, _iPxl, _nPxl);
                 }
-                ***/
+                else if (_para.mode == MODE_3D)
+                {
+                    par.rot(rot3D, t * nR * nT + m * nT);
 
-                mul(imgAll, imgRot, trans[n], _iPxl, _nPxl);
+                    _model.proj(t).project(imgRot, rot3D, _iCol, _iRow, _iPxl, _nPxl);
+                }
+                else
+                    REPORT_ERROR("INEXISTENT MODE");
 
-                Complex* priP = new Complex[_nPxl];
+                for (unsigned int n = 0; n < (unsigned int)nT; n++)
+                {
+                    mul(imgAll, imgRot, trans[n], _iPxl, _nPxl);
 
-                for (int i = 0; i < _nPxl; i++)
-                    priP[i] = imgAll.iGetFT(_iPxl[i]);
+                    Complex* priP = new Complex[_nPxl];
 
-                /***
-                logW.row(m * nT + n).transpose() = logDataVSPrior(_img,
-                                                                  imgAll,
-                                                                  _ctf,
-                                                                  _groupID,
-                                                                  _sig,
-                                                                  _r,
-                                                                  _rL);
-                                                                  ***/
-                /***
-                logW.row(m * nT + n).transpose() = logDataVSPrior(_img,
-                                                                  imgAll,
-                                                                  _ctf,
-                                                                  _groupID,
-                                                                  _sig,
-                                                                  _iPxl,
-                                                                  _iSig,
-                                                                  nPxl);
-                                                                  ***/
+                    for (int i = 0; i < _nPxl; i++)
+                        priP[i] = imgAll.iGetFT(_iPxl[i]);
 
-                /***
-                vec dvp = logDataVSPrior(_img,
-                                         imgAll,
-                                         _ctf,
-                                         _groupID,
-                                         _sigRcp,
-                                         _iPxl,
-                                         _iSig,
-                                         nPxl);
-                                         ***/
+                    vec dvp = logDataVSPrior(_datP,
+                                             priP,
+                                             _ctfP,
+                                             _sigRcpP,
+                                             (int)_ID.size(),
+                                             _nPxl);
 
-                vec dvp = logDataVSPrior(_datP,
-                                         priP,
-                                         _ctfP,
-                                         _sigRcpP,
-                                         (int)_ID.size(),
-                                         _nPxl);
+                    delete[] priP;
 
-                delete[] priP;
+                    FOR_EACH_2D_IMAGE
+                    {
+                        omp_set_lock(&mtx[l]);
 
-                FOR_EACH_2D_IMAGE
-                {
-                    omp_set_lock(&mtx[l]);
+                        if ((int)leaderBoard[l].size() < nSampleMax)
+                            leaderBoard[l].push(Sp(dvp(l), t, m, n));
+                        else if (leaderBoard[l].top()._w < dvp(l))
+                        {
+                            leaderBoard[l].pop();
 
-                    if ((int)leaderBoard[l].size() < nSampleMax)
-                        leaderBoard[l].push(Sp(dvp(l), m, n));
-                    else if (leaderBoard[l].top()._w < dvp(l))
-                    {
-                        leaderBoard[l].pop();
+                            leaderBoard[l].push(Sp(dvp(l), t, m, n));
+                        }
 
-                        leaderBoard[l].push(Sp(dvp(l), m, n));
+                        omp_unset_lock(&mtx[l]);
                     }
-
-                    omp_unset_lock(&mtx[l]);
                 }
-            }
 
-            #pragma omp atomic
-            _nR += 1;
+                #pragma omp atomic
+                _nR += 1;
 
-            #pragma omp critical
-            if (_nR > (int)(nR / 10))
-            {
-                _nR = 0;
+                #pragma omp critical
+                if (_nR > (int)(nR * _para.k / 10))
+                {
+                    _nR = 0;
 
-                nPer += 1;
+                    nPer += 1;
 
-                ALOG(INFO, "LOGGER_ROUND") << nPer * 10
-                                           << "\% Initial Phase of Global Search Performed";
-                BLOG(INFO, "LOGGER_ROUND") << nPer * 10
-                                           << "\% Initial Phase of Global Search Performed";
+                    ALOG(INFO, "LOGGER_ROUND") << nPer * 10
+                                               << "\% Initial Phase of Global Search Performed";
+                    BLOG(INFO, "LOGGER_ROUND") << nPer * 10
+                                               << "\% Initial Phase of Global Search Performed";
+                }
             }
         }
 
         delete[] mtx;
         
-        mat topW(_para.mG, _ID.size());
+        mat topW(nSampleMax, _ID.size());
 
-        umat iTopR(_para.mG, _ID.size());
-        umat iTopT(_para.mG, _ID.size());
+        umat iTopC(nSampleMax, _ID.size());
+        umat iTopR(nSampleMax, _ID.size());
+        umat iTopT(nSampleMax, _ID.size());
 
         #pragma omp parallel for
         for (int j = 0; j < (int)_ID.size(); j++)
-            for (int i = 0; i < nSampleMax; i++)
+        {
+            int leaderBoardSize = leaderBoard[j].size();
+
+            for (int i = 0; i < leaderBoardSize; i++)
             {
                 topW(i, j) = leaderBoard[j].top()._w;
 
+                iTopC(i, j) = leaderBoard[j].top()._k;
                 iTopR(i, j) = leaderBoard[j].top()._iR;
                 iTopT(i, j) = leaderBoard[j].top()._iT;
 
                 leaderBoard[j].pop();
             }
+        }
 
         #pragma omp parallel for
         FOR_EACH_2D_IMAGE
         {
             vec v = topW.col(l);
 
-#ifdef SCAN_SOFT_PROCESS
             PROCESS_LOGW_SOFT(v);
-#else
-            PROCESS_LOGW_HARD(v);
-#endif
+            //PROCESS_LOGW_HARD(v);
 
             topW.col(l) = v;
         }
@@ -548,48 +554,27 @@ void MLOptimiser::expectation()
         #pragma omp parallel for
         FOR_EACH_2D_IMAGE
         {
-            /***
-            for (int m = 0; m < _par[l].n(); m++)
-                _par[l].mulW(logW(m, l), m);
-            ***/
-
-            _par[l].reset(nSampleMax);
+            _par[l].reset(_para.k, nSampleMax);
 
+            int c;
             vec4 quat;
             vec2 t;
 
             for (int m = 0; m < nSampleMax; m++)
             {
-                /***
-                double w = leaderBoard[l].top()._w;
-                int iR = leaderBoard[l].top()._iR;
-                int iT = leaderBoard[l].top()._iT;
-
-                leaderBoard[l].pop();
-                ***/
-
+                par.c(c, iTopC(m, l) * nR * nT);
                 par.quaternion(quat, iTopR(m, l) * nT);
                 par.t(t, iTopT(m, l));
 
-                /***
-                par.quaternion(quat, iR * nT);
-                par.t(t, iT);;
-                ***/
-
+                _par[l].setC(c, m);
                 _par[l].setQuaternion(quat, m);
                 _par[l].setT(t, m);
 
                 _par[l].mulW(topW(m, l), m);
-                //_par[l].mulW(w, m);
             }
 
             _par[l].normW();
 
-            /***
-            // sort
-            _par[l].sort(_para.mG);
-            ***/
-
             if (_ID[l] < 20)
             {
                 char filename[FILE_NAME_LENGTH];
@@ -606,14 +591,18 @@ void MLOptimiser::expectation()
 
             // resample
             _par[l].resample();
+
+            // calculation variance
+            _par[l].calVari();
         }
 
-#ifdef DYNAMIC_NUM_SAMPLE
+#ifdef OPTIMISER_DYNAMIC_NUM_SAMPLE
 
 #ifdef VERBOSE_LEVEL_1
         ALOG(INFO, "LOGGER_ROUND") << "Determining Compression Level After Initial Phase of Global Search";
 #endif
 
+        #pragma omp parallel for
         FOR_EACH_2D_IMAGE
         {
             _par[l].calVari();
@@ -622,23 +611,37 @@ void MLOptimiser::expectation()
             {
                 ALOG(INFO, "LOGGER_ROUND") << "Compress Level after Global Search: "
                                            << _par[0].compress();
+                                           //<< _par[0].compressPerDim();
                 ALOG(INFO, "LOGGER_ROUND") << "Number of Sampling Points for the Next Phase: "
                                            << AROUND(nSampleWholeSpace
-                                                   * sqrt(_par[0].compress()));
+                                                   * sqrt(GSL_MIN_DBL(1,
+                                                                      _par[0].compress())));
+                                                                      //_par[0].compressPerDim())));
             }
 
             _par[l].downSample(GSL_MAX_INT(nSampleMin,
                                            GSL_MIN_INT(nSampleMax,
                                                        AROUND(nSampleWholeSpace
-                                                            * sqrt(_par[l].compress())))));
+                                                            * sqrt(GSL_MIN_DBL(1,
+                                                                               _par[l].compress()))))));
+                                                                               //_par[l].compressPerDim()))))));
         }
+#endif
 
         ALOG(INFO, "LOGGER_ROUND") << "Initial Phase of Global Search Performed.";
         BLOG(INFO, "LOGGER_ROUND") << "Initial Phase of Global Search Performed.";
 
+#ifdef VERBOSE_LEVEL_1
+        MPI_Barrier(_hemi);
+
+        ALOG(INFO, "LOGGER_ROUND") << "Initial Phase of Global Search in Hemisphere A Performed";
+        BLOG(INFO, "LOGGER_ROUND") << "Initial Phase of Global Search in Hemisphere B Performed";
 #endif
     }
 
+    if (_para.mode == MODE_3D)
+    {
+
     _nF = 0;
     _nI = 0;
 
@@ -648,10 +651,6 @@ void MLOptimiser::expectation()
     FOR_EACH_2D_IMAGE
     {
         Complex* priP = new Complex[_nPxl];
-        //Image image(size(), size(), FT_SPACE);
-
-        // number of sampling for the next phase searching
-        // int nSamplingNextPhase = 0;
 
         int nPhaseWithNoVariDecrease = 0;
 
@@ -661,60 +660,74 @@ void MLOptimiser::expectation()
 
         for (int phase = 0; phase < MAX_N_PHASE_PER_ITER; phase++)
         {
+            /***
+            ILOG(INFO, "LOGGER_SYS") << "ID = "
+                                     << _ID[l]
+                                     << ", Phase ="
+                                     << phase;
+                                     ***/
+
             if ((phase == 0) &&
                 (_searchType == SEARCH_TYPE_LOCAL))
             {
                 _par[l].resample(_para.mL,
                                  ALPHA_LOCAL_SEARCH);
 
-                _par[l].perturb(PERTURB_FACTOR_L);
+                _par[l].perturb(_para.perturbFactorL);
+                //_par[l].perturb(PERTURB_FACTOR_L);
             }
             else
-                _par[l].perturb(PERTURB_FACTOR_S);
+            {
+                _par[l].perturb(_para.perturbFactorS);
+                //_par[l].perturb(PERTURB_FACTOR_S);
+            }
 
             vec logW(_par[l].n());
-            mat33 rot;
+
+            int c;
+            mat22 rot2D;
+            mat33 rot3D;
             vec2 t;
 
             for (int m = 0; m < _par[l].n(); m++)
             {
-                _par[l].rot(rot, m);
+                _par[l].c(c, m);
+
+                if (_para.mode == MODE_2D)
+                {
+                    _par[l].rot(rot2D, m);
+                }
+                else if (_para.mode == MODE_3D)
+                {
+                    _par[l].rot(rot3D, m);
+                }
+                else
+                    REPORT_ERROR("INEXISTENT MODE");
+
                 _par[l].t(t, m);
-                    //_model.proj(0).project(image, rot, t);
-                    //_model.proj(0).project(image, rot, t, _iCol, _iRow, _iPxl, nPxl);
-                _model.proj(0).project(priP,
-                                       rot,
-                                       t,
-                                       _para.size,
-                                       _para.size,
-                                       _iCol,
-                                       _iRow,
-                                       _nPxl);
-
-                    /***
-                    logW(m) = logDataVSPrior(_img[l], // dat
-                                             image, // pri
-                                             _ctf[l], // ctf
-                                             _sig.row(_groupID[l] - 1).head(_r).transpose(), // sig
-                                             _r,
-                                             _rL);
-                                             ***/
-                    /***
-                    logW(m) = logDataVSPrior(_img[l], // dat
-                                             image, // pri
-                                             _ctf[l], // ctf
-                                             _sigRcp.row(_groupID[l] - 1).head(_r).transpose(), // sig
-                                             _iPxl,
-                                             _iSig,
-                                             nPxl);
-                                             ***/
-                /***
-                logW(m) = logDataVSPrior(_datP[l],
-                                         priP,
-                                         _ctfP[l],
-                                         _sigRcpP[l],
-                                         _nPxl);
-                                         ***/
+
+                if (_para.mode == MODE_2D)
+                {
+                    _model.proj(c).project(priP,
+                                           rot2D,
+                                           t,
+                                           _para.size,
+                                           _para.size,
+                                           _iCol,
+                                           _iRow,
+                                           _nPxl);
+                }
+                else if (_para.mode == MODE_3D)
+                {
+                    _model.proj(c).project(priP,
+                                           rot3D,
+                                           t,
+                                           _para.size,
+                                           _para.size,
+                                           _iCol,
+                                           _iRow,
+                                           _nPxl);
+                }
 
                 logW(m) = logDataVSPrior(_datP + l * _nPxl,
                                          priP,
@@ -723,11 +736,7 @@ void MLOptimiser::expectation()
                                          _nPxl);
             }
 
-#ifdef DEEP_SOFT_PROCESS
             PROCESS_LOGW_SOFT(logW);
-#else
-            PROCESS_LOGW_HARD(logW);
-#endif
 
             for (int m = 0; m < _par[l].n(); m++)
                 _par[l].mulW(logW(m), m);
@@ -749,33 +758,40 @@ void MLOptimiser::expectation()
 
             // Only after resampling, the current variance can be calculated
             // correctly.
-
-            _par[l].calVari();
+            
+            _par[l].resample();
 
             if (_searchType == SEARCH_TYPE_GLOBAL)
             {
-#ifdef DYNAMIC_NUM_SAMPLE
+#ifdef OPTIMISER_DYNAMIC_NUM_SAMPLE
+
+                _par[l].calVari();
+
                 if (l == 0)
                 {
                     ALOG(INFO, "LOGGER_ROUND") << "Compress Level after Phase "
                                                << phase
                                                << ": "
                                                << _par[0].compress();
+                                               //<< _par[0].compressPerDim();
                     ALOG(INFO, "LOGGER_ROUND") << "Number of Sampling Points for the Next Phase: "
                                                << AROUND(nSampleWholeSpace
-                                                       * sqrt(_par[0].compress()));
+                                                       * sqrt(GSL_MIN_DBL(1,
+                                                                          _par[0].compress())));
+                                                                          //_par[0].compressPerDim())));
                 }
+
                 _par[l].downSample(GSL_MAX_INT(nSampleMin,
                                                GSL_MIN_INT(nSampleMax,
                                                            AROUND(nSampleWholeSpace
-                                                                * sqrt(_par[l].compress())))));
-#else
-                _par[l].resample();
+                                                                * sqrt(GSL_MIN_DBL(1,
+                                                                                   _par[l].compress()))))));
+                                                                                   //_par[l].compressPerDim()))))));
 #endif
             }
-            else
-                _par[l].resample();
 
+            _par[l].calVari();
+            
             if (phase >= MIN_N_PHASE_PER_ITER)
             {
                 double tVariS0Cur;
@@ -784,16 +800,6 @@ void MLOptimiser::expectation()
 
                 _par[l].vari(rVariCur, tVariS0Cur, tVariS1Cur);
 
-                /***
-                CLOG(INFO, "LOGGER_SYS") << "phase = " << phase;
-                CLOG(INFO, "LOGGER_SYS") << "tVariS0 = " << tVariS0;
-                CLOG(INFO, "LOGGER_SYS") << "tVariS1 = " << tVariS1;
-                CLOG(INFO, "LOGGER_SYS") << "rVari = " << rVari;
-                CLOG(INFO, "LOGGER_SYS") << "tVariS0Cur = " << tVariS0Cur;
-                CLOG(INFO, "LOGGER_SYS") << "tVariS1Cur = " << tVariS1Cur;
-                CLOG(INFO, "LOGGER_SYS") << "rVariCur = " << rVariCur;
-                ***/
-
                 if ((tVariS0Cur < tVariS0 * 0.9) ||
                     (tVariS1Cur < tVariS1 * 0.9) ||
                     (rVariCur < rVari * 0.9))
@@ -802,10 +808,7 @@ void MLOptimiser::expectation()
                     nPhaseWithNoVariDecrease = 0;
                 }
                 else
-                {
-                    // there is no improvement in this search
                     nPhaseWithNoVariDecrease += 1;
-                }
 
                 // make tVariS0, tVariS1, rVari the smallest variance ever got
                 if (tVariS0Cur < tVariS0) tVariS0 = tVariS0Cur;
@@ -850,6 +853,14 @@ void MLOptimiser::expectation()
 
         delete[] priP;
     }
+    }
+
+    ALOG(INFO, "LOGGER_ROUND") << "Performing Final Perturbation";
+    BLOG(INFO, "LOGGER_ROUND") << "Performing Final Perturbation";
+
+    #pragma omp parallel for
+    FOR_EACH_2D_IMAGE
+        _par[l].perturb(_para.perturbFactorS);
 
     ALOG(INFO, "LOGGER_ROUND") << "Freeing Space for Pre-calcuation in Expectation";
     BLOG(INFO, "LOGGER_ROUND") << "Freeing Space for Pre-calcuation in Expectation";
@@ -861,6 +872,10 @@ void MLOptimiser::expectation()
 
 void MLOptimiser::maximization()
 {
+    MLOG(INFO, "LOGGER_ROUND") << "Normalisation Noise";
+
+    normCorrection();
+
     ALOG(INFO, "LOGGER_ROUND") << "Generate Sigma for the Next Iteration";
     BLOG(INFO, "LOGGER_ROUND") << "Generate Sigma for the Next Iteration";
 
@@ -890,12 +905,14 @@ void MLOptimiser::run()
 
     init();
 
+    /***
     MLOG(INFO, "LOGGER_ROUND") << "Saving Some Data";
     
     saveImages();
     saveBinImages();
     saveCTFs();
     saveLowPassImages();
+    ***/
 
     MPI_Barrier(MPI_COMM_WORLD);
 
@@ -904,31 +921,6 @@ void MLOptimiser::run()
     {
         MLOG(INFO, "LOGGER_ROUND") << "Round " << _iter;
 
-        /***
-        switch (_searchType)
-        {
-            case SEARCH_TYPE_GLOBAL:
-                MLOG(INFO, "LOGGER_ROUND") << "Search Type : Global Search";
-                break;
-
-            case SEARCH_TYPE_LOCAL:
-                MLOG(INFO, "LOGGER_ROUND") << "Search Type : Local Search";
-                break;
-
-            case SEARCH_TYPE_HARSH:
-                MLOG(INFO, "LOGGER_ROUND") << "Search Type : Harsh Search";
-                break;
-
-            case SEARCH_TYPE_STOP:
-                MLOG(INFO, "LOGGER_ROUND") << "Search Type : Stop Search";
-                break;
-
-            default:
-                CLOG(FATAL, "LOGGER_ROUND") << "Invalid Search Type";
-                break;
-        }
-        ***/
-
         if (_searchType == SEARCH_TYPE_GLOBAL)
         {
             MLOG(INFO, "LOGGER_ROUND") << "Search Type : Global Search";
@@ -947,16 +939,6 @@ void MLOptimiser::run()
 
         MPI_Barrier(MPI_COMM_WORLD);
 
-        MLOG(INFO, "LOGGER_ROUND") << "Determining Lower Boundary of Frequency for Expectation";
-        _rL = 2.5;
-        /***
-        if (_searchType == SEARCH_TYPE_GLOBAL)
-            _rL = 2.5;
-        else if (_searchType == SEARCH_TYPE_LOCAL)
-            _rL = _r / 2;
-            ***/
-            //_rL = _model.rGlobal() / 2;
-
         MLOG(INFO, "LOGGER_ROUND") << "Performing Expectation";
 
         expectation();
@@ -972,9 +954,30 @@ void MLOptimiser::run()
 
         MLOG(INFO, "LOGGER_ROUND") << "All Processes Finishing Expectation";
 
+        MLOG(INFO, "LOGGER_ROUND") << "Determining Percentage of Images Belonging to Each Class";
+
+        refreshClassDistr();
+
+        for (int t = 0; t < _para.k; t++)
+            MLOG(INFO, "LOGGER_ROUND") << _cDistr(t) * 100
+                                       << "\% Percentage of Images Belonging to Class "
+                                       << t;
+
+#ifdef VERBOSE_LEVEL_1
+        MPI_Barrier(MPI_COMM_WORLD);
+
+        MLOG(INFO, "LOGGER_ROUND") << "Percentage of Images Belonging to Each Class Determined";
+#endif
+
         MLOG(INFO, "LOGGER_ROUND") << "Saving Best Projections";
         saveBestProjections();
 
+#ifdef VERBOSE_LEVEL_1
+        MPI_Barrier(MPI_COMM_WORLD);
+
+        MLOG(INFO, "LOGGER_ROUND") << "Best Projections Saved";
+#endif
+
         MLOG(INFO, "LOGGER_ROUND") << "Calculating Variance of Rotation and Translation";
 
         refreshVariance();
@@ -992,6 +995,12 @@ void MLOptimiser::run()
                                    << ", "
                                    << _model.stdTVariS1();
 
+#ifdef VERBOSE_LEVEL_1
+        MPI_Barrier(MPI_COMM_WORLD);
+
+        MLOG(INFO, "LOGGER_ROUND") << "Variance of Rotation and Translation Calculated";
+#endif
+
         MLOG(INFO, "LOGGER_ROUND") << "Calculating Changes of Rotation between Iterations";
         refreshRotationChange();
 
@@ -1005,30 +1014,6 @@ void MLOptimiser::run()
         MLOG(INFO, "LOGGER_ROUND") << "Standard Deviation of Rotation Change : "
                                    << _model.stdRChange();
 
-        /***
-        NT_MASTER
-        {
-            _model.allReduceRChange(_par, _N);
-
-            ALOG(INFO, "LOGGER_ROUND") << "Average Rotation Change : " << _model.rChange();
-            BLOG(INFO, "LOGGER_ROUND") << "Average Rotation Change : " << _model.rChange();
-
-            ALOG(INFO, "LOGGER_ROUND") << "Standard Deviation of Rotation Change : "
-                                       << _model.stdRChange();
-            BLOG(INFO, "LOGGER_ROUND") << "Standard Deviation of Rotation Change : "
-                                       << _model.stdRChange();
-        }
-        ***/
-
-        MLOG(INFO, "LOGGER_ROUND") << "Calculating Tau";
-        NT_MASTER
-        {
-            ///_model.refreshSig(_sig.row(_groupID[0] - 1).head(_r));
-
-            //_model.refreshRecoSigTau(_r, _r);
-            //_model.reco(0).setSig(_sig.row(0).head(_r));
-        }
-
         MLOG(INFO, "LOGGER_ROUND") << "Performing Maximization";
         maximization();
 
@@ -1045,23 +1030,10 @@ void MLOptimiser::run()
         MLOG(INFO, "LOGGER_ROUND") << "Re-Masking Images";
         reMaskImg();
 
-        /***
-        MLOG(INFO, "LOGGER_ROUND") << "Refreshing Tau";
-        NT_MASTER
-        {
-            _model.refreshTau();
-
-            _model.refreshSig(_sig.row(_groupID[0] - 1));
+        //MLOG(INFO, "LOGGER_ROUND") << "Saving Sigma and Tau";
 
-            //_model.refreshRecoSigTau(_model.rPrev(), _model.rUPrev());
-            //_model.refreshRecoSigTau(_r, _model.rU());
-        }
-
-        MLOG(INFO, "LOGGER_ROUND") << "Saving Sigma and Tau";
-
-        saveSig();
-        saveTau();
-        ***/
+        //saveSig();
+        //saveTau();
 
         MPI_Barrier(MPI_COMM_WORLD);
         MLOG(INFO, "LOGGER_ROUND") << "Maximization Performed";
@@ -1069,13 +1041,6 @@ void MLOptimiser::run()
         MLOG(INFO, "LOGGER_ROUND") << "Saving Reference(s)";
         saveReference();
 
-        /***
-        ALOG(INFO, "LOGGER_ROUND") << "Reference(s) Saved";
-        BLOG(INFO, "LOGGER_ROUND") << "Reference(s) Saved";
-        MPI_Barrier(MPI_COMM_WORLD);
-        MLOG(INFO, "LOGGER_ROUND") << "Reference(s) Saved";
-        ***/
-
         MLOG(INFO, "LOGGER_ROUND") << "Calculating FSC(s)";
         _model.BcastFSC();
 
@@ -1184,18 +1149,6 @@ void MLOptimiser::run()
             BLOG(INFO, "LOGGER_ROUND") << "Resetting Reconstructors";
 
             _model.resetReco();
-
-            /***
-            ALOG(INFO, "LOGGER_ROUND") << "Refreshing Reconstructors";
-            BLOG(INFO, "LOGGER_ROUND") << "Refreshing Reconstructors";
-
-            _model.refreshReco();
-            ***/
-
-            /***
-            //_model.refreshRecoSigTau(maxR(), _model.rUPrev());
-            _model.refreshRecoSigTau(maxR(), _resReport);
-            ***/
         }
     }
 
@@ -1207,10 +1160,9 @@ void MLOptimiser::run()
     MLOG(INFO, "LOGGER_ROUND") << "Refreshing Reconstructors";
     NT_MASTER
     {
-        //_model.refreshReco();
         _model.resetReco();
 
-        //_model.refreshRecoSigTau(maxR(), _resReport);
+        _model.reco(0).setMAP(false);
     }
 
     MLOG(INFO, "LOGGER_ROUND") << "Reconstructing References(s) at Nyquist";
@@ -1224,19 +1176,6 @@ void MLOptimiser::run()
 
     MLOG(INFO, "LOGGER_ROUND") << "Saving Final FSC(s)";
     saveFSC(true);
-
-    if (_para.performSharpen)
-    {
-        MLOG(INFO, "LOGGER_ROUND") << "Sharpening Reference(s)";
-
-        if (_para.estBFactor)
-            _model.sharpenUp(true);
-        else
-            _model.sharpenUp(-_para.bFactor / gsl_pow_2(_para.pixelSize), true);
-
-        MLOG(INFO, "LOGGER_ROUND") << "Saving Sharp Reference(s)";
-        saveSharpReference();
-    }
 }
 
 void MLOptimiser::clear()
@@ -1315,42 +1254,135 @@ void MLOptimiser::bcastGroupInfo()
 
 void MLOptimiser::initRef()
 {
-    _model.appendRef(Volume());
+    FFT fft;
 
-    MLOG(INFO, "LOGGER_INIT") << "Read Initial Model from Hard-disk";
+    if (strcmp(_para.initModel, "") != 0)
+    {
+        MLOG(INFO, "LOGGER_INIT") << "Read Initial Model from Hard-disk";
 
-    Volume ref;
+        Volume ref;
 
-    ImageFile imf(_para.initModel, "rb");
-    imf.readMetaData();
-    imf.readVolume(ref);
+        ImageFile imf(_para.initModel, "rb");
+        imf.readMetaData();
+        imf.readVolume(ref);
 
-    if ((ref.nColRL() != _para.size) ||
-        (ref.nRowRL() != _para.size) ||
-        (ref.nSlcRL() != _para.size))
-    {
-        CLOG(FATAL, "LOGGER_SYS") << "Incorrect Size of Appending Reference"
-                                  << ": size = " << _para.size
-                                  << ", nCol = " << ref.nColRL()
-                                  << ", nRow = " << ref.nRowRL()
-                                  << ", nSlc = " << ref.nSlcRL();
+        if (_para.mode == MODE_2D)
+        {
+            if ((ref.nColRL() != _para.size) ||
+                (ref.nRowRL() != _para.size) ||
+                (ref.nSlcRL() != 1))
+            {
+                CLOG(FATAL, "LOGGER_SYS") << "Incorrect Size of Appending Reference"
+                                          << ": size = " << _para.size
+                                          << ", nCol = " << ref.nColRL()
+                                          << ", nRow = " << ref.nRowRL()
+                                          << ", nSlc = " << ref.nSlcRL();
 
-        abort();
-    }
+                abort();
+            }
+        }
+        else if (_para.mode == MODE_3D)
+        {
+            if ((ref.nColRL() != _para.size) ||
+                (ref.nRowRL() != _para.size) ||
+                (ref.nSlcRL() != _para.size))
+            {
+                CLOG(FATAL, "LOGGER_SYS") << "Incorrect Size of Appending Reference"
+                                          << ": size = " << _para.size
+                                          << ", nCol = " << ref.nColRL()
+                                          << ", nRow = " << ref.nRowRL()
+                                          << ", nSlc = " << ref.nSlcRL();
+ 
+                abort();
+            }
+        }
+        else
+            REPORT_ERROR("INEXISTENT MODE");
     
-    MLOG(INFO, "LOGGER_INIT") << "Padding Initial Model";
+        MLOG(INFO, "LOGGER_INIT") << "Padding Initial Model";
 
-    #pragma omp parallel for
-    FOR_EACH_PIXEL_RL(ref)
-        if (ref(i) < 0) ref(i) = 0;
+        #pragma omp parallel for
+        FOR_EACH_PIXEL_RL(ref)
+            if (ref(i) < 0) ref(i) = 0;
+
+        for (int t = 0; t < _para.k; t++)
+        {
+            if (_para.mode == MODE_2D)
+            {
+                //TODO
+            }
+            else if (_para.mode == MODE_3D)
+            {
+                _model.appendRef(ref.copyVolume());
+                /***
+                _model.appendRef(Volume());
+                VOL_PAD_RL(_model.ref(t), ref, _para.pf);
+                ***/
+            }
+            else
+                REPORT_ERROR("INEXISTENT MODE");
+
+            fft.fwMT(_model.ref(t));
+            _model.ref(t).clearRL();
+        }
+    }
+    else
+    {
+        MLOG(INFO, "LOGGER_INIT") << "Initial Model is not Provided";
 
-    VOL_PAD_RL(_model.ref(0), ref, _para.pf);
+        if (_para.mode == MODE_2D)
+        {
+            Image ref(_para.size,
+                      _para.size,
+                      RL_SPACE);
 
-    MLOG(INFO, "LOGGER_INIT") << "Performing Fourier Transform";
+            IMAGE_FOR_EACH_PIXEL_RL(ref)
+            {
+                if (NORM(i, j) < _para.maskRadius / _para.pixelSize)
+                    ref.setRL(1, i, j);
+                else
+                    ref.setRL(0, i, j);
+            }
 
-    FFT fft;
-    fft.fwMT(_model.ref(0));
-    _model.ref(0).clearRL();
+            fft.fwMT(ref);
+            ref.clearRL();
+
+            Volume volRef(_para.size,
+                          _para.size,
+                          1,
+                          FT_SPACE);
+
+            COPY_FT(volRef, ref);
+
+            for (int t = 0; t < _para.k; t++)
+            {
+                _model.appendRef(volRef.copyVolume());
+            }
+        }
+        else if (_para.mode == MODE_3D)
+        {
+            Volume ref(_para.size,
+                       _para.size,
+                       _para.size,
+                       RL_SPACE);
+
+            VOLUME_FOR_EACH_PIXEL_RL(ref)
+            {
+                if (NORM_3(i, j, k) < _para.maskRadius / _para.pixelSize)
+                    ref.setRL(1, i, j, k);
+                else
+                    ref.setRL(0, i, j, k);
+            }
+
+            fft.fwMT(ref);
+            ref.clearRL();
+
+            for (int t = 0; t < _para.k; t++)
+                _model.appendRef(ref.copyVolume());
+        }
+        else
+            REPORT_ERROR("INEXISTENT MODE");
+    }
 }
 
 void MLOptimiser::initMask()
@@ -1358,10 +1390,13 @@ void MLOptimiser::initMask()
     ImageFile imf(_para.mask, "rb");
     imf.readMetaData();
 
+    imf.readVolume(_mask);
+    /***
     Volume mask;
     imf.readVolume(mask);
 
     VOL_PAD_RL(_mask, mask, _para.pf);
+    ***/
 }
 
 void MLOptimiser::initID()
@@ -1549,9 +1584,8 @@ void MLOptimiser::statImg()
     {
         #pragma omp atomic
         _stdN += bgStddev(0,
-                         _img[l],
-                         //size() * MASK_RATIO / 2);
-                         _para.maskRadius / _para.pixelSize);
+                          _img[l],
+                          _para.maskRadius / _para.pixelSize - EDGE_WIDTH_RL);
 
         #pragma omp atomic
         _stdD += stddev(0, _img[l]);
@@ -1559,8 +1593,7 @@ void MLOptimiser::statImg()
         #pragma omp atomic
         _stdStdN += gsl_pow_2(bgStddev(0,
                                        _img[l],
-                                       //size() * MASK_RATIO / 2));
-                                       _para.maskRadius / _para.pixelSize));
+                                       _para.maskRadius / _para.pixelSize - EDGE_WIDTH_RL));
     }
 
     MPI_Barrier(_hemi);
@@ -1605,13 +1638,27 @@ void MLOptimiser::substractBgImg()
     #pragma omp parallel for
     FOR_EACH_2D_IMAGE
     {
+        double bgMean, bgStddev;
+
+        bgMeanStddev(bgMean,
+                     bgStddev,
+                     _img[l],
+                     _para.maskRadius / _para.pixelSize - EDGE_WIDTH_RL);
+
+        FOR_EACH_PIXEL_RL(_img[l])
+        {
+            _img[l](i) -= bgMean;
+            _img[l](i) /= bgStddev;
+        }
+
+        /***
         double bg = background(_img[l],
                                _para.maskRadius / _para.pixelSize,
-                               //size() * MASK_RATIO / 2,
                                EDGE_WIDTH_RL);
 
         FOR_EACH_PIXEL_RL(_img[l])
             _img[l](i) -= bg;
+        ***/
     }
 }
 
@@ -1922,7 +1969,8 @@ void MLOptimiser::initParticles()
 
     #pragma omp parallel for
     FOR_EACH_2D_IMAGE
-        _par[l].init(_para.transS,
+        _par[l].init(_para.mode,
+                     _para.transS,
                      TRANS_Q,
                      &_sym);
 }
@@ -1955,6 +2003,36 @@ void MLOptimiser::refreshRotationChange()
     _model.setStdRChange(std);
 }
 
+void MLOptimiser::refreshClassDistr()
+{
+    _cDistr = vec::Zero(_para.k);
+
+    NT_MASTER
+    {
+        int cls;
+
+        #pragma omp parallel for private(cls)
+        FOR_EACH_2D_IMAGE
+        {
+            _par[l].rank1st(cls);
+
+            #pragma omp atomic
+            _cDistr[cls] += 1;
+        }
+    }
+
+    MPI_Barrier(MPI_COMM_WORLD);
+
+    MPI_Allreduce(MPI_IN_PLACE,
+                  _cDistr.data(),
+                  _cDistr.size(),
+                  MPI_DOUBLE,
+                  MPI_SUM,
+                  MPI_COMM_WORLD);
+
+    _cDistr.array() /= _nPar;
+}
+
 void MLOptimiser::refreshVariance()
 {
     vec rv = vec::Zero(_nPar);
@@ -2080,7 +2158,7 @@ void MLOptimiser::refreshScale(const bool init,
                                const bool group)
 {
     if (init)
-        _rS = 3;
+        _rS = 1;
     else if (_iter == 0)
         CLOG(FATAL, "LOGGER_SYS") << "Intensity Scale Can Not be Correct in First Iteration";
     else
@@ -2105,7 +2183,9 @@ void MLOptimiser::refreshScale(const bool init,
     {
         Image img(size(), size(), FT_SPACE);
 
-        mat33 rot;
+        int cls;
+        mat22 rot2D;
+        mat33 rot3D;
         vec2 tran;
 
         FOR_EACH_2D_IMAGE
@@ -2117,30 +2197,77 @@ void MLOptimiser::refreshScale(const bool init,
 
             if (init)
             {
-                randRotate3D(rot);
-
+                if (_para.mode == MODE_2D)
+                {
+                    randRotate2D(rot2D);
 #ifdef VERBOSE_LEVEL_3
-                ALOG(INFO, "LOGGER_SYS") << "The Random Rotation Matrix is " << rot;
-                BLOG(INFO, "LOGGER_SYS") << "The Random Rotation Matrix is " << rot;
+                ALOG(INFO, "LOGGER_SYS") << "The Random Rotation Matrix is " << rot2D;
+                BLOG(INFO, "LOGGER_SYS") << "The Random Rotation Matrix is " << rot2D;
 #endif
+                }
+                else if (_para.mode == MODE_3D)
+                {
+                    randRotate3D(rot3D);
+#ifdef VERBOSE_LEVEL_3
+                ALOG(INFO, "LOGGER_SYS") << "The Random Rotation Matrix is " << rot3D;
+                BLOG(INFO, "LOGGER_SYS") << "The Random Rotation Matrix is " << rot3D;
+#endif
+                }
+                else
+                    REPORT_ERROR("INEXISTENT MODE");
 
-                _model.proj(0).projectMT(img, rot);
+                if (_para.mode == MODE_2D)
+                {
+                    _model.proj(0).projectMT(img, rot2D);
+                }
+                else if (_para.mode == MODE_3D)
+                {
+                    _model.proj(0).projectMT(img, rot3D);
+                }
+                else
+                    REPORT_ERROR("INEXISTENT MODE");
             }
             else
             {
                 if (!_switch[l]) continue;
 
-                _par[l].rank1st(rot, tran);
+                if (_para.mode == MODE_2D)
+                {
+                    _par[l].rank1st(cls, rot2D, tran);
+                }
+                else if (_para.mode == MODE_3D)
+                {
+                    _par[l].rank1st(cls, rot3D, tran);
+                }
+                else
+                    REPORT_ERROR("INEXISTENT MODE");
 
+                if (_para.mode == MODE_2D)
+                {
 #ifdef OPTIMISER_RECENTRE_IMAGE_EACH_ITERATION
 #ifdef OPTIMISER_SCALE_MASK
-                _model.proj(0).projectMT(img, rot, tran);
+                    _model.proj(cls).projectMT(img, rot2D, tran);
 #else
-                _model.proj(0).projectMT(img, rot, tran - _offset[l]);
+                    _model.proj(cls).projectMT(img, rot2D, tran - _offset[l]);
 #endif
 #else
-                _model.proj(0).projectMT(img, rot, tran);
+                    _model.proj(cls).projectMT(img, rot2D, tran);
+#endif
+                }
+                else if (_para.mode == MODE_3D)
+                {
+#ifdef OPTIMISER_RECENTRE_IMAGE_EACH_ITERATION
+#ifdef OPTIMISER_SCALE_MASK
+                    _model.proj(cls).projectMT(img, rot3D, tran);
+#else
+                    _model.proj(cls).projectMT(img, rot3D, tran - _offset[l]);
 #endif
+#else
+                    _model.proj(cls).projectMT(img, rot3D, tran);
+#endif
+                }
+                else
+                    REPORT_ERROR("INEXISTENT MODE");
             }
 
 #ifdef VERBOSE_LEVEL_3
@@ -2155,7 +2282,7 @@ void MLOptimiser::refreshScale(const bool init,
                              img,
                              _ctf[l],
                              _rS,
-                             1);
+                             0);
 #else
             scaleDataVSPrior(sXA,
                              sAA,
@@ -2163,7 +2290,7 @@ void MLOptimiser::refreshScale(const bool init,
                              img,
                              _ctf[l],
                              _rS,
-                             1);
+                             0);
 #endif
 
 #ifdef VERBOSE_LEVEL_3
@@ -2213,10 +2340,10 @@ void MLOptimiser::refreshScale(const bool init,
             double sum = 0;
             int count = 0;
 
-            for (int r = 1; r < _rS; r++)
+            for (int r = 0; r < _rS; r++)
             {
                 sum += mXA(i, r) / mAA(i, r);
-                count += 1;
+                count += 0;
             }
 
             _scale(i) = sum / count;
@@ -2227,7 +2354,7 @@ void MLOptimiser::refreshScale(const bool init,
         double sum = 0;
         int count = 0;
 
-        for (int r = 1; r < _rS; r++)
+        for (int r = 0; r < _rS; r++)
         {
             sum += mXA(0, r) / mAA(0, r);
             count += 1;
@@ -2293,6 +2420,7 @@ void MLOptimiser::reCentreImg()
         _offset[l](0) -= tran(0);
         _offset[l](1) -= tran(1);
 
+        /***
         if ((fabs(_offset[l](0)) > gsl_cdf_chisq_Qinv(TRANS_Q, 2) * _para.transS) ||
             (fabs(_offset[l](1)) > gsl_cdf_chisq_Qinv(TRANS_Q, 2) * _para.transS))
         {
@@ -2303,11 +2431,14 @@ void MLOptimiser::reCentreImg()
             _offset[l](0) = 0;
             _offset[l](1) = 0;
         }
+        ***/
 
         translate(_img[l],
                   _imgOri[l],
                   _offset[l](0),
                   _offset[l](1));
+
+        _par[l].setT(_par[l].t().rowwise() - tran.transpose());
     }
 }
 #endif
@@ -2318,15 +2449,24 @@ void MLOptimiser::reMaskImg()
 
     if (_para.zeroMask)
     {
+        Image mask(_para.size, _para.size, RL_SPACE);
+
+        softMask(mask,
+                 _para.maskRadius / _para.pixelSize - EDGE_WIDTH_RL,
+                 EDGE_WIDTH_RL);
+
         #pragma omp parallel for
         FOR_EACH_2D_IMAGE
             C2C_RL(_img[l],
                    _img[l],
+                   MUL_RL(_img[l], mask));
+        /***
                    softMask(_img[l],
                             _img[l],
                             _para.maskRadius / _para.pixelSize - EDGE_WIDTH_RL,
                             EDGE_WIDTH_RL,
                             0));
+                            ***/
     }
     else
     {
@@ -2334,6 +2474,217 @@ void MLOptimiser::reMaskImg()
     }
 }
 
+void MLOptimiser::normCorrection()
+{
+    vec norm = vec::Zero(_nPar);
+
+    int cls;
+
+    mat22 rot2D;
+    mat33 rot3D;
+
+    vec2 tran;
+
+    NT_MASTER
+    {
+        #pragma omp parallel for private(rot2D, rot3D, tran)
+        FOR_EACH_2D_IMAGE
+        {
+            Image img(size(), size(), FT_SPACE);
+
+            SET_0_FT(img);
+
+            if (_para.mode == MODE_2D)
+            {
+                _par[l].rank1st(cls, rot2D, tran);
+
+#ifdef OPTIMISER_RECENTRE_IMAGE_EACH_ITERATION
+#ifdef OPTIMISER_NORM_MASK
+                _model.proj(cls).project(img, rot2D, tran);
+#else
+                _model.proj(cls).project(img, rot2D, tran - _offset[l]);
+#endif
+#else
+                _model.proj(cls).project(img, rot2D, tran);
+#endif
+            }
+            else if (_para.mode == MODE_3D)
+            {
+                _par[l].rank1st(cls, rot3D, tran);
+
+#ifdef OPTIMISER_RECENTRE_IMAGE_EACH_ITERATION
+#ifdef OPTIMISER_NORM_MASK
+                _model.proj(cls).project(img, rot3D, tran);
+#else
+                _model.proj(cls).project(img, rot3D, tran - _offset[l]);
+#endif
+#else
+                _model.proj(cls).project(img, rot3D, tran);
+#endif
+            }
+
+            FOR_EACH_PIXEL_FT(img)
+                img[i] *= REAL(_ctf[l][i]);
+
+#ifdef OPTIMISER_ADJUST_2D_IMAGE_NOISE_ZERO_MEAN
+            _img[l][0] = img[0];
+            _imgOri[l][0] = img[0];
+#endif
+
+            NEG_FT(img);
+
+#ifdef OPTIMISER_NORM_MASK
+            ADD_FT(img, _img[l]);
+#else
+            ADD_FT(img, _imgOri[l]);
+#endif
+
+            /***
+            FFT fft;
+            fft.bw(img);
+            ***/
+
+            /***
+            norm(_ID[l] - 1) = gsl_stats_mean(&img(0),
+                                              1,
+                                              img.sizeRL());
+                                              ***/
+
+            /***
+            double mean;
+            double stddev;
+
+            centreMeanStddev(mean,
+                             stddev,
+                             img,
+                             _para.maskRadius / _para.pixelSize - EDGE_WIDTH_RL);
+
+            norm(_ID[l] - 1) = stddev;
+            ***/
+
+            /***
+#ifdef OPTIMISER_ADJUST_2D_IMAGE_NOISE_ZERO_MEAN
+            _img[l][0] -= mean;
+            _imgOri[l][0] -= mean;
+#endif
+***/
+
+            /***
+            norm(_ID[l] - 1) = centreStddev(0,
+                                            img,
+                                            _para.maskRadius
+                                          / _para.pixelSize
+                                          - EDGE_WIDTH_RL);
+                                          ***/
+
+            IMAGE_FOR_EACH_PIXEL_FT(img)
+            {
+                if (QUAD(i, j) < gsl_pow_2(_r))
+                    norm(_ID[l] - 1) += ABS2(img.getFTHalf(i, j));
+            }
+        }
+    }
+
+    MPI_Barrier(MPI_COMM_WORLD);
+
+    MPI_Allreduce(MPI_IN_PLACE,
+                  norm.data(),
+                  norm.size(),
+                  MPI_DOUBLE,
+                  MPI_SUM,
+                  MPI_COMM_WORLD); 
+
+    MPI_Barrier(MPI_COMM_WORLD);
+
+    IF_MASTER
+    {
+        for (int i = 0; i < 100; i++)
+            MLOG(INFO, "LOGGER_SYS") << "norm "
+                                     << i
+                                     << " = "
+                                     << norm[i];
+    }
+
+    MLOG(INFO, "LOGGER_SYS") << "Max of Norm of Noise : "
+                             << gsl_stats_max(norm.data(), 1, norm.size());
+
+    MLOG(INFO, "LOGGER_SYS") << "Min of Norm of Noise : "
+                             << gsl_stats_min(norm.data(), 1, norm.size());
+
+    //double m = gsl_stats_mean(norm.data(), 1, norm.size());
+
+    double m = median(norm, norm.size());
+
+    MLOG(INFO, "LOGGER_SYS") << "Mean of Norm of Noise : "
+                             << m;
+
+    /***
+    for (int i = 0; i < norm.size(); i++)
+    {
+        if (norm(i) < m / 5)
+            norm(i) = m / 5;
+        else if (norm(i) > m * 5)
+            norm(i) = m * 5;
+    }
+    ***/
+
+    /***
+    double sd = gsl_stats_sd_m(norm.data(), 1, norm.size(), m);
+
+    MLOG(INFO, "LOGGER_SYS") << "Standard Deviation of Norm of Noise : "
+                             << sd;
+                             ***/
+
+    NT_MASTER
+    {
+        #pragma omp parallel for
+        FOR_EACH_2D_IMAGE
+        {
+            /***
+            ALOG(INFO, "LOGGER_SYS") << "isEmptyRL of img " << _img[l].isEmptyRL();
+            ALOG(INFO, "LOGGER_SYS") << "isEmptyFT of img " << _img[l].isEmptyFT();
+
+            ALOG(INFO, "LOGGER_SYS") << "SizeRL of img " << _img[l].sizeRL();
+            ALOG(INFO, "LOGGER_SYS") << "SizeFT of img " << _img[l].sizeFT();
+
+            ALOG(INFO, "LOGGER_SYS") << "isEmptyRL of imgOri " << _imgOri[l].isEmptyRL();
+            ALOG(INFO, "LOGGER_SYS") << "isEmptyFT of imgOri " << _imgOri[l].isEmptyFT();
+
+            ALOG(INFO, "LOGGER_SYS") << "SizeRL of imgOri " << _imgOri[l].sizeRL();
+            ALOG(INFO, "LOGGER_SYS") << "SizeFT of imgOri " << _imgOri[l].sizeFT();
+
+            FFT fft;
+
+            fft.bw(_imgOri[l]);
+
+            FOR_EACH_PIXEL_RL(_imgOri[l])
+                _imgOri[l](i) /= 2;
+
+            fft.fw(_imgOri[l]);
+            ***/
+            
+            /***
+            fft.bw(_img[l]);
+
+            FOR_EACH_PIXEL_RL(_img[l])
+                _img[l](i) /= 2;
+
+            fft.fw(_img[l]);
+            ***/
+
+            FOR_EACH_PIXEL_FT(_img[l])
+            {
+                // _img[l][i] /= 2;
+                // _imgOri[l][i] /= 2;
+                // _img[l][i] *= (m / norm(_ID[l] - 1));
+                // _imgOri[l][i] *= (m / norm(_ID[l] - 1));
+                _img[l][i] *= sqrt(m / norm(_ID[l] - 1));
+                _imgOri[l][i] *= sqrt(m / norm(_ID[l] - 1));
+            }
+        }
+    }
+}
+
 void MLOptimiser::allReduceSigma(const bool group)
 {
     IF_MASTER return;
@@ -2348,7 +2699,10 @@ void MLOptimiser::allReduceSigma(const bool group)
     ALOG(INFO, "LOGGER_ROUND") << "Recalculating Sigma";
     BLOG(INFO, "LOGGER_ROUND") << "Recalculating Sigma";
 
-    mat33 rot;
+    int cls;
+
+    mat22 rot2D;
+    mat33 rot3D;
 
     vec2 tran;
 
@@ -2358,7 +2712,7 @@ void MLOptimiser::allReduceSigma(const bool group)
     for (int l = 0; l < _nGroup; l++)
         omp_init_lock(&mtx[l]);
 
-    #pragma omp parallel for private(rot, tran) schedule(dynamic)
+    #pragma omp parallel for private(rot2D, rot3D, tran) schedule(dynamic)
     FOR_EACH_2D_IMAGE
     {
         if (_switch[l])
@@ -2367,17 +2721,48 @@ void MLOptimiser::allReduceSigma(const bool group)
 
             vec sig(_r);
 
-            _par[l].rank1st(rot, tran);
+            if (_para.mode == MODE_2D)
+            {
+                _par[l].rank1st(cls, rot2D, tran);
 
 #ifdef OPTIMISER_RECENTRE_IMAGE_EACH_ITERATION
 #ifdef OPTIMISER_SIGMA_MASK
-            _model.proj(0).project(img, rot, tran);
+                _model.proj(cls).project(img, rot2D, tran);
 #else
-            _model.proj(0).project(img, rot, tran - _offset[l]);
+                _model.proj(cls).project(img, rot2D, tran - _offset[l]);
 #endif
 #else
-            _model.proj(0).project(img, rot, tran);
+                _model.proj(cls).project(img, rot2D, tran);
 #endif
+            }
+            else if (_para.mode == MODE_3D)
+            {
+                _par[l].rank1st(cls, rot3D, tran);
+
+#ifdef OPTIMISER_RECENTRE_IMAGE_EACH_ITERATION
+#ifdef OPTIMISER_SIGMA_MASK
+                _model.proj(cls).project(img, rot3D, tran);
+#else
+                _model.proj(cls).project(img, rot3D, tran - _offset[l]);
+#endif
+#else
+                _model.proj(cls).project(img, rot3D, tran);
+#endif
+            }
+
+            /***
+            double weight = logDataVSPrior(_img[l],
+                                           img,
+                                           _ctf[l],
+                                           _sigRcp.row(_groupID[l] - 1).transpose(),
+                                           _r,
+                                           2.5);
+
+            ALOG(INFO, "LOGGER_SYS") << "_ID = "
+                                     << _ID[l]
+                                     << ", Final dataVSPrior = "
+                                     << exp(weight);
+                                     ***/
 
             FOR_EACH_PIXEL_FT(img)
                 img[i] *= REAL(_ctf[l][i]);
@@ -2390,9 +2775,6 @@ void MLOptimiser::allReduceSigma(const bool group)
             ADD_FT(img, _imgOri[l]);
 #endif
 
-#ifdef OPTIMISER_ADJUST_2D_IMAGE_NOISE_ZERO_MEAN
-            _imgOri[l][0] -= img[0];
-#endif
             powerSpectrum(sig, img, _r);
 
             if (group)
@@ -2457,6 +2839,10 @@ void MLOptimiser::allReduceSigma(const bool group)
     }
 
     #pragma omp parallel for
+    for (int i = _r; i < _sig.cols() - 1; i++)
+        _sig.col(i) = _sig.col(_r - 1);
+
+    #pragma omp parallel for
     for (int i = 0; i < _nGroup; i++)
         for (int j = 0; j < _r; j++)
             _sigRcp(i, j) = -0.5 / _sig(i, j);
@@ -2474,7 +2860,8 @@ void MLOptimiser::reconstructRef()
     ALOG(INFO, "LOGGER_ROUND") << "Inserting High Probability 2D Images into Reconstructor";
     BLOG(INFO, "LOGGER_ROUND") << "Inserting High Probability 2D Images into Reconstructor";
 
-    _model.reco(0).setPreCal(_nPxl, _iCol, _iRow, _iPxl, _iSig);
+    for (int t = 0; t < _para.k; t++)
+        _model.reco(t).setPreCal(_nPxl, _iCol, _iRow, _iPxl, _iSig);
 
     FOR_EACH_2D_IMAGE
     {
@@ -2482,53 +2869,91 @@ void MLOptimiser::reconstructRef()
 
         for (int m = 0; m < _para.mReco; m++)
         {
-            mat33 rot;
+            int cls;
+            mat22 rot2D;
+            mat33 rot3D;
             vec2 tran;
 
-            _par[l].rand(rot, tran);
+            if (_para.mode == MODE_2D)
+            {
+                _par[l].rand(cls, rot2D, tran);
+
+                /***
+                ALOG(INFO, "LOGGER_SYS") << "ID = "
+                                         << _ID[l]
+                                         << ", compress = "
+                                         << _par[l].compressTrans();
+                                         ***/
 
 #ifdef OPTIMISER_RECENTRE_IMAGE_EACH_ITERATION
-#ifdef OPTIMISER_COMPRESS_WEIGHTING
-            _par[l].calVari();
-            _model.reco(0).insertP(_imgOri[l],
-                                   _ctf[l],
-                                   rot,
-                                   tran - _offset[l],
-                                   1.0 / (NUM_SAMPLE_POINT_IN_RECONSTRUCTION
-                                        * _par[l].compress()));
+                _model.reco(cls).insertP(_imgOri[l],
+                                         _ctf[l],
+                                         rot2D,
+                                         tran - _offset[l],
+                                         1.0 / _para.mReco);
+                                         //1.0 / (_para.mReco * _par[l].compressTrans()));
+                                         //1.0 / (_para.mReco * _par[l].compress()));
+                                         //1.0 / _para.mReco * (-log(_par[l].compress())));
 #else
-            _model.reco(0).insertP(_imgOri[l],
-                                   _ctf[l],
-                                   rot,
-                                   tran - _offset[l],
-                                   1.0 / NUM_SAMPLE_POINT_IN_RECONSTRUCTION);
+                _model.reco(cls).insertP(_imgOri[l],
+                                         _ctf[l],
+                                         rot2D,
+                                         tran,
+                                         1.0 / _para.mReco);
+                                         //1.0 / (_para.mReco * _par[l].compressTrans()));
+                                         //1.0 / (_para.mReco * _par[l].compress()));
+                                         //1.0 / _para.mReco * (-log(_par[l].compress())));
 #endif
+            }
+            else if (_para.mode == MODE_3D)
+            {
+                _par[l].rand(cls, rot3D, tran);
+
+                /***
+                ALOG(INFO, "LOGGER_SYS") << "ID = "
+                                         << _ID[l]
+                                         << ", compress = "
+                                         << _par[l].compressTrans();
+                                         ***/
+
+#ifdef OPTIMISER_RECENTRE_IMAGE_EACH_ITERATION
+                _model.reco(cls).insertP(_imgOri[l],
+                                         _ctf[l],
+                                         rot3D,
+                                         tran - _offset[l],
+                                         1.0 / _para.mReco);
+                                         //1.0 / (_para.mReco * _par[l].compressTrans()));
+                                         //1.0 / (_para.mReco * _par[l].compress()));
+                                         //1.0 / _para.mReco * (-log(_par[l].compress())));
 #else
-#ifdef OPTIMISER_COMPRESS_WEIGHTING
-            _par[l].calVari();
-            _model.reco(0).insertP(_imgOri[l],
-                                   _ctf[l],
-                                    rot,
-                                    tran,
-                                    1.0 / (NUN_SAMPLE_POINT_IN_RECONSTRUCTION
-                                         * _par[l].compress()));
-#else
-            _model.reco(0).insertP(_imgOri[l],
-                                   _ctf[l],
-                                   rot,
-                                   tran,
-                                   1.0 / NUM_SAMPLE_POINT_IN_RECONSTRUCTION);
-#endif
+                _model.reco(cls).insertP(_imgOri[l],
+                                         _ctf[l],
+                                         rot3D,
+                                         tran,
+                                         1.0 / _para.mReco);
+                                         //1.0 / (_para.mReco * _par[l].compressTrans()));
+                                         //1.0 / (_para.mReco * _par[l].compress()));
+                                         //1.0 / _para.mReco * (-log(_par[l].compress())));
 #endif
+            }
+            else
+                REPORT_ERROR("INEXISTENT MODE");
         }
     }
 
     MPI_Barrier(_hemi);
 
-    ALOG(INFO, "LOGGER_ROUND") << "Reconstructing References for Next Iteration";
-    BLOG(INFO, "LOGGER_ROUND") << "Reconstructing References for Next Iteration";
+    for (int t = 0; t < _para.k; t++)
+    {
+        ALOG(INFO, "LOGGER_ROUND") << "Reconstructing Reference "
+                                   << t
+                                   << " for Next Iteration";
+        BLOG(INFO, "LOGGER_ROUND") << "Reconstructing Reference "
+                                   << t
+                                   << " for Next Iteration";
 
-    _model.reco(0).reconstruct(_model.ref(0));
+        _model.reco(t).reconstruct(_model.ref(t));
+    }
 
     ALOG(INFO, "LOGGER_ROUND") << "Freeing Space for Pre-calcuation in Reconstruction";
     BLOG(INFO, "LOGGER_ROUND") << "Freeing Space for Pre-calcuation in Reconstruction";
@@ -2540,6 +2965,7 @@ void MLOptimiser::reconstructRef()
     ALOG(INFO, "LOGGER_ROUND") << "Reference(s) Reconstructed";
     BLOG(INFO, "LOGGER_ROUND") << "Reference(s) Reconstructed";
 
+    /***
     if (_genMask)
     {
         ALOG(INFO, "LOGGER_ROUND") << "Generating Automask";
@@ -2557,92 +2983,133 @@ void MLOptimiser::reconstructRef()
 
         lowPassRef = _model.ref(0).copyVolume();
 
-        /***
-        softMask(lowPassRef,
-                 lowPassRef,
-                 _para.size / 2 - EDGE_WIDTH_RL,
-                 EDGE_WIDTH_RL,
-                 0);
-        ***/
-
         FFT fft;
 
         fft.fwMT(lowPassRef);
 
         lowPassFilter(lowPassRef,
                       lowPassRef,
-                      //_para.pixelSize / GEN_MASK_RES,
                       _model.rGlobal() / _para.size,
                       (double)EDGE_WIDTH_FT / _para.pf / _para.size);
 
         fft.bwMT(lowPassRef);
 
+        softMask(lowPassRef,
+                 lowPassRef,
+                 _para.size / 2 - EDGE_WIDTH_RL,
+                 EDGE_WIDTH_RL,
+                 0);
+
         autoMask(_mask,
                  lowPassRef,
                  GEN_MASK_EXT,
                  EDGE_WIDTH_RL,
-                 _para.size / 2);
+                 _para.size / 2 - EDGE_WIDTH_RL);
 
         saveMask();
 
         _genMask = false;
     }
+    ***/
 
     ALOG(INFO, "LOGGER_ROUND") << "Fourier Transforming References";
     BLOG(INFO, "LOGGER_ROUND") << "Fourier Transforming References";
 
     FFT fft;
-    fft.fwMT(_model.ref(0));
-    _model.ref(0).clearRL();
+    for (int t = 0; t < _para.k; t++)
+    {
+#ifdef VERBOSE_LEVEL_2
+        ALOG(INFO, "LOGGER_ROUND") << "Fourier Transforming Reference " << t;
+        BLOG(INFO, "LOGGER_ROUND") << "Fourier Transforming Reference " << t;
+#endif
+
+        /***
+        if (_para.mode == MODE_2D)
+        {
+            Image tmp(_para.size * _para.pf,
+                      _para.size * _para.pf,
+                      RL_SPACE);
+
+            SLC_EXTRACT_RL(tmp, _model.ref(t), 0);
+            fft.fwMT(tmp);
+            tmp.clearRL();
+            _model.ref(t) = Volume(tmp);
+        }
+        else if (_para.mode == MODE_3D)
+        {
+            fft.fwMT(_model.ref(t));
+            _model.ref(t).clearRL();
+        }
+        ***/
+
+        fft.fwMT(_model.ref(t));
+        _model.ref(t).clearRL();
+
+#ifdef VERBOSE_LEVEL_2
+        ALOG(INFO, "LOGGER_ROUND") << "Reference " << t << "Fourier Transformed";
+        BLOG(INFO, "LOGGER_ROUND") << "Reference " << t << "Fourier Transformed";
+#endif
+    }
 }
 
 void MLOptimiser::solventFlatten(const bool mask)
 {
     IF_MASTER return;
 
-    ALOG(INFO, "LOGGER_ROUND") << "Inverse Fourier Transforming References";
-    BLOG(INFO, "LOGGER_ROUND") << "Inverse Fourier Transforming References";
+    for (int t = 0; t < _para.k; t++)
+    {
+        ALOG(INFO, "LOGGER_ROUND") << "Inverse Fourier Transforming Reference " << t;
+        BLOG(INFO, "LOGGER_ROUND") << "Inverse Fourier Transforming Reference " << t;
 
-    FFT fft;
-    fft.bwMT(_model.ref(0));
+        FFT fft;
+        fft.bwMT(_model.ref(t));
 
-    if (mask && !_mask.isEmptyRL())
-    {
-        ALOG(INFO, "LOGGER_ROUND") << "Performing Reference Masking";
-        BLOG(INFO, "LOGGER_ROUND") << "Performing Reference Masking";
+        if (mask && !_mask.isEmptyRL())
+        {
+            ALOG(INFO, "LOGGER_ROUND") << "Performing Reference Masking";
+            BLOG(INFO, "LOGGER_ROUND") << "Performing Reference Masking";
 
-#ifdef OPTIMISER_REFERENCE_ZERO_MASK
-        softMask(_model.ref(0), _model.ref(0), _mask, 0);
-#else
-        softMask(_model.ref(0), _model.ref(0), _mask);
-#endif
-    }
-    else
-    {
-        ALOG(INFO, "LOGGER_ROUND") << "Performing Solvent Flatten";
-        BLOG(INFO, "LOGGER_ROUND") << "Performing Solvent Flatten";
+            softMask(_model.ref(t), _model.ref(t), _mask, 0);
+        }
+        else
+        {
+            ALOG(INFO, "LOGGER_ROUND") << "Performing Solvent Flatten of Reference " << t;
+            BLOG(INFO, "LOGGER_ROUND") << "Performing Solvent Flatten of Reference " << t;
 
-#ifdef OPTIMISER_REFERENCE_ZERO_MASK
-        softMask(_model.ref(0),
-                 _model.ref(0),
-                 SOLVENT_FLATTEN_LOOSE_FACTOR * _para.size / 4 - EDGE_WIDTH_RL,
-                 EDGE_WIDTH_RL,
-                 0);
-#else
-        regionBgSoftMask(_model.ref(0),
-                         _model.ref(0),
-                         SOLVENT_FLATTEN_LOOSE_FACTOR * _para.size / 4 - EDGE_WIDTH_RL,
+            if (_para.mode == MODE_2D)
+            {
+                Image ref(_para.size,
+                          _para.size,
+                          RL_SPACE);
+
+                SLC_EXTRACT_RL(ref, _model.ref(t), 0);
+
+                softMask(ref,
+                         ref, 
+                         _para.maskRadius / _para.pixelSize - EDGE_WIDTH_RL,
                          EDGE_WIDTH_RL,
-                         _para.size / 2,
-                         SOLVENT_FLATTEN_LOOSE_FACTOR * _para.size / 4 - EDGE_WIDTH_RL);
-#endif
-    }
+                         0);
 
-    ALOG(INFO, "LOGGER_ROUND") << "Fourier Transforming References";
-    BLOG(INFO, "LOGGER_ROUND") << "Fourier Transforming References";
+                COPY_RL(_model.ref(t), ref);
+            }
+            else if (_para.mode == MODE_3D)
+            {
+                softMask(_model.ref(t),
+                         _model.ref(t),
+                         _para.maskRadius / _para.pixelSize - EDGE_WIDTH_RL,
+                         EDGE_WIDTH_RL,
+                         0);
+            }
+            else
+                REPORT_ERROR("INEXISTENT MODE");
+        }
 
-    fft.fwMT(_model.ref(0));
-    _model.ref(0).clearRL();
+        ALOG(INFO, "LOGGER_ROUND") << "Fourier Transforming Reference " << t;
+        BLOG(INFO, "LOGGER_ROUND") << "Fourier Transforming Reference " << t;
+
+        fft.fwMT(_model.ref(t));
+        _model.ref(t).clearRL();
+    }
 }
 
 void MLOptimiser::allocPreCalIdx(const double rU,
@@ -2783,7 +3250,9 @@ void MLOptimiser::saveBestProjections()
     Image diff(_para.size, _para.size, FT_SPACE);
     char filename[FILE_NAME_LENGTH];
 
-    mat33 rot;
+    int cls;
+    mat22 rot2D;
+    mat33 rot3D;
     vec2 tran;
 
     FOR_EACH_2D_IMAGE
@@ -2796,9 +3265,20 @@ void MLOptimiser::saveBestProjections()
             #pragma omp parallel for
             SET_0_FT(diff);
 
-            _par[l].rank1st(rot, tran);
+            if (_para.mode == MODE_2D)
+            {
+                _par[l].rank1st(cls, rot2D, tran);
 
-            _model.proj(0).projectMT(result, rot, tran);
+                _model.proj(cls).projectMT(result, rot2D, tran);
+            }
+            else if (_para.mode == MODE_3D)
+            {
+                _par[l].rank1st(cls, rot3D, tran);
+
+                _model.proj(cls).projectMT(result, rot3D, tran);
+            }
+            else
+                REPORT_ERROR("INEXISTENT MODE");
 
             #pragma omp parallel for
             FOR_EACH_PIXEL_FT(diff)
@@ -2915,78 +3395,116 @@ void MLOptimiser::saveReference(const bool finished)
         (_commRank != HEMI_B_LEAD))
         return;
 
-    Volume lowPass(_para.size * _para.pf,
-                   _para.size * _para.pf,
-                   _para.size * _para.pf,
-                   FT_SPACE);
-
     FFT fft;
 
-    if (finished)
-        fft.bwMT(_model.ref(0));
-    else
-    {
-        lowPassFilter(lowPass,
-                      _model.ref(0),
-                      (double)_resReport / _para.size,
-                      (double)EDGE_WIDTH_FT / _para.size);
-        fft.bwMT(lowPass);
-    }
-
     ImageFile imf;
     char filename[FILE_NAME_LENGTH];
 
-    Volume result;
-
-    if (_commRank == HEMI_A_LEAD)
+    for (int t = 0; t < _para.k; t++)
     {
-        ALOG(INFO, "LOGGER_ROUND") << "Saving Reference(s)";
-
-        if (finished)
+        if (_para.mode == MODE_2D)
         {
-            VOL_EXTRACT_RL(result, _model.ref(0), 1.0 / _para.pf);
+            if (_commRank == HEMI_A_LEAD)
+            {
+                ALOG(INFO, "LOGGER_ROUND") << "Saving Reference " << t;
 
-            fft.fwMT(_model.ref(0));
-            _model.ref(0).clearRL();
+                Image ref(_para.size,
+                          _para.size,
+                          FT_SPACE);
 
-            sprintf(filename, "Reference_A_Final.mrc");
-        }
-        else
-        {
-            VOL_EXTRACT_RL(result, lowPass, 1.0 / _para.pf);
-            sprintf(filename, "Reference_A_Round_%03d.mrc", _iter);
-        }
+                SLC_EXTRACT_FT(ref, _model.ref(t), 0);
 
-        REMOVE_NEG(result);
+                sprintf(filename, "FT_Reference_%03d_A_Round_%03d.bmp", t, _iter);
+                ref.saveFTToBMP(filename, 0.001);
 
-        imf.readMetaData(result);
+                fft.bwMT(ref);
 
-        imf.writeVolume(filename, result, _para.pixelSize);
-    }
-    else if (_commRank == HEMI_B_LEAD)
-    {
-        BLOG(INFO, "LOGGER_ROUND") << "Saving Reference(s)";
+                sprintf(filename, "Reference_%03d_A_Round_%03d.bmp", t, _iter);
+                ref.saveRLToBMP(filename);
+            }
+            else if (_commRank == HEMI_B_LEAD)
+            {
+                BLOG(INFO, "LOGGER_ROUND") << "Saving Reference " << t;
 
-        if (finished)
-        {
-            VOL_EXTRACT_RL(result, _model.ref(0), 1.0 / _para.pf);
+                Image ref(_para.size,
+                          _para.size,
+                          FT_SPACE);
 
-            fft.fwMT(_model.ref(0));
-            _model.ref(0).clearRL();
+                SLC_EXTRACT_FT(ref, _model.ref(t), 0);
 
-            sprintf(filename, "Reference_B_Final.mrc");
+                sprintf(filename, "FT_Reference_%03d_B_Round_%03d.bmp", t, _iter);
+                ref.saveFTToBMP(filename, 0.001);
+
+                fft.bwMT(ref);
+
+                sprintf(filename, "Reference_%03d_B_Round_%03d.bmp", t, _iter);
+                ref.saveRLToBMP(filename);
+            }
         }
-        else
+        else if (_para.mode == MODE_3D)
         {
-            VOL_EXTRACT_RL(result, lowPass, 1.0 / _para.pf);
-            sprintf(filename, "Reference_B_Round_%03d.mrc", _iter);
-        }
+            Volume lowPass(_para.size,
+                           _para.size,
+                           _para.size,
+                           FT_SPACE);
 
-        REMOVE_NEG(result);
+            if (finished)
+                fft.bwMT(_model.ref(t));
+            else
+            {
+                lowPassFilter(lowPass,
+                              _model.ref(0),
+                              (double)_resReport / _para.size,
+                              (double)EDGE_WIDTH_FT / _para.size);
+                fft.bwMT(lowPass);
+            }
 
-        imf.readMetaData(result);
+            if (_commRank == HEMI_A_LEAD)
+            {
+                ALOG(INFO, "LOGGER_ROUND") << "Saving Reference " << t;
 
-        imf.writeVolume(filename, result, _para.pixelSize);
+                if (finished)
+                {
+                    sprintf(filename, "Reference_%03d_A_Final.mrc", t);
+
+                    imf.readMetaData(_model.ref(t));
+                    imf.writeVolume(filename, _model.ref(t), _para.pixelSize);
+
+                    fft.fwMT(_model.ref(t));
+                    _model.ref(t).clearRL();
+
+                }
+                else
+                {
+                    sprintf(filename, "Reference_%03d_A_Round_%03d.mrc", t, _iter);
+
+                    imf.readMetaData(lowPass);
+                    imf.writeVolume(filename, lowPass, _para.pixelSize);
+                }
+            }
+            else if (_commRank == HEMI_B_LEAD)
+            {
+                BLOG(INFO, "LOGGER_ROUND") << "Saving Reference " << t;
+
+                if (finished)
+                {
+                    sprintf(filename, "Reference_%03d_B_Final.mrc", t);
+
+                    imf.readMetaData(_model.ref(t));
+                    imf.writeVolume(filename, _model.ref(t), _para.pixelSize);
+
+                    fft.fwMT(_model.ref(t));
+                    _model.ref(t).clearRL();
+                }
+                else
+                {
+                    sprintf(filename, "Reference_%03d_B_Round_%03d.mrc", t, _iter);
+
+                    imf.readMetaData(lowPass);
+                    imf.writeVolume(filename, lowPass, _para.pixelSize);
+                }
+            }
+        }
     }
 }
 
@@ -3044,23 +3562,26 @@ void MLOptimiser::saveFSC(const bool finished) const
 
     char filename[FILE_NAME_LENGTH];
 
-    vec fsc = _model.fsc(0);
+    for (int t = 0; t < _para.k; t++)
+    {
+        vec fsc = _model.fsc(t);
 
-    if (finished)
-        sprintf(filename, "FSC_Final.txt");
-    else
-        sprintf(filename, "FSC_Round_%03d.txt", _iter);
+        if (finished)
+            sprintf(filename, "FSC_%03d_Final.txt", t);
+        else
+            sprintf(filename, "FSC_%03d_Round_%03d.txt", t, _iter);
 
-    FILE* file = fopen(filename, "w");
+        FILE* file = fopen(filename, "w");
 
-    for (int i = 1; i < fsc.size(); i++)
-        fprintf(file,
-                "%05d   %10.6lf   %10.6lf\n",
-                i,
-                1.0 / resP2A(i, _para.size * _para.pf, _para.pixelSize),
-                fsc(i));
+        for (int i = 1; i < fsc.size(); i++)
+            fprintf(file,
+                    "%05d   %10.6lf   %10.6lf\n",
+                    i,
+                    1.0 / resP2A(i, _para.size * _para.pf, _para.pixelSize),
+                    fsc(i));
 
-    fclose(file);
+        fclose(file);
+    }
 }
 
 void MLOptimiser::saveSig() const
@@ -3079,8 +3600,6 @@ void MLOptimiser::saveSig() const
     FILE* file = fopen(filename, "w");
 
     for (int i = 1; i < maxR(); i++)
-    //for (int i = 1; i < _r; i++)
-    //for (int i = 1; i < _model.rU(); i++)
         fprintf(file,
                 "%05d   %10.6lf   %10.6lf\n",
                 i,
@@ -3105,8 +3624,6 @@ void MLOptimiser::saveTau() const
 
     FILE* file = fopen(filename, "w");
 
-    //for (int i = 1; i < _model.rU() * _para.pf - 1; i++)
-    //for (int i = 1; i < _r * _para.pf - 1; i++)
     for (int i = 1; i < maxR() * _para.pf - 1; i++)
         fprintf(file,
                 "%05d   %10.6lf   %10.6lf\n",
diff --git a/src/Particle.cpp b/src/Particle.cpp
index 2cbaed5..cd2c79b 100644
--- a/src/Particle.cpp
+++ b/src/Particle.cpp
@@ -13,14 +13,16 @@ Particle::Particle()
     defaultInit();
 }
 
-Particle::Particle(const int n,
+Particle::Particle(const int mode,
+                   const int m,
+                   const int n,
                    const double transS,
                    const double transQ,
                    const Symmetry* sym)
 {
     defaultInit();
 
-    init(n, transS, transQ, sym);
+    init(mode, m, n, transS, transQ, sym);
 }
 
 Particle::~Particle()
@@ -28,27 +30,35 @@ Particle::~Particle()
     clear();
 }
 
-void Particle::init(const double transS,
+void Particle::init(const int mode,
+                    const double transS,
                     const double transQ,
                     const Symmetry* sym)
 {
     clear();
 
+    _mode = mode;
+
     _transS = transS;
     _transQ = transQ;
 
     _sym = sym;
 }
 
-void Particle::init(const int n,
+void Particle::init(const int mode,
+                    const int m,
+                    const int n,
                     const double transS,
                     const double transQ,
                     const Symmetry* sym)
 {
-    init(transS, transQ, sym);
+    init(mode, transS, transQ, sym);
+
+    _m = m;
 
     _n = n;
 
+    _c.resize(_n);
     _r.resize(_n, 4);
     _t.resize(_n, 2);
 
@@ -59,13 +69,34 @@ void Particle::init(const int n,
 
 void Particle::reset()
 {
-    // sample from Angular Central Gaussian Distribution with identity matrix
-    sampleACG(_r, 1, 1, _n);
-
-    // sample from 2D Gaussian Distribution
     gsl_rng* engine = get_random_engine();
 
+    // class, sample from flat distribution
+    for (int i = 0; i < _n; i++)
+        _c(i) = gsl_rng_uniform_int(engine, _m);
+
+    switch (_mode)
+    {
+        // rotation, MODE_2D, sample from von Mises Distribution with kappa = 0
+        case MODE_2D:
+            sampleVMS(_r, vec4(1, 0, 0, 0), 0, _n);
+            break;
+
+        // rotation, MODE_3D, sample from Angular Central Gaussian Distribution
+        // with identity matrix
+        case MODE_3D:
+            sampleACG(_r, 1, 1, _n);
+            break;
+
+        default:
+            CLOG(FATAL, "LOGGER_SYS") << __FUNCTION__
+                                      << ": INEXISTENT MODE";
+            break;
+    }
+
+
 #ifdef PARTICLE_TRANS_INIT_GAUSSIAN
+    // sample from 2D Gaussian Distribution
     for (int i = 0; i < _n; i++)
     {
         gsl_ran_bivariate_gaussian(engine,
@@ -74,8 +105,6 @@ void Particle::reset()
                                    0,
                                    &_t(i, 0),
                                    &_t(i, 1));
-                
-        _w(i) = 1.0 / _n;
     }
 #endif
 
@@ -88,18 +117,24 @@ void Particle::reset()
 
         _t(i, 0) = r * cos(t);
         _t(i, 1) = r * sin(t);
-
-        _w(i) = 1.0 / _n;
     }
 #endif
 
-    symmetrise();
+    // initialise weight
+    for (int i = 0; i < _n; i++)
+        _w(i) = 1.0 / _n;
+
+    if (_mode == MODE_3D) symmetrise();
 }
 
-void Particle::reset(const int n)
+void Particle::reset(const int m,
+                     const int n)
 {
+    _m = m;
+
     _n = n;
 
+    _c.resize(_n);
     _r.resize(_n, 4);
     _t.resize(_n, 2);
     _w.resize(_n);
@@ -107,24 +142,51 @@ void Particle::reset(const int n)
     reset();
 }
 
-void Particle::reset(const int nR,
+void Particle::reset(const int m,
+                     const int nR,
                      const int nT)
 {
-    _n = nR * nT;
+    gsl_rng* engine = get_random_engine();
+
+    _m = m;
 
+    _n = m * nR * nT;
+
+    _c.resize(_n);
     _r.resize(_n, 4);
     _t.resize(_n, 2);
     _w.resize(_n);
 
+    uvec c(m);
+
+    // sample from 0 to (m - 1)
+    for (int i = 0; i < m; i++)
+        c(i) = i;
+
     mat4 r(nR, 4);
 
-    // sample from Angular Central Gaussian Distribution with identity matrix
-    sampleACG(r, 1, 1, nR);
-    
+    switch (_mode)
+    {
+        case MODE_2D:
+            // sample from von Mises Distribution with kappa = 0
+            sampleVMS(r, vec4(1, 0, 0, 0), 0, nR);
+            break;
+
+        case MODE_3D:
+            // sample from Angular Central Gaussian Distribution with identity matrix
+            sampleACG(r, 1, 1, nR);
+            break;
+
+        default:
+            CLOG(FATAL, "LOGGER_SYS") << __FUNCTION__
+                                      << ": INEXISTENT MODE";
+            break;
+    }
+
     mat2 t(nT, 2);
 
+#ifdef PARTICLE_TRANS_INIT_GAUSSIAN
     // sample from 2D Gaussian Distribution
-    gsl_rng* engine = get_random_engine();
     for (int i = 0; i < nT; i++)
         gsl_ran_bivariate_gaussian(engine,
                                    _transS,
@@ -132,19 +194,44 @@ void Particle::reset(const int nR,
                                    0,
                                    &t(i, 0),
                                    &t(i, 1));
+#endif
 
-    for (int j = 0; j < nR; j++)
-        for (int i = 0; i < nT; i++)
-        {
-            _r.row(j * nT + i) = r.row(j);
-            _t.row(j * nT + i) = t.row(i);
+#ifdef PARTICLE_TRANS_INIT_FLAT
+    // sample for 2D Flat Distribution in a Circle
+    for (int i = 0; i < nT; i++)
+    {
+        double r = gsl_ran_flat(engine, 0, _transS);
+        double t = gsl_ran_flat(engine, 0, 2 * M_PI);
 
-            _w(j * nT + i) = 1.0 / _n;
-        }
+        t(i, 0) = r * cos(t);
+        t(i, 1) = r * sin(t);
+    }
+#endif
+
+    for (int k = 0; k < m; k++)
+        for (int j = 0; j < nR; j++)
+            for (int i = 0; i < nT; i++)
+            {
+                _c(k * nR * nT + j * nT + i) = c(k);
+
+                _r.row(k * nR * nT + j * nT + i) = r.row(j);
 
-    symmetrise();
+                _t.row(k * nR * nT + j * nT + i) = t.row(i);
+
+                _w(k * nR * nT + j * nT + i) = 1.0 / _n;
+            }
+
+    if (_mode == MODE_3D) symmetrise();
 }
 
+int Particle::mode() const { return _mode; }
+
+void Particle::setMode(const int mode) { _mode = mode; }
+
+int Particle::m() const { return _m; }
+
+void Particle::setM(const int m) { _m = m; }
+
 int Particle::n() const { return _n; }
 
 void Particle::setN(const int n) { _n = n; }
@@ -157,6 +244,10 @@ double Particle::transQ() const { return _transQ; }
 
 void Particle::setTransQ(const double transQ) { _transQ = transQ; }
 
+uvec Particle::c() const { return _c; }
+
+void Particle::setC(const uvec& c) { _c = c; }
+
 mat4 Particle::r() const { return _r; }
 
 void Particle::setR(const mat4& r) { _r = r; }
@@ -190,18 +281,74 @@ void Particle::vari(double& rVari,
                     double& s0,
                     double& s1) const
 {
-    rVari = sqrt(_k1) / sqrt(_k0);
+    switch (_mode)
+    {
+        case MODE_2D:
+            rVari = 1.0 / (1 + _k); // TODO: it is a approximation
+            break;
+
+        case MODE_3D:
+            /***
+            if (_k0 == 0) CLOG(FATAL, "LOGGER_SYS") << "k0 = 0";
+            if (gsl_isnan(_k0)) CLOG(FATAL, "LOGGER_SYS") << "k0 NAN";
+            if (gsl_isnan(_k1)) CLOG(FATAL, "LOGGER_SYS") << "k1 NAN";
+            ***/
+
+            rVari = sqrt(_k1) / sqrt(_k0);
+
+            break;
+
+        default:
+            CLOG(FATAL, "LOGGER_SYS") << __FUNCTION__
+                                      << ": INEXISTENT MODE";
+            break;
+    }
+
     s0 = _s0;
     s1 = _s1;
 }
 
+double Particle::compressTrans() const
+{
+    return _s0 * _s1 / gsl_pow_2(_transS);
+}
+
+double Particle::compressPerDim() const
+{
+    double cmp = compress();
+
+    switch (_mode)
+    {
+        case MODE_2D:
+            return pow(cmp, 1.0 / 3);
+
+        case MODE_3D:
+            return pow(cmp, 1.0 / 5);
+
+        default:
+            REPORT_ERROR("INEXISTENT MODE");
+            abort();
+    }
+}
+
 double Particle::compress() const
 {
     double rVari, s0, s1;
 
     vari(rVari, s0, s1);
 
-    return gsl_pow_3(rVari) * s0 * s1 / gsl_pow_2(_transS);
+    switch (_mode)
+    {
+        case MODE_2D:
+            return rVari * s0 * s1 / gsl_pow_2(_transS);
+            
+        case MODE_3D:
+            return gsl_pow_3(rVari) * s0 * s1 / gsl_pow_2(_transS);
+
+        default:
+            REPORT_ERROR("INEXISTENT MODE");
+            abort();
+    }
 }
 
 double Particle::w(const int i) const { return _w(i); }
@@ -236,6 +383,24 @@ void Particle::coord(Coordinate5D& dst,
     dst.y = _t(i, 1);
 }
 
+void Particle::c(int& dst,
+                 const int i) const
+{
+    dst = _c(i);
+}
+
+void Particle::setC(const int src,
+                    const int i)
+{
+    _c(i) = src;
+}
+
+void Particle::rot(mat22& dst,
+                   const int i) const
+{
+    rotate2D(dst, vec2(_r(i, 0), _r(i, 1)));
+}
+
 void Particle::rot(mat33& dst,
                    const int i) const
 {
@@ -278,7 +443,12 @@ void Particle::calVari()
 
     _rho = 0;
 
-    inferACG(_k0, _k1, _r);
+    if (_mode == MODE_2D)
+        inferVMS(_k, _r);
+    else if (_mode == MODE_3D)
+        inferACG(_k0, _k1, _r);
+    else
+        REPORT_ERROR("INEXISTENT MODE");
 }
 
 void Particle::perturb(const double pf)
@@ -295,8 +465,12 @@ void Particle::perturb(const double pf)
     {
         double x, y;
         gsl_ran_bivariate_gaussian(engine, _s0, _s1, _rho, &x, &y);
+        _t(i, 0) += x * pf;
+        _t(i, 1) += y * pf;
+        /***
         _t(i, 0) += x * sqrt(pf);
         _t(i, 1) += y * sqrt(pf);
+        ***/
     }
 
 #ifdef VERBOSE_LEVEL_4
@@ -304,7 +478,25 @@ void Particle::perturb(const double pf)
 #endif
 
     mat4 d(_n, 4);
-    sampleACG(d, pow(pf, -2.0 / 3) * _k0, _k1, _n);
+
+    switch (_mode)
+    {
+        case MODE_2D:
+            // for more sparse, pf > 1
+            // for more dense, 0 < pf < 1
+            sampleVMS(d, vec4(1, 0, 0, 0), _k / pf, _n);
+            break;
+
+        case MODE_3D:
+            //sampleACG(d, pow(pf, -2.0 / 3) * _k0, _k1, _n);
+            sampleACG(d, pow(pf, -2.0) * _k0, _k1, _n);
+            break;
+
+        default:
+            CLOG(FATAL, "LOGGER_SYS") << __FUNCTION__
+                                      << ": INEXISTENT MODE";
+            break;
+    }
 
     for (int i = 0; i < _n; i++)
     {
@@ -314,7 +506,7 @@ void Particle::perturb(const double pf)
         _r.row(i) = quat.transpose();
     }
 
-    symmetrise();
+    if (_mode == MODE_3D) symmetrise();
 
     reCentre();
 }
@@ -327,18 +519,25 @@ void Particle::resample(const double alpha)
 void Particle::resample(const int n,
                         const double alpha)
 {
-    // record the current most likely coordinate (highest weight)
+#ifdef VERBOSE_LEVEL_4
+    CLOG(INFO, "LOGGER_SYS") << "Recording the Current Most Likely Coordinate";
+#endif
 
     uvec rank = iSort();
 
-    quaternion(_topR, rank[0]);
-    t(_topT, rank[0]);
+    c(_topC, rank(0));
+    quaternion(_topR, rank(0));
+    t(_topT, rank(0));
 
-    // perform resampling
+#ifdef VERBOSE_LEVEL_4
+    CLOG(INFO, "LOGGER_SYS") << "Performing Resampling";
+#endif
 
     vec cdf = cumsum(_w);
 
-    // CLOG(INFO, "LOGGER_SYS") << "Recording New Number of Sampling Points";
+#ifdef VERBOSE_LEVEL_4
+    CLOG(INFO, "LOGGER_SYS") << "Recording New Number of Sampling Points";
+#endif
 
     _n = n;
     _w.resize(n);
@@ -349,16 +548,49 @@ void Particle::resample(const int n,
     // number of local sampling points
     int nL = n - nG;
 
-    // CLOG(INFO, "LOGGER_SYS") << "Allocating Temporary Storage";
+#ifdef VERBOSE_LEVEL_4
+    CLOG(INFO, "LOGGER_SYS") << "Allocating Temporary Storage";
+#endif
 
+    uvec c(n);
     mat4 r(n, 4);
     mat2 t(n, 2);
     
-    // CLOG(INFO, "LOGGER_SYS") << "Generate Global Sampling Points";
-
-    sampleACG(r, 1, 1, nG);
+#ifdef VERBOSE_LEVEL_4
+    CLOG(INFO, "LOGGER_SYS") << "Generating Global Sampling Points";
+#endif
 
     gsl_rng* engine = get_random_engine();
+
+#ifdef VERBOSE_LEVEL_4
+    CLOG(INFO, "LOGGER_SYS") << "Generating Global Sampling Points for Class";
+#endif
+
+    for (int i = 0; i < nG; i++)
+        c(i) = gsl_rng_uniform_int(engine, _m);
+
+#ifdef VERBOSE_LEVEL_4
+    CLOG(INFO, "LOGGER_SYS") << "Generating Global Sampling Points for Rotation";
+#endif
+
+    switch (_mode)
+    {
+        case MODE_2D:
+            sampleVMS(r, vec4(1, 0, 0, 0), 0, nG);
+            break;
+
+        case MODE_3D:
+            sampleACG(r, 1, 1, nG);
+            break;
+
+        default:
+            CLOG(FATAL, "LOGGER_SYS") << __FUNCTION__
+                                      << ": INEXISTENT MODE";
+    }
+
+#ifdef VERBOSE_LEVEL_4
+    CLOG(INFO, "LOGGER_SYS") << "Generating Global Sampling Points for Translation";
+#endif
     
     for (int i = 0; i < nG; i++)
     {
@@ -369,11 +601,18 @@ void Particle::resample(const int n,
                                    &t(i, 0),
                                    &t(i, 1));
                 
-        _w(i) = 1.0 / n;
     }
 
-    // CLOG(INFO, "LOGGER_SYS") << "Generate Local Sampling Points";
-    // CLOG(INFO, "LOGGER_SYS") << "nL = " << nL << ", nG = " << nG;
+#ifdef VERBOSE_LEVEL_4
+    CLOG(INFO, "LOGGER_SYS") << "Generating Weights for Global Sampling Points";
+#endif
+
+    for (int i = 0; i < nG; i++)
+        _w(i) = 1.0 / n;
+
+#ifdef VERBOSE_LEVEL_4
+    CLOG(INFO, "LOGGER_SYS") << "Generating Local Sampling Points";
+#endif
 
     double u0 = gsl_ran_flat(engine, 0, 1.0 / nL);  
 
@@ -385,23 +624,33 @@ void Particle::resample(const int n,
         while (uj > cdf[i])
             i++;
         
+        c(nG + j) = _c(i);
+
         r.row(nG + j) = _r.row(i);
+
         t.row(nG + j) = _t.row(i);
 
         _w(nG + j) = 1.0 / n;
     }
 
-    // CLOG(INFO, "LOGGER_SYS") << "Recording Results";
+#ifdef VERBOSE_LEVEL_4
+    CLOG(INFO, "LOGGER_SYS") << "Recording Results";
+#endif
 
-    _t.resize(n, 2);
-    _t = t;
+    _c.resize(n);
+    _c = c;
 
     _r.resize(n, 4);
     _r = r;
+
+    _t.resize(n, 2);
+    _t = t;
+
+#ifdef VERBOSE_LEVEL_4
+    CLOG(INFO, "LOGGER_SYS") << "Symmetrizing";
+#endif
     
-    // CLOG(INFO, "LOGGER_SYS") << "Symmetrize";
-    
-    symmetrise();
+    if (_mode == MODE_3D) symmetrise();
 }
 
 void Particle::downSample(const int n,
@@ -424,7 +673,8 @@ double Particle::neff() const
 void Particle::sort(const int n)
 {
     if (n > _n)
-        CLOG(FATAL, "LOGGER_SYS") << "Can not Select Top K from N when K > N";
+        CLOG(FATAL, "LOGGER_SYS") << __FUNCTION__
+                                  << ": CANNOT SELECT TOP K FROM N WHEN K > N";
 
     uvec order = iSort();
 
@@ -472,11 +722,24 @@ double Particle::diffTopT()
     return diff;
 }
 
+void Particle::rank1st(int& cls) const
+{
+    cls = _topC;
+}
+
 void Particle::rank1st(vec4& quat) const
 {
     quat = _topR;
 }
 
+void Particle::rank1st(mat22& rot) const
+{
+    vec4 quat;
+    rank1st(quat);
+
+    rotate2D(rot, vec2(quat(0), quat(1)));
+}
+
 void Particle::rank1st(mat33& rot) const
 {
     vec4 quat;
@@ -490,31 +753,44 @@ void Particle::rank1st(vec2& tran) const
     tran = _topT;
 }
 
-void Particle::rank1st(vec4& quat,
+void Particle::rank1st(int& cls,
+                       vec4& quat,
                        vec2& tran) const
 {
+    cls = _topC;
     quat = _topR;
     tran = _topT;
 }
 
-void Particle::rank1st(mat33& rot,
+void Particle::rank1st(int& cls,
+                       mat22& rot,
                        vec2& tran) const
 {
     vec4 quat;
-    rank1st(quat, tran);
+    rank1st(cls, quat, tran);
 
-    rotate3D(rot, quat);
+    rotate2D(rot, vec2(quat(0), quat(1)));
 }
 
-
-void Particle::rand(mat33& rot) const
+void Particle::rank1st(int& cls,
+                       mat33& rot,
+                       vec2& tran) const
 {
     vec4 quat;
-    rand(quat);
+    rank1st(cls, quat, tran);
 
     rotate3D(rot, quat);
 }
 
+void Particle::rand(int& cls) const
+{
+    gsl_rng* engine = get_random_engine();
+
+    size_t u = gsl_rng_uniform_int(engine, _n);
+
+    c(cls, u);
+}
+
 void Particle::rand(vec4& quat) const
 {
     gsl_rng* engine = get_random_engine();
@@ -524,6 +800,14 @@ void Particle::rand(vec4& quat) const
     quaternion(quat, u);
 }
 
+void Particle::rand(mat33& rot) const
+{
+    vec4 quat;
+    rand(quat);
+
+    rotate3D(rot, quat);
+}
+
 void Particle::rand(vec2& tran) const
 {
     gsl_rng* engine = get_random_engine();
@@ -533,22 +817,35 @@ void Particle::rand(vec2& tran) const
     t(tran, u);
 }
 
-void Particle::rand(vec4& quat,
+void Particle::rand(int& cls,
+                    vec4& quat,
                     vec2& tran) const
 {
     gsl_rng* engine = get_random_engine();
 
     size_t u = gsl_rng_uniform_int(engine, _n);
 
+    c(cls, u);
     quaternion(quat, u);
     t(tran, u);
 }
 
-void Particle::rand(mat33& rot,
+void Particle::rand(int& cls,
+                    mat22& rot,
                     vec2& tran) const
 {
     vec4 quat;
-    rand(quat, tran);
+    rand(cls, quat, tran);
+
+    rotate2D(rot, vec2(quat(0), quat(1)));
+}
+
+void Particle::rand(int& cls,
+                    mat33& rot,
+                    vec2& tran) const
+{
+    vec4 quat;
+    rand(cls, quat, tran);
 
     rotate3D(rot, quat);
 }
@@ -581,9 +878,11 @@ void Particle::shuffle()
 
 void Particle::copy(Particle& that) const
 {
+    that.setMode(_mode);
     that.setN(_n);
     that.setTransS(_transS);
     that.setTransQ(_transQ);
+    that.setC(_c);
     that.setR(_r);
     that.setT(_t);
     that.setW(_w);
@@ -636,13 +935,21 @@ void Particle::reCentre()
 
 void Particle::clear() {}
 
-void display(const Particle& particle)
+void display(const Particle& par)
 {
-    Coordinate5D coord;
-    for (int i = 0; i < particle.n(); i++)
+    int c;
+    vec4 q;
+    vec2 t;
+    for (int i = 0; i < par.n(); i++)
     {
-        particle.coord(coord, i);
-        display(coord);
+        par.c(c, i);
+        par.quaternion(q, i);
+        par.t(t, i);
+        printf("%03d %15.9lf %15.9lf %15.9lf %15.9lf %15.9lf %15.9lf %15.9lf\n",
+               c,
+               q(0), q(1), q(2), q(3),
+               t(0), t(1),
+               par.w(i));
     }
 }
 
@@ -651,14 +958,17 @@ void save(const char filename[],
 {
     FILE* file = fopen(filename, "w");
 
+    int c;
     vec4 q;
     vec2 t;
     for (int i = 0; i < par.n(); i++)
     {
+        par.c(c, i);
         par.quaternion(q, i);
         par.t(t, i);
         fprintf(file,
-                "%15.9lf %15.9lf %15.9lf %15.9lf %15.9lf %15.9lf %15.9lf\n",
+                "%03d %15.9lf %15.9lf %15.9lf %15.9lf %15.9lf %15.9lf %15.9lf\n",
+                c,
                 q(0), q(1), q(2), q(3),
                 t(0), t(1),
                 par.w(i));
@@ -672,6 +982,7 @@ void load(Particle& par,
 {
     FILE* file = fopen(filename, "r");
 
+    int c;
     vec4 q;
     vec2 t;
     double w;
@@ -681,18 +992,20 @@ void load(Particle& par,
     int nLine = 0;
     while (fgets(buf, FILE_LINE_LENGTH, file)) nLine++;
 
-    par.reset(nLine);
+    par.reset(1, nLine);
 
     rewind(file);
 
     for (int i = 0; i < nLine; i++) 
     {
         fscanf(file,
-               "%lf %lf %lf %lf %lf %lf %lf",
+               "%d %lf %lf %lf %lf %lf %lf %lf",
+               &c,
                &q(0), &q(1), &q(2), &q(3),
                &t(0), &t(1),
                &w);
 
+        par.setC(c, i);
         par.setQuaternion(q, i);
         par.setT(t, i);
         par.setW(w, i);
diff --git a/src/Postprocess.cpp b/src/Postprocess.cpp
index e7a30fc..c94842b 100644
--- a/src/Postprocess.cpp
+++ b/src/Postprocess.cpp
@@ -31,6 +31,9 @@ Postprocess::Postprocess(const char mapAFilename[],
     imfB.readVolume(_mapB);
     imfM.readVolume(_mask);
 
+    // REMOVE_NEG(_mapA);
+    // REMOVE_NEG(_mapB);
+
     _size = _mapA.nColRL();
 
     if ((_size != _mapA.nRowRL()) ||
@@ -70,17 +73,56 @@ void Postprocess::run()
     fft.fwMT(_mapAMasked);
     fft.fwMT(_mapBMasked);
 
-    CLOG(INFO, "LOGGER_SYS") << "Determining FSC";
+    CLOG(INFO, "LOGGER_SYS") << "Determining FSCUnmask & FSCMask";
+
+    _FSCUnmask.resize(maxR());
+
+    _FSCMask.resize(maxR());
+
+    FSC(_FSCUnmask, _mapA, _mapB);
+
+    FSC(_FSCMask, _mapAMasked, _mapBMasked);
+
+    int randomPhaseThres = resP(_FSCUnmask, 0.8, 1, 1, false);
+
+    CLOG(INFO, "LOGGER_SYS") << "Performing Random Phase From "
+                             << 1.0 / resP2A(randomPhaseThres,
+                                             _size,
+                                             _pixelSize);
+
+    randomPhaseAB(randomPhaseThres);
+
+    CLOG(INFO, "LOGGER_SYS") << "Determing FSCRFMask";
+
+    fft.bwMT(_mapARFMask);
+    fft.bwMT(_mapBRFMask);
+
+    maskABRF();
+
+    fft.fwMT(_mapARFMask);
+    fft.fwMT(_mapBRFMask);
+
+    _FSCRFMask.resize(maxR());
+
+    FSC(_FSCRFMask, _mapARFMask, _mapBRFMask);
+
+    CLOG(INFO, "LOGGER_SYS") << "Calculating True FSC";
 
     _FSC.resize(maxR());
 
-    FSC(_FSC, _mapAMasked, _mapBMasked);
+    for (int i = 0; i < maxR(); i++)
+    {
+        if (i < randomPhaseThres + 2)
+            _FSC(i) = _FSCMask(i);
+        else
+            _FSC(i) = (_FSCMask(i) - _FSCRFMask(i)) / (1 - _FSCRFMask(i));
+    }
 
     CLOG(INFO, "LOGGER_SYS") << "Saving FSC";
 
     saveFSC();
 
-    _res = resP(_FSC, 0.143);
+    _res = resP(_FSC, 0.143, 1, 1, true);
 
     CLOG(INFO, "LOGGER_SYS") << "Resolution: "
                              << 1.0 / resP2A(_res,
@@ -126,7 +168,7 @@ void Postprocess::run()
 
     softMask(_mapI, _mapI, _mask, 0);
 
-    REMOVE_NEG(_mapI);
+    //REMOVE_NEG(_mapI);
 
     imf.readMetaData(_mapI);
     imf.writeVolume("Reference_Sharp.mrc", _mapI, _pixelSize);
@@ -138,6 +180,21 @@ void Postprocess::maskAB()
     softMask(_mapBMasked, _mapB, _mask, 0);
 }
 
+void Postprocess::maskABRF()
+{
+    softMask(_mapARFMask, _mapARFMask, _mask, 0);
+    softMask(_mapBRFMask, _mapBRFMask, _mask, 0);
+}
+
+void Postprocess::randomPhaseAB(const int randomPhaseThres)
+{
+    _mapARFMask.alloc(_size, _size, _size, FT_SPACE);
+    _mapBRFMask.alloc(_size, _size, _size, FT_SPACE);
+
+    randomPhase(_mapARFMask, _mapA, randomPhaseThres);
+    randomPhase(_mapBRFMask, _mapB, randomPhaseThres);
+}
+
 void Postprocess::mergeAB()
 {
     _mapI.alloc(_size, _size, _size, FT_SPACE);
diff --git a/src/Projector.cpp b/src/Projector.cpp
index be87ca9..b5218ca 100644
--- a/src/Projector.cpp
+++ b/src/Projector.cpp
@@ -12,6 +12,8 @@
 
 Projector::Projector()
 {
+    _mode = MODE_3D;
+
     _maxRadius = -1;
 
     _interp = LINEAR_INTERP;
@@ -19,36 +21,37 @@ Projector::Projector()
     _pf = 2;
 }
 
-/***
-Projector::Projector(BOOST_RV_REF(Projector) that)
-{
-    swap(that);
-}
-***/
-
 Projector::~Projector() {}
 
 void Projector::swap(Projector& that)
 {
+    std::swap(_mode, that._mode);
     std::swap(_maxRadius, that._maxRadius);
     std::swap(_interp, that._interp);
     std::swap(_pf, that._pf);
     
-    _projectee.swap(that._projectee);
+    _projectee2D.swap(that._projectee2D);
+    _projectee3D.swap(that._projectee3D);
+}
+
+bool Projector::isEmpty2D() const
+{
+    return _projectee2D.isEmptyFT();
 }
 
-/***
-Projector& Projector::operator=(BOOST_RV_REF(Projector) that)
+bool Projector::isEmpty3D() const
 {
-    if (this != &other) swap(other);
+    return _projectee3D.isEmptyFT();
+}
 
-    return *this;
+int Projector::mode() const
+{
+    return _mode;
 }
-***/
 
-bool Projector::isEmpty() const
+void Projector::setMode(const int mode)
 {
-    return _projectee.isEmptyFT();
+    _mode = mode;
 }
 
 int Projector::maxRadius() const
@@ -81,24 +84,73 @@ void Projector::setPf(const int pf)
     _pf = pf;
 }
 
-const Volume& Projector::projectee() const
+const Image& Projector::projectee2D() const
+{
+    return _projectee2D;
+}
+
+const Volume& Projector::projectee3D() const
 {
-    return _projectee;
+    return _projectee3D;
+}
+
+void Projector::setProjectee(Image src)
+{
+    FFT fft;
+    fft.bwMT(src);
+
+    IMG_PAD_RL(_projectee2D, src, _pf);
+
+    if (_projectee2D.isEmptyRL()) REPORT_ERROR("REAL SPACE EMPTY");
+
+    _maxRadius = floor(MIN(_projectee2D.nColRL(),
+                           _projectee2D.nRowRL()) / _pf / 2 - 1);
+
+#ifdef VERBOSE_LEVEL_3
+    CLOG(INFO, "LOGGER_SYS") << "Performing Grid Correction";
+#endif
+
+    gridCorrection();
 }
 
 void Projector::setProjectee(Volume src)
 {
-    _projectee.swap(src);
+    FFT fft;
+    fft.bwMT(src);
+
+    VOL_PAD_RL(_projectee3D, src, _pf);
+
+    if (_projectee3D.isEmptyRL()) REPORT_ERROR("RL SPACE EMPTY");
+
+    _maxRadius = floor(MIN_3(_projectee3D.nColRL(),
+                             _projectee3D.nRowRL(),
+                             _projectee3D.nSlcRL()) / _pf / 2 - 1);
 
-    _maxRadius = floor(MIN_3(_projectee.nColRL(),
-                             _projectee.nRowRL(),
-                             _projectee.nSlcRL()) / _pf / 2 - 1);
+#ifdef VERBOSE_LEVEL_3
+    CLOG(INFO, "LOGGER_SYS") << "Performing Grid Correction";
+#endif
 
-    // perform grid correction
     gridCorrection();
 }
 
 void Projector::project(Image& dst,
+                        const mat22& mat) const
+{
+    IMAGE_FOR_PIXEL_R_FT(_maxRadius)
+        if (QUAD(i, j) < gsl_pow_2(_maxRadius))
+        {
+            vec2 newCor((double)(i * _pf), (double)(j * _pf));
+            vec2 oldCor = mat * newCor;
+
+            dst.setFT(_projectee2D.getByInterpolationFT(oldCor(0),
+                                                        oldCor(1),
+                                                        _interp),
+                      i,
+                      j);
+        }
+}
+
+void Projector::project(Image& dst,
                         const mat33& mat) const
 {
     IMAGE_FOR_PIXEL_R_FT(_maxRadius)
@@ -107,16 +159,34 @@ void Projector::project(Image& dst,
             vec3 newCor((double)(i * _pf), (double)(j * _pf), 0);
             vec3 oldCor = mat * newCor;
 
-            dst.setFT(_projectee.getByInterpolationFT(oldCor(0),
-                                                      oldCor(1),
-                                                      oldCor(2),
-                                                      _interp),
+            dst.setFT(_projectee3D.getByInterpolationFT(oldCor(0),
+                                                        oldCor(1),
+                                                        oldCor(2),
+                                                        _interp),
                       i,
                       j);
         }
 }
 
 void Projector::project(Image& dst,
+                        const mat22& mat,
+                        const int* iCol,
+                        const int* iRow,
+                        const int* iPxl,
+                        const int nPxl) const
+{
+    for (int i = 0; i < nPxl; i++)
+    {
+        vec2 newCor((double)(iCol[i] * _pf), (double)(iRow[i] * _pf));
+        vec2 oldCor = mat * newCor;
+
+        dst[iPxl[i]] = _projectee2D.getByInterpolationFT(oldCor(0),
+                                                         oldCor(1),
+                                                         _interp);
+    }
+}
+
+void Projector::project(Image& dst,
                         const mat33& mat,
                         const int* iCol,
                         const int* iRow,
@@ -128,10 +198,27 @@ void Projector::project(Image& dst,
         vec3 newCor((double)(iCol[i] * _pf), (double)(iRow[i] * _pf), 0);
         vec3 oldCor = mat * newCor;
 
-        dst[iPxl[i]] = _projectee.getByInterpolationFT(oldCor(0),
-                                                       oldCor(1),
-                                                       oldCor(2),
-                                                       _interp);
+        dst[iPxl[i]] = _projectee3D.getByInterpolationFT(oldCor(0),
+                                                         oldCor(1),
+                                                         oldCor(2),
+                                                         _interp);
+    }
+}
+
+void Projector::project(Complex* dst,
+                        const mat22& mat,
+                        const int* iCol,
+                        const int* iRow,
+                        const int nPxl) const
+{
+    for (int i = 0; i < nPxl; i++)
+    {
+        vec2 newCor((double)(iCol[i] * _pf), (double)(iRow[i] * _pf));
+        vec2 oldCor = mat * newCor;
+
+        dst[i] = _projectee2D.getByInterpolationFT(oldCor(0),
+                                                   oldCor(1),
+                                                   _interp);
     }
 }
 
@@ -146,14 +233,32 @@ void Projector::project(Complex* dst,
         vec3 newCor((double)(iCol[i] * _pf), (double)(iRow[i] * _pf), 0);
         vec3 oldCor = mat * newCor;
 
-        dst[i] = _projectee.getByInterpolationFT(oldCor(0),
-                                                 oldCor(1),
-                                                 oldCor(2),
-                                                 _interp);
+        dst[i] = _projectee3D.getByInterpolationFT(oldCor(0),
+                                                   oldCor(1),
+                                                   oldCor(2),
+                                                   _interp);
     }
 }
 
 void Projector::projectMT(Image& dst,
+                          const mat22& mat) const
+{
+    #pragma omp parallel for schedule(dynamic)
+    IMAGE_FOR_PIXEL_R_FT(_maxRadius)
+        if (QUAD(i, j) < gsl_pow_2(_maxRadius))
+        {
+            vec2 newCor((double)(i * _pf), (double)(j * _pf));
+            vec2 oldCor = mat * newCor;
+
+            dst.setFT(_projectee2D.getByInterpolationFT(oldCor(0),
+                                                        oldCor(1),
+                                                        _interp),
+                      i,
+                      j);
+        }
+}
+
+void Projector::projectMT(Image& dst,
                           const mat33& mat) const
 {
     #pragma omp parallel for schedule(dynamic)
@@ -163,17 +268,17 @@ void Projector::projectMT(Image& dst,
             vec3 newCor((double)(i * _pf), (double)(j * _pf), 0);
             vec3 oldCor = mat * newCor;
 
-            dst.setFT(_projectee.getByInterpolationFT(oldCor(0),
-                                                      oldCor(1),
-                                                      oldCor(2),
-                                                      _interp),
+            dst.setFT(_projectee3D.getByInterpolationFT(oldCor(0),
+                                                        oldCor(1),
+                                                        oldCor(2),
+                                                        _interp),
                       i,
                       j);
         }
 }
 
 void Projector::projectMT(Image& dst,
-                          const mat33& mat,
+                          const mat22& mat,
                           const int* iCol,
                           const int* iRow,
                           const int* iPxl,
@@ -182,20 +287,20 @@ void Projector::projectMT(Image& dst,
     #pragma omp parallel for
     for (int i = 0; i < nPxl; i++)
     {
-        vec3 newCor((double)(iCol[i] * _pf), (double)(iRow[i] * _pf), 0);
-        vec3 oldCor = mat * newCor;
+        vec2 newCor((double)(iCol[i] * _pf), (double)(iRow[i] * _pf));
+        vec2 oldCor = mat * newCor;
 
-        dst[iPxl[i]] = _projectee.getByInterpolationFT(oldCor(0),
-                                                       oldCor(1),
-                                                       oldCor(2),
-                                                       _interp);
+        dst[iPxl[i]] = _projectee2D.getByInterpolationFT(oldCor(0),
+                                                         oldCor(1),
+                                                         _interp);
     }
 }
 
-void Projector::projectMT(Complex* dst,
+void Projector::projectMT(Image& dst,
                           const mat33& mat,
                           const int* iCol,
                           const int* iRow,
+                          const int* iPxl,
                           const int nPxl) const
 {
     #pragma omp parallel for
@@ -204,117 +309,56 @@ void Projector::projectMT(Complex* dst,
         vec3 newCor((double)(iCol[i] * _pf), (double)(iRow[i] * _pf), 0);
         vec3 oldCor = mat * newCor;
 
-        dst[i] = _projectee.getByInterpolationFT(oldCor(0),
-                                                 oldCor(1),
-                                                 oldCor(2),
-                                                 _interp);
+        dst[iPxl[i]] = _projectee3D.getByInterpolationFT(oldCor(0),
+                                                         oldCor(1),
+                                                         oldCor(2),
+                                                         _interp);
     }
 }
 
-void Projector::project(Image& dst,
-                        const double phi,
-                        const double theta,
-                        const double psi) const
-{
-    mat33 mat;
-    rotate3D(mat, phi, theta, psi);
-
-    project(dst, mat);
-}
-
-void Projector::projectMT(Image& dst,
-                          const double phi,
-                          const double theta,
-                          const double psi) const
-{
-    mat33 mat;
-    rotate3D(mat, phi, theta, psi);
-
-    projectMT(dst, mat);
-}
-
-void Projector::project(Image& dst,
-                        const double phi,
-                        const double theta,
-                        const double psi,
-                        const double x,
-                        const double y) const
-{
-    project(dst, phi, theta, psi);
-
-    translate(dst, dst, _maxRadius, x, y);
-}
-
-void Projector::project(Image& dst,
-                        const double phi,
-                        const double theta,
-                        const double psi,
-                        const double x,
-                        const double y,
-                        const int* iCol,
-                        const int* iRow,
-                        const int* iPxl,
-                        const int nPxl) const
-{
-    mat33 mat;
-    rotate3D(mat, phi, theta, psi);
-
-    project(dst, mat, iCol, iRow, iPxl, nPxl);
-
-    translate(dst, dst, x, y, iCol, iRow, iPxl, nPxl);
-}
-
-void Projector::projectMT(Image& dst,
-                          const double phi,
-                          const double theta,
-                          const double psi,
-                          const double x,
-                          const double y) const
+void Projector::projectMT(Complex* dst,
+                          const mat22& mat,
+                          const int* iCol,
+                          const int* iRow,
+                          const int nPxl) const
 {
-    projectMT(dst, phi, theta, psi);
+    #pragma omp parallel for
+    for (int i = 0; i < nPxl; i++)
+    {
+        vec2 newCor((double)(iCol[i] * _pf), (double)(iRow[i] * _pf));
+        vec2 oldCor = mat * newCor;
 
-    translateMT(dst, dst, _maxRadius, x, y);
+        dst[i] = _projectee2D.getByInterpolationFT(oldCor(0),
+                                                   oldCor(1),
+                                                   _interp);
+    }
 }
 
-void Projector::projectMT(Image& dst,
-                          const double phi,
-                          const double theta,
-                          const double psi,
-                          const double x,
-                          const double y,
+void Projector::projectMT(Complex* dst,
+                          const mat33& mat,
                           const int* iCol,
                           const int* iRow,
-                          const int* iPxl,
                           const int nPxl) const
 {
-    mat33 mat;
-    rotate3D(mat, phi, theta, psi);
-
-    projectMT(dst, mat, iCol, iRow, iPxl, nPxl);
+    #pragma omp parallel for
+    for (int i = 0; i < nPxl; i++)
+    {
+        vec3 newCor((double)(iCol[i] * _pf), (double)(iRow[i] * _pf), 0);
+        vec3 oldCor = mat * newCor;
 
-    translateMT(dst, dst, x, y, iCol, iRow, iPxl, nPxl);
+        dst[i] = _projectee3D.getByInterpolationFT(oldCor(0),
+                                                   oldCor(1),
+                                                   oldCor(2),
+                                                   _interp);
+    }
 }
 
 void Projector::project(Image& dst,
-                        const Coordinate5D& coordinate5D) const
-{
-    project(dst,
-            coordinate5D.phi,
-            coordinate5D.theta,
-            coordinate5D.psi,
-            coordinate5D.x,
-            coordinate5D.y);
-}
-
-void Projector::projectMT(Image& dst,
-                          const Coordinate5D& coordinate5D) const
+                        const mat22& rot,
+                        const vec2& t) const
 {
-    projectMT(dst,
-              coordinate5D.phi,
-              coordinate5D.theta,
-              coordinate5D.psi,
-              coordinate5D.x,
-              coordinate5D.y);
+    project(dst, rot);
+    translate(dst, dst, _maxRadius, t(0), t(1));
 }
 
 void Projector::project(Image& dst,
@@ -326,6 +370,19 @@ void Projector::project(Image& dst,
 }
 
 void Projector::project(Image& dst,
+                        const mat22& rot,
+                        const vec2& t,
+                        const int* iCol,
+                        const int* iRow,
+                        const int* iPxl,
+                        const int nPxl) const
+{
+    project(dst, rot, iCol, iRow, iPxl, nPxl);
+
+    translate(dst, dst, t(0), t(1), iCol, iRow, iPxl, nPxl);
+}
+
+void Projector::project(Image& dst,
                         const mat33& rot,
                         const vec2& t,
                         const int* iCol,
@@ -339,6 +396,20 @@ void Projector::project(Image& dst,
 }
 
 void Projector::project(Complex* dst,
+                        const mat22& rot,
+                        const vec2& t,
+                        const int nCol,
+                        const int nRow,
+                        const int* iCol,
+                        const int* iRow,
+                        const int nPxl) const
+{
+    project(dst, rot, iCol, iRow, nPxl);
+
+    translate(dst, dst, t(0), t(1), nCol, nRow, iCol, iRow, nPxl);
+}
+
+void Projector::project(Complex* dst,
                         const mat33& rot,
                         const vec2& t,
                         const int nCol,
@@ -353,6 +424,15 @@ void Projector::project(Complex* dst,
 }
 
 void Projector::projectMT(Image& dst,
+                          const mat22& rot,
+                          const vec2& t) const
+{
+    projectMT(dst, rot);
+
+    translateMT(dst, dst, _maxRadius, t(0), t(1));
+}
+
+void Projector::projectMT(Image& dst,
                           const mat33& rot,
                           const vec2& t) const
 {
@@ -362,6 +442,19 @@ void Projector::projectMT(Image& dst,
 }
 
 void Projector::projectMT(Image& dst,
+                          const mat22& rot,
+                          const vec2& t,
+                          const int* iCol,
+                          const int* iRow,
+                          const int* iPxl,
+                          const int nPxl) const
+{
+    projectMT(dst, rot, iCol, iRow, iPxl, nPxl);
+
+    translateMT(dst, dst, t(0), t(1), iCol, iRow, iPxl, nPxl);
+}
+
+void Projector::projectMT(Image& dst,
                           const mat33& rot,
                           const vec2& t,
                           const int* iCol,
@@ -375,6 +468,20 @@ void Projector::projectMT(Image& dst,
 }
 
 void Projector::projectMT(Complex* dst,
+                          const mat22& rot,
+                          const vec2& t,
+                          const int nCol,
+                          const int nRow,
+                          const int* iCol,
+                          const int* iRow,
+                          const int nPxl) const
+{
+    projectMT(dst, rot, iCol, iRow, nPxl);
+
+    translateMT(dst, dst, t(0), t(1), nCol, nRow, iCol, iRow, nPxl);
+}
+
+void Projector::projectMT(Complex* dst,
                           const mat33& rot,
                           const vec2& t,
                           const int nCol,
@@ -395,17 +502,60 @@ void Projector::gridCorrection()
     {
         FFT fft;
 
-        fft.bwMT(_projectee);
-
-        #pragma omp parallel for schedule(dynamic)
-        VOLUME_FOR_EACH_PIXEL_RL(_projectee)
-            _projectee.setRL(_projectee.getRL(i, j, k)
-                           / TIK_RL(NORM_3(i, j, k)
-                                  / (_projectee.nColRL() * _pf)),
-                             i,
-                             j,
-                             k);
-
-        fft.fwMT(_projectee);
+        if (_mode == MODE_2D)
+        {
+#ifdef VERBOSE_LEVEL_3
+            CLOG(INFO, "LOGGER_SYS") << "Inverse Fourier Transform in Grid Correction";
+#endif
+
+#ifdef PROJECTOR_REMOVE_NEG
+            #pragma omp parallel for
+            REMOVE_NEG(_projectee2D);
+#endif
+
+            #pragma omp parallel for schedule(dynamic)
+            IMAGE_FOR_EACH_PIXEL_RL(_projectee2D)
+                _projectee2D.setRL(_projectee2D.getRL(i, j)
+                                 / TIK_RL(NORM(i, j)
+                                        / (_projectee2D.nColRL() * _pf)),
+                                   i,
+                                   j);
+
+#ifdef VERBOSE_LEVEL_3
+            CLOG(INFO, "LOGGER_SYS") << "Fourier Transform in Grid Correction";
+#endif
+
+            fft.fwMT(_projectee2D);
+            _projectee2D.clearRL();
+        }
+        else if (_mode == MODE_3D)
+        {
+#ifdef VERBOSE_LEVEL_3
+            CLOG(INFO, "LOGGER_SYS") << "Inverse Fourier Transform in Grid Correction";
+#endif
+
+#ifdef PROJECTOR_REMOVE_NEG
+            #pragma omp parallel for
+            REMOVE_NEG(_projectee3D);
+#endif
+
+            #pragma omp parallel for schedule(dynamic)
+            VOLUME_FOR_EACH_PIXEL_RL(_projectee3D)
+                _projectee3D.setRL(_projectee3D.getRL(i, j, k)
+                                 / TIK_RL(NORM_3(i, j, k)
+                                        / (_projectee3D.nColRL() * _pf)),
+                                   i,
+                                   j,
+                                   k);
+
+#ifdef VERBOSE_LEVEL_3
+            CLOG(INFO, "LOGGER_SYS") << "Fourier Transform in Grid Correction";
+#endif
+
+            fft.fwMT(_projectee3D);
+            _projectee3D.clearRL();
+        }
+        else
+            REPORT_ERROR("INEXISTENT_MODE");
     }
 }
diff --git a/src/Reconstructor.cpp b/src/Reconstructor.cpp
index e87854c..e86ee07 100644
--- a/src/Reconstructor.cpp
+++ b/src/Reconstructor.cpp
@@ -8,14 +8,13 @@
 
 #include "Reconstructor.h"
 
-#include <boost/bind.hpp>
-
 Reconstructor::Reconstructor()
 {
     defaultInit();
 }
 
-Reconstructor::Reconstructor(const int size,
+Reconstructor::Reconstructor(const int mode,
+                             const int size,
                              const int pf,
                              const Symmetry* sym,
                              const double a,
@@ -23,7 +22,7 @@ Reconstructor::Reconstructor(const int size,
 {
     defaultInit();
 
-    init(size, pf, sym, a, alpha);
+    init(mode, size, pf, sym, a, alpha);
 }
 
 Reconstructor::~Reconstructor()
@@ -32,12 +31,14 @@ Reconstructor::~Reconstructor()
     _fft.bwDestroyPlanMT();
 }
 
-void Reconstructor::init(const int size,
+void Reconstructor::init(const int mode,
+                         const int size,
                          const int pf,
                          const Symmetry* sym,
                          const double a,
                          const double alpha)
 {
+    _mode = mode;
     _size = size;
     _pf = pf;
     _sym = sym;
@@ -54,6 +55,9 @@ void Reconstructor::init(const int size,
     _alpha = alpha;
 
     // initialise the interpolation kernel
+    
+    ALOG(INFO, "LOGGER_RECO") << "Initialising Kernels";
+    BLOG(INFO, "LOGGER_RECO") << "Initialising Kernels";
 
     _kernelFT.init(boost::bind(MKB_FT_R2,
                                boost::placeholders::_1,
@@ -73,22 +77,51 @@ void Reconstructor::init(const int size,
 
     _maxRadius = (_size / 2 - a);
 
-    _F.alloc(PAD_SIZE, PAD_SIZE, PAD_SIZE, FT_SPACE);
-    _W.alloc(PAD_SIZE, PAD_SIZE, PAD_SIZE, FT_SPACE);
-    _C.alloc(PAD_SIZE, PAD_SIZE, PAD_SIZE, FT_SPACE);
-    _T.alloc(PAD_SIZE, PAD_SIZE, PAD_SIZE, FT_SPACE);
+    if (_mode == MODE_2D)
+    {
+        ALOG(INFO, "LOGGER_RECO") << "Allocating Spaces";
+        BLOG(INFO, "LOGGER_RECO") << "Allocating Spaces";
+
+        _F2D.alloc(PAD_SIZE, PAD_SIZE, FT_SPACE);
+        _W2D.alloc(PAD_SIZE, PAD_SIZE, FT_SPACE);
+        _C2D.alloc(PAD_SIZE, PAD_SIZE, FT_SPACE);
+        _T2D.alloc(PAD_SIZE, PAD_SIZE, FT_SPACE);
+
+        ALOG(INFO, "LOGGER_RECO") << "Creating Fourier Transform Plans";
+        BLOG(INFO, "LOGGER_RECO") << "Creating Fourier Transform Plans";
 
-    _fft.fwCreatePlanMT(PAD_SIZE, PAD_SIZE, PAD_SIZE);
-    _fft.bwCreatePlanMT(PAD_SIZE, PAD_SIZE, PAD_SIZE);
+        _fft.fwCreatePlanMT(PAD_SIZE, PAD_SIZE);
+        _fft.bwCreatePlanMT(PAD_SIZE, PAD_SIZE);
+    }
+    else if (_mode == MODE_3D)
+    {
+        ALOG(INFO, "LOGGER_RECO") << "Allocating Spaces";
+        BLOG(INFO, "LOGGER_RECO") << "Allocating Spaces";
+
+        _F3D.alloc(PAD_SIZE, PAD_SIZE, PAD_SIZE, FT_SPACE);
+        _W3D.alloc(PAD_SIZE, PAD_SIZE, PAD_SIZE, FT_SPACE);
+        _C3D.alloc(PAD_SIZE, PAD_SIZE, PAD_SIZE, FT_SPACE);
+        _T3D.alloc(PAD_SIZE, PAD_SIZE, PAD_SIZE, FT_SPACE);
+
+        ALOG(INFO, "LOGGER_RECO") << "Creating Fourier Transform Plans";
+        BLOG(INFO, "LOGGER_RECO") << "Creating Fourier Transform Plans";
+
+        _fft.fwCreatePlanMT(PAD_SIZE, PAD_SIZE, PAD_SIZE);
+        _fft.bwCreatePlanMT(PAD_SIZE, PAD_SIZE, PAD_SIZE);
+    }
+    else 
+        REPORT_ERROR("INEXISTENT MODE");
 
     reset();
 }
 
 void Reconstructor::reset()
 {
+    /***
     _rot.clear();
     _w.clear();
     _ctf.clear();
+    ***/
 
     _iCol = NULL;
     _iRow = NULL;
@@ -97,17 +130,58 @@ void Reconstructor::reset()
 
     _calMode = POST_CAL_MODE;
 
-    #pragma omp parallel for
-    SET_0_FT(_F);
+    _MAP = true;
 
-    #pragma omp parallel for
-    SET_1_FT(_W);
+    if (_mode == MODE_2D)
+    {
+        #pragma omp parallel for
+        SET_0_FT(_F2D);
 
-    #pragma omp parallel for
-    SET_0_FT(_C);
+        #pragma omp parallel for
+        SET_1_FT(_W2D);
 
-    #pragma omp parallel for
-    SET_0_FT(_T);
+        #pragma omp parallel for
+        SET_0_FT(_C2D);
+
+        #pragma omp parallel for
+        SET_0_FT(_T2D);
+    }
+    else if (_mode == MODE_3D)
+    {
+        #pragma omp parallel for
+        SET_0_FT(_F3D);
+
+        #pragma omp parallel for
+        SET_1_FT(_W3D);
+
+        #pragma omp parallel for
+        SET_0_FT(_C3D);
+
+        #pragma omp parallel for
+        SET_0_FT(_T3D);
+    }
+    else
+        REPORT_ERROR("INEXISTENT MODE");
+}
+
+int Reconstructor::mode() const
+{
+    return _mode;
+}
+
+void Reconstructor::setMode(const int mode)
+{
+    _mode = mode;
+}
+
+bool Reconstructor::MAP() const
+{
+    return _MAP;
+}
+
+void Reconstructor::setMAP(const bool MAP)
+{
+    _MAP = MAP;
 }
 
 void Reconstructor::setSymmetry(const Symmetry* sym)
@@ -172,29 +246,99 @@ void Reconstructor::setPreCal(const int nPxl,
 
 void Reconstructor::insert(const Image& src,
                            const Image& ctf,
-                           const mat33& rot,
+                           const mat22& rot,
                            const vec2& t,
-                           const double w,
-                           const vec* sig)
+                           const double w)
 {
+#ifdef RECONSTRUCTOR_ASSERT_CHECK
     IF_MASTER
-    {
-        CLOG(FATAL, "LOGGER_SYS") << "Inserting Images into Reconstructor in MASTER";
-    }
+        REPORT_ERROR("INSERTING IMAGES INTO RECONSTRUCTOR IN MASTER");
+
+    NT_MODE_2D REPORT_ERROR("WRONG MODE");
 
     if (_calMode != POST_CAL_MODE)
+        REPORT_ERROR("WRONG PRE(POST) CALCULATION MODE IN RECONSTRUCTOR");
+
+    if ((src.nColRL() != _size) ||
+        (src.nRowRL() != _size) ||
+        (ctf.nColRL() != _size) ||
+        (ctf.nRowRL() != _size))
+        REPORT_ERROR("INCORRECT SIZE OF INSERTING IMAGE");
+#endif
+
+    Image transSrc(_size, _size, FT_SPACE);
+    translateMT(transSrc, src, _maxRadius, -t(0), -t(1));
+
+    #pragma omp parallel for schedule(dynamic)
+    IMAGE_FOR_EACH_PIXEL_FT(transSrc)
     {
-        CLOG(FATAL, "LOGGER_SYS") << "Wrong Pre(Post) Calculation Mode in Reconstructor";
+        if (QUAD(i, j) < gsl_pow_2(_maxRadius))
+        {
+            vec2 newCor((double)(i * _pf), (double)(j * _pf));
+            vec2 oldCor = rot * newCor;
+
+#ifdef RECONSTRUCTOR_MKB_KERNEL
+            _F2D.addFT(transSrc.getFTHalf(i, j)
+                     * REAL(ctf.getFTHalf(i, j))
+                     * w, 
+                       oldCor(0), 
+                       oldCor(1), 
+                       _pf * _a, 
+                       _kernelFT);
+#endif
+
+#ifdef RECONSTRUCTOR_TRILINEAR_KERNEL
+            _F2D.addFT(transSrc.getFTHalf(i, j)
+                     * REAL(ctf.getFTHalf(i, j))
+                     * w, 
+                       oldCor(0), 
+                       oldCor(1));
+#endif
+
+#ifdef RECONSTRUCTOR_ADD_T_DURING_INSERT
+
+#ifdef RECONSTRUCTOR_MKB_KERNEL
+            _T2D.addFT(gsl_pow_2(REAL(ctf.getFTHalf(i, j)))
+                     * w, 
+                       oldCor(0), 
+                       oldCor(1), 
+                       _pf * _a,
+                       _kernelFT);
+#endif
+
+#ifdef RECONSTRUCTOR_TRILINEAR_KERNEL
+             _T2D.addFT(gsl_pow_2(REAL(ctf.getFTHalf(i, j)))
+                      * w, 
+                        oldCor(0), 
+                        oldCor(1));
+#endif
+
+#endif
+        }
     }
+}
+
+void Reconstructor::insert(const Image& src,
+                           const Image& ctf,
+                           const mat33& rot,
+                           const vec2& t,
+                           const double w)
+{
+#ifdef RECONSTRUCTOR_ASSERT_CHECK
+    IF_MASTER
+        REPORT_ERROR("INSERTING IMAGES INTO RECONSTRUCTOR IN MASTER");
+
+    NT_MODE_3D REPORT_ERROR("WRONG MODE");
+
+    if (_calMode != POST_CAL_MODE)
+        REPORT_ERROR("WRONG PRE(POST) CALCULATION MODE IN RECONSTRUCTOR");
 
     if ((src.nColRL() != _size) ||
         (src.nRowRL() != _size) ||
         (ctf.nColRL() != _size) ||
         (ctf.nRowRL() != _size))
-        CLOG(FATAL, "LOGGER_SYS") << "Incorrect Size of Inserting Image"
-                                  << ": _size = " << _size
-                                  << ", nCol = " << src.nColRL()
-                                  << ", nRow = " << src.nRowRL();
+        REPORT_ERROR("INCORRECT SIZE OF INSERTING IMAGE");
+#endif
 
     Image transSrc(_size, _size, FT_SPACE);
     translateMT(transSrc, src, _maxRadius, -t(0), -t(1));
@@ -208,10 +352,6 @@ void Reconstructor::insert(const Image& src,
 
     for (int k = 0; k < int(sr.size()); k++)
     {
-        _rot.push_back(sr[k]);
-        _w.push_back(w);
-        _ctf.push_back(&ctf);
-
         #pragma omp parallel for schedule(dynamic)
         IMAGE_FOR_EACH_PIXEL_FT(transSrc)
         {
@@ -221,54 +361,43 @@ void Reconstructor::insert(const Image& src,
                 vec3 oldCor = sr[k] * newCor;
 
 #ifdef RECONSTRUCTOR_MKB_KERNEL
-                if (sig == NULL)
-                    _F.addFT(transSrc.getFTHalf(i, j)
-                           * REAL(ctf.getFTHalf(i, j))
-                           * w, 
-                             oldCor(0), 
-                             oldCor(1), 
-                             oldCor(2), 
-                             _pf * _a, 
-                             _kernelFT);
-                else
-                    _F.addFT(transSrc.getFTHalf(i, j)
-                           * REAL(ctf.getFTHalf(i, j))
-                           / sig(AROUND(NORM(i, j)))
-                           * w,
-                             oldCor(0),
-                             oldCor(1),
-                             oldCor(2),
-                             _pf * _a,
-                             _kernelFT);
+                _F3D.addFT(transSrc.getFTHalf(i, j)
+                         * REAL(ctf.getFTHalf(i, j))
+                         * w, 
+                           oldCor(0), 
+                           oldCor(1), 
+                           oldCor(2), 
+                           _pf * _a, 
+                           _kernelFT);
 #endif
 
 #ifdef RECONSTRUCTOR_TRILINEAR_KERNEL
-                _F.addFT(transSrc.getFTHalf(i, j)
-                       * REAL(ctf.getFTHalf(i, j))
-                       * w, 
-                         oldCor(0), 
-                         oldCor(1), 
-                         oldCor(2));
+                _F3D.addFT(transSrc.getFTHalf(i, j)
+                         * REAL(ctf.getFTHalf(i, j))
+                         * w, 
+                           oldCor(0), 
+                           oldCor(1), 
+                           oldCor(2));
 #endif
 
 #ifdef RECONSTRUCTOR_ADD_T_DURING_INSERT
 
 #ifdef RECONSTRUCTOR_MKB_KERNEL
-                _T.addFT(gsl_pow_2(REAL(ctf.getFTHalf(i, j)))
-                       * w, 
-                         oldCor(0), 
-                         oldCor(1), 
-                         oldCor(2),
-                         _pf * _a,
-                         _kernelFT);
+                _T3D.addFT(gsl_pow_2(REAL(ctf.getFTHalf(i, j)))
+                         * w, 
+                           oldCor(0), 
+                           oldCor(1), 
+                           oldCor(2),
+                           _pf * _a,
+                           _kernelFT);
 #endif
 
 #ifdef RECONSTRUCTOR_TRILINEAR_KERNEL
-                _T.addFT(gsl_pow_2(REAL(ctf.getFTHalf(i, j)))
-                       * w, 
-                         oldCor(0), 
-                         oldCor(1), 
-                         oldCor(2));
+                _T3D.addFT(gsl_pow_2(REAL(ctf.getFTHalf(i, j)))
+                         * w, 
+                           oldCor(0), 
+                           oldCor(1), 
+                           oldCor(2));
 #endif
 
 #endif
@@ -279,20 +408,84 @@ void Reconstructor::insert(const Image& src,
 
 void Reconstructor::insertP(const Image& src,
                             const Image& ctf,
+                            const mat22& rot,
+                            const vec2& t,
+                            const double w)
+{
+#ifdef RECONSTRUCTOR_ASSERT_CHECK
+    IF_MASTER
+        REPORT_ERROR("INSERTING IMAGES INTO RECONSTRUCTOR IN MASTER");
+
+    NT_MODE_2D REPORT_ERROR("WRONG MODE");
+
+    if (_calMode != PRE_CAL_MODE)
+        REPORT_ERROR("WRONG PRE(POST) CALCULATION MODE IN RECONSTRUCTOR");
+#endif
+
+    Image transSrc(_size, _size, FT_SPACE);
+    translateMT(transSrc, src, -t(0), -t(1), _iCol, _iRow, _iPxl, _nPxl);
+
+        #pragma omp parallel for
+        for (int i = 0; i < _nPxl; i++)
+        {
+            vec2 newCor((double)(_iCol[i] * _pf), (double)(_iRow[i] * _pf));
+            vec2 oldCor = rot * newCor;
+
+#ifdef RECONSTRUCTOR_MKB_KERNEL
+            _F2D.addFT(transSrc[_iPxl[i]]
+                     * REAL(ctf.iGetFT(_iPxl[i]))
+                     * w,
+                       oldCor(0), 
+                       oldCor(1), 
+                       _pf * _a, 
+                       _kernelFT);
+#endif
+
+#ifdef RECONSTRUCTOR_TRILINEAR_KERNEL
+            _F2D.addFT(transSrc[_iPxl[i]]
+                     * REAL(ctf.iGetFT(_iPxl[i]))
+                     * w,
+                       oldCor(0), 
+                       oldCor(1));
+#endif
+
+#ifdef RECONSTRUCTOR_ADD_T_DURING_INSERT
+
+#ifdef RECONSTRUCTOR_MKB_KERNEL
+            _T2D.addFT(gsl_pow_2(REAL(ctf.iGetFT(_iPxl[i])))
+                     * w,
+                       oldCor(0), 
+                       oldCor(1), 
+                       _pf * _a,
+                       _kernelFT);
+#endif
+
+#ifdef RECONSTRUCTOR_TRILINEAR_KERNEL
+            _T2D.addFT(gsl_pow_2(REAL(ctf.iGetFT(_iPxl[i])))
+                     * w,
+                       oldCor(0), 
+                       oldCor(1));
+#endif
+
+#endif
+        }
+}
+
+void Reconstructor::insertP(const Image& src,
+                            const Image& ctf,
                             const mat33& rot,
                             const vec2& t,
-                            const double w,
-                            const vec* sig)
+                            const double w)
 {
+#ifdef RECONSTRUCTOR_ASSERT_CHECK
     IF_MASTER
-    {
-        CLOG(FATAL, "LOGGER_SYS") << "Inserting Images into Reconstructor in MASTER";
-    }
+        REPORT_ERROR("INSERTING IMAGES INTO RECONSTRUCTOR IN MASTER");
+
+    NT_MODE_3D REPORT_ERROR("WRONG MODE");
 
     if (_calMode != PRE_CAL_MODE)
-    {
-        CLOG(FATAL, "LOGGER_SYS") << "Wrong Pre(Post) Calculation Mode in Reconstructor";
-    }
+        REPORT_ERROR("WRONG PRE(POST) CALCULATION MODE IN RECONSTRUCTOR");
+#endif
 
     Image transSrc(_size, _size, FT_SPACE);
     translateMT(transSrc, src, -t(0), -t(1), _iCol, _iRow, _iPxl, _nPxl);
@@ -306,10 +499,6 @@ void Reconstructor::insertP(const Image& src,
 
     for (int k = 0; k < int(sr.size()); k++)
     {
-        _rot.push_back(sr[k]);
-        _w.push_back(w);
-        _ctf.push_back(&ctf);
-
         #pragma omp parallel for
         for (int i = 0; i < _nPxl; i++)
         {
@@ -317,43 +506,43 @@ void Reconstructor::insertP(const Image& src,
             vec3 oldCor = sr[k] * newCor;
 
 #ifdef RECONSTRUCTOR_MKB_KERNEL
-            _F.addFT(transSrc[_iPxl[i]]
-                   * REAL(ctf.iGetFT(_iPxl[i]))
-                   * w,
-                     oldCor(0), 
-                     oldCor(1), 
-                     oldCor(2), 
-                     _pf * _a, 
-                     _kernelFT);
+            _F3D.addFT(transSrc[_iPxl[i]]
+                     * REAL(ctf.iGetFT(_iPxl[i]))
+                     * w,
+                       oldCor(0), 
+                       oldCor(1), 
+                       oldCor(2), 
+                       _pf * _a, 
+                       _kernelFT);
 #endif
 
 #ifdef RECONSTRUCTOR_TRILINEAR_KERNEL
-            _F.addFT(transSrc[_iPxl[i]]
-                   * REAL(ctf.iGetFT(_iPxl[i]))
-                   * w,
-                     oldCor(0), 
-                     oldCor(1), 
-                     oldCor(2));
+            _F3D.addFT(transSrc[_iPxl[i]]
+                     * REAL(ctf.iGetFT(_iPxl[i]))
+                     * w,
+                       oldCor(0), 
+                       oldCor(1), 
+                       oldCor(2));
 #endif
 
 #ifdef RECONSTRUCTOR_ADD_T_DURING_INSERT
 
 #ifdef RECONSTRUCTOR_MKB_KERNEL
-            _T.addFT(gsl_pow_2(REAL(ctf.iGetFT(_iPxl[i])))
-                   * w,
-                     oldCor(0), 
-                     oldCor(1), 
-                     oldCor(2),
-                     _pf * _a,
-                     _kernelFT);
+            _T3D.addFT(gsl_pow_2(REAL(ctf.iGetFT(_iPxl[i])))
+                     * w,
+                       oldCor(0), 
+                       oldCor(1), 
+                       oldCor(2),
+                       _pf * _a,
+                       _kernelFT);
 #endif
 
 #ifdef RECONSTRUCTOR_TRILINEAR_KERNEL
-            _T.addFT(gsl_pow_2(REAL(ctf.iGetFT(_iPxl[i])))
-                   * w,
-                     oldCor(0), 
-                     oldCor(1), 
-                     oldCor(2));
+            _T3D.addFT(gsl_pow_2(REAL(ctf.iGetFT(_iPxl[i])))
+                     * w,
+                       oldCor(0), 
+                       oldCor(1), 
+                       oldCor(2));
 #endif
 
 #endif
@@ -361,95 +550,141 @@ void Reconstructor::insertP(const Image& src,
     }
 }
 
+void Reconstructor::reconstruct(Image& dst)
+{
+    Volume tmp;
+
+    reconstruct(tmp);
+
+    dst.alloc(PAD_SIZE, PAD_SIZE, RL_SPACE);
+
+    SLC_EXTRACT_RL(dst, tmp, 0);
+}
+
 void Reconstructor::reconstruct(Volume& dst)
 {
     IF_MASTER return;
 
+    IF_MODE_2D
+    {
+        ALOG(INFO, "LOGGER_RECO") << "Reconstructing Under 2D Mode";
+        BLOG(INFO, "LOGGER_RECO") << "Reconstructing Under 2D Mode";
+    }
+
+    IF_MODE_3D
+    {
+        ALOG(INFO, "LOGGER_RECO") << "Reconstructing Under 3D Mode";
+        BLOG(INFO, "LOGGER_RECO") << "Reconstructing Under 3D Mode";
+    }
+
     ALOG(INFO, "LOGGER_RECO") << "Allreducing T";
     BLOG(INFO, "LOGGER_RECO") << "Allreducing T";
 
     allReduceT();
 
+    // only in 3D mode, symmetry should be considered
+    IF_MODE_3D
+    {
 #ifdef RECONSTRUCTOR_SYMMETRIZE_DURING_RECONSTRUCT
-    ALOG(INFO, "LOGGER_RECO") << "Symmetrizing T";
-    BLOG(INFO, "LOGGER_RECO") << "Symmetrizing T";
+        ALOG(INFO, "LOGGER_RECO") << "Symmetrizing T";
+        BLOG(INFO, "LOGGER_RECO") << "Symmetrizing T";
 
-    symmetrizeT();
+        symmetrizeT();
 #endif
+    }
 
-    // Obviously, wiener_filter with FSC can be wrong when dealing with
-    // preferrable orienation problem
+    // only in 3D mode, the MAP method is appropriate
+    if (_MAP && (_mode == MODE_3D))
+    {
+        // Obviously, wiener_filter with FSC can be wrong when dealing with
+        // preferrable orienation problem
 #ifdef RECONSTRUCTOR_WIENER_FILTER_FSC
 
 #ifdef RECONSTRUCTOR_WIENER_FILTER_FSC_FREQ_AVG
-    vec avg = vec::Zero(_maxRadius * _pf + 1);
-    shellAverage(avg,
-                 _T,
-                 gsl_real,
-                 _maxRadius * _pf - 1);
-    // the last two elements have low fidelity
-    avg(_maxRadius * _pf - 1) = avg(_maxRadius * _pf - 2);
-    avg(_maxRadius * _pf) = avg(_maxRadius * _pf - 2);
-
-    ALOG(INFO, "LOGGER_SYS") << "End of Avg = "
-                             << avg(avg.size() - 5) << ", "
-                             << avg(avg.size() - 4) << ", "
-                             << avg(avg.size() - 3) << ", "
-                             << avg(avg.size() - 2) << ", "
-                             << avg(avg.size() - 1);
-    BLOG(INFO, "LOGGER_SYS") << "End of Avg = "
-                             << avg(avg.size() - 5) << ", "
-                             << avg(avg.size() - 4) << ", "
-                             << avg(avg.size() - 3) << ", "
-                             << avg(avg.size() - 2) << ", "
-                             << avg(avg.size() - 1);
-#endif
-
-    ALOG(INFO, "LOGGER_SYS") << "End of FSC = " << _FSC(_FSC.size() - 1);
-    BLOG(INFO, "LOGGER_SYS") << "End of FSC = " << _FSC(_FSC.size() - 1);
+        vec avg = vec::Zero(_maxRadius * _pf + 1);
+        shellAverage(avg,
+                     _T3D,
+                     gsl_real,
+                    _maxRadius * _pf - 1);
+        // the last two elements have low fidelity
+        avg(_maxRadius * _pf - 1) = avg(_maxRadius * _pf - 2);
+        avg(_maxRadius * _pf) = avg(_maxRadius * _pf - 2);
+
+        ALOG(INFO, "LOGGER_SYS") << "End of Avg = "
+                                 << avg(avg.size() - 5) << ", "
+                                 << avg(avg.size() - 4) << ", "
+                                 << avg(avg.size() - 3) << ", "
+                                 << avg(avg.size() - 2) << ", "
+                                 << avg(avg.size() - 1);
+        BLOG(INFO, "LOGGER_SYS") << "End of Avg = "
+                                 << avg(avg.size() - 4) << ", "
+                                 << avg(avg.size() - 3) << ", "
+                                 << avg(avg.size() - 2) << ", "
+                                 << avg(avg.size() - 1);
+#endif
 
-    #pragma omp parallel for schedule(dynamic)
-    VOLUME_FOR_EACH_PIXEL_FT(_T)
-        if ((QUAD_3(i, j, k) >= gsl_pow_2(WIENER_FACTOR_MIN_R * _pf)) &&
-            (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf)))
-        {
-            int u = AROUND(NORM_3(i, j, k));
+        ALOG(INFO, "LOGGER_SYS") << "End of FSC = " << _FSC(_FSC.size() - 1);
+        BLOG(INFO, "LOGGER_SYS") << "End of FSC = " << _FSC(_FSC.size() - 1);
+
+        #pragma omp parallel for schedule(dynamic)
+        VOLUME_FOR_EACH_PIXEL_FT(_T3D)
+            if ((QUAD_3(i, j, k) >= gsl_pow_2(WIENER_FACTOR_MIN_R * _pf)) &&
+                (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf)))
+            {
+                int u = AROUND(NORM_3(i, j, k));
 
-            double FSC = (u >= _FSC.size())
-                       ? _FSC(_FSC.size() - 1)
-                       : _FSC(u);
+                double FSC = (u / _pf >= _FSC.size())
+                           ? _FSC(_FSC.size() - 1)
+                           : _FSC(u / _pf);
 
-            FSC = GSL_MAX_DBL(1e-5, GSL_MIN_DBL(1 - 1e-5, FSC));
+                FSC = GSL_MAX_DBL(1e-3, GSL_MIN_DBL(1 - 1e-3, FSC));
+
+                FSC = sqrt(2 * FSC / (1 + FSC));
 
 #ifdef RECONSTRUCTOR_WIENER_FILTER_FSC_FREQ_AVG
-            _T.setFT(_T.getFT(i, j, k)
-                   + COMPLEX((1 - FSC) / FSC * avg(u), 0),
-                     i,
-                     j,
-                     k);
+                _T3D.setFT(_T3D.getFT(i, j, k)
+                         + COMPLEX((1 - FSC) / FSC * avg(u), 0),
+                           i,
+                           j,
+                           k);
 #else
-            _T.setFT(_T.getFT(i, j, k) / FSC, i, j, k);
+                _T3D.setFT(_T3D.getFT(i, j, k) / FSC, i, j, k);
 #endif
-        }
+            }
 #endif
 
 #ifdef RECONSTRUCTOR_WIENER_FILTER_CONST
-    #pragma omp parallel for schedule(dynamic)
-    VOLUME_FOR_EACH_PIXEL_FT(_T)
-        if ((QUAD_3(i, j, k) >= gsl_pow_2(WIENER_FACTOR_MIN_R * _pf)) &&
-            (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf)))
-            _T.setFT(_T.getFT(i, j, k) + COMPLEX(1, 0), i, j, k);
+        #pragma omp parallel for schedule(dynamic)
+        VOLUME_FOR_EACH_PIXEL_FT(_T3D)
+            if ((QUAD_3(i, j, k) >= gsl_pow_2(WIENER_FACTOR_MIN_R * _pf)) &&
+                (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf)))
+                _T3D.setFT(_T3D.getFT(i, j, k) + COMPLEX(1, 0), i, j, k);
 #endif
+    }
 
     ALOG(INFO, "LOGGER_RECO") << "Initialising W";
     BLOG(INFO, "LOGGER_RECO") << "Initialising W";
 
-    #pragma omp parallel for
-    VOLUME_FOR_EACH_PIXEL_FT(_W)
-        if (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf))
-            _W.setFTHalf(COMPLEX(1, 0), i, j, k);
-        else
-            _W.setFTHalf(COMPLEX(0, 0), i, j, k);
+    if (_mode == MODE_2D)
+    {
+        #pragma omp parallel for
+        IMAGE_FOR_EACH_PIXEL_FT(_W2D)
+            if (QUAD(i, j) < gsl_pow_2(_maxRadius * _pf))
+                _W2D.setFTHalf(COMPLEX(1, 0), i, j);
+            else
+                _W2D.setFTHalf(COMPLEX(0, 0), i, j);
+    }
+    else if (_mode == MODE_3D)
+    {
+        #pragma omp parallel for
+        VOLUME_FOR_EACH_PIXEL_FT(_W3D)
+            if (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf))
+                _W3D.setFTHalf(COMPLEX(1, 0), i, j, k);
+            else
+                _W3D.setFTHalf(COMPLEX(0, 0), i, j, k);
+    }
+    else
+        REPORT_ERROR("INEXISTENT MODE");
 
     double diffC = DBL_MAX;
     double diffCPrev = DBL_MAX;
@@ -459,19 +694,23 @@ void Reconstructor::reconstruct(Volume& dst)
         ALOG(INFO, "LOGGER_RECO") << "Balancing Weights Round " << m;
         BLOG(INFO, "LOGGER_RECO") << "Balancing Weights Round " << m;
 
-        /***
-        ALOG(INFO, "LOGGER_RECO") << "Allreducing W";
-        BLOG(INFO, "LOGGER_RECO") << "Allreducing W";
-
-        allReduceW();
-        ***/
-
         ALOG(INFO, "LOGGER_RECO") << "Determining C";
         BLOG(INFO, "LOGGER_RECO") << "Determining C";
         
-        #pragma omp parallel for
-        FOR_EACH_PIXEL_FT(_C)
-            _C[i] = _T[i] * _W[i];
+        if (_mode == MODE_2D)
+        {
+            #pragma omp parallel for
+            FOR_EACH_PIXEL_FT(_C2D)
+                _C2D[i] = _T2D[i] * _W2D[i];
+        }
+        else if (_mode == MODE_3D)
+        {
+            #pragma omp parallel for
+            FOR_EACH_PIXEL_FT(_C3D)
+                _C3D[i] = _T3D[i] * _W3D[i];
+        }
+        else
+            REPORT_ERROR("INEXISTENT MODE");
 
         convoluteC();
 
@@ -489,15 +728,31 @@ void Reconstructor::reconstruct(Volume& dst)
             (diffC > diffCPrev * DIFF_C_DECREASE_THRES)) break;
         else
         {
-            #pragma omp parallel for schedule(dynamic)
-            VOLUME_FOR_EACH_PIXEL_FT(_W)
-                if (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf))
-                    _W.setFTHalf(_W.getFTHalf(i, j, k)
-                               / GSL_MAX_DBL(ABS(_C.getFTHalf(i, j, k)),
-                                             1e-6),
-                                 i,
-                                 j,
-                                 k);
+            if (_mode == MODE_2D)
+            {
+                #pragma omp parallel for schedule(dynamic)
+                IMAGE_FOR_EACH_PIXEL_FT(_W2D)
+                    if (QUAD(i, j) < gsl_pow_2(_maxRadius * _pf))
+                        _W2D.setFTHalf(_W2D.getFTHalf(i, j)
+                                     / GSL_MAX_DBL(ABS(_C2D.getFTHalf(i, j)),
+                                                   1e-6),
+                                       i,
+                                       j);
+            }
+            else if (_mode == MODE_3D)
+            {
+                #pragma omp parallel for schedule(dynamic)
+                VOLUME_FOR_EACH_PIXEL_FT(_W3D)
+                    if (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf))
+                        _W3D.setFTHalf(_W3D.getFTHalf(i, j, k)
+                                     / GSL_MAX_DBL(ABS(_C3D.getFTHalf(i, j, k)),
+                                                   1e-6),
+                                       i,
+                                       j,
+                                       k);
+            }
+            else
+                REPORT_ERROR("INEXISTENT MODE");
         }
     }
 
@@ -506,33 +761,23 @@ void Reconstructor::reconstruct(Volume& dst)
 
     allReduceF();
 
+    // only in 3D mode, symmetry should be considered
+    IF_MODE_3D
+    {
 #ifdef RECONSTRUCTOR_SYMMETRIZE_DURING_RECONSTRUCT
-    ALOG(INFO, "LOGGER_RECO") << "Symmetrizing F";
-    BLOG(INFO, "LOGGER_RECO") << "Symmetrizing F";
+        ALOG(INFO, "LOGGER_RECO") << "Symmetrizing F";
+        BLOG(INFO, "LOGGER_RECO") << "Symmetrizing F";
 
-    symmetrizeF();
+        symmetrizeF();
 #endif
+    }
 
-    dst = _F.copyVolume();
-
-    _fft.bwExecutePlan(dst);
-
-    /***
-#ifdef RECONSTRUCTOR_ZERO_MASK
-    softMask(dst,
-             dst,
-             0.5 * _size - EDGE_WIDTH_RL,
-             EDGE_WIDTH_RL,
-             0);
-#else
-    regionBgSoftMask(dst,
-                     dst,
-                     0.5 * _size - EDGE_WIDTH_RL,
-                     EDGE_WIDTH_RL,
-                     0.5 * _size,
-                     0.5 * _size - EDGE_WIDTH_RL);
-#endif
-    ***/
+    if (_mode == MODE_2D)
+        _fft.bwExecutePlan(_F2D);
+    else if (_mode == MODE_3D)
+        _fft.bwExecutePlan(_F3D);
+    else
+        REPORT_ERROR("INEXISTENT MODE");
 
 #ifdef RECONSTRUCTOR_CORRECT_CONVOLUTION_KERNEL
 
@@ -543,277 +788,128 @@ void Reconstructor::reconstruct(Volume& dst)
     double nf = MKB_RL(0, _a * _pf, _alpha);
 #endif
 
-    #pragma omp parallel for schedule(dynamic)
-    VOLUME_FOR_EACH_PIXEL_RL(dst)
+    if (_mode == MODE_2D)
     {
+        #pragma omp parallel for schedule(dynamic)
+        IMAGE_FOR_EACH_PIXEL_RL(_F2D)
+        {
 #ifdef RECONSTRUCTOR_MKB_KERNEL
-            dst.setRL(dst.getRL(i, j, k)
-                    / MKB_RL(NORM_3(i, j, k) / PAD_SIZE,
-                             _a * _pf,
-                             _alpha)
-                    * nf,
-                      i,
-                      j,
-                      k);
+            _F2D.setRL(_F2D.getRL(i, j)
+                     / MKB_RL(NORM(i, j) / PAD_SIZE,
+                              _a * _pf,
+                              _alpha)
+                     * nf,
+                       i,
+                       j);
 #endif
 
 #ifdef RECONSTRUCTOR_TRILINEAR_KERNEL
-            dst.setRL(dst.getRL(i, j, k)
-                    / TIK_RL(NORM_3(i, j, k) / PAD_SIZE),
-                      i,
-                      j,
-                      k);
-#endif
-    }
-
-    ALOG(INFO, "LOGGER_RECO") << "Convolution Kernel Corrected";
-    BLOG(INFO, "LOGGER_RECO") << "Convolution Kernel Corrected";
-
-#endif
-}
-
-void Reconstructor::allReduceW()
-{
-    #pragma omp parallel for
-    SET_0_FT(_C);
-
-    ALOG(INFO, "LOGGER_RECO") << "Re-calculating C";
-    BLOG(INFO, "LOGGER_RECO") << "Re-calculating C";
-
-    if (_calMode == POST_CAL_MODE)
-    {
-        #pragma omp parallel for
-        for (int k = 0; k < int(_rot.size()); k++)
-            for (int j = -_size / 2; j < _size / 2; j++)
-                for (int i = 0; i <= _size / 2; i++)
-                {
-                    if (QUAD(i, j) < gsl_pow_2(_maxRadius))
-                    {
-                        vec3 newCor((double)(i * _pf), (double)(j * _pf), 0);
-                        vec3 oldCor = _rot[k] * newCor;
-
-#ifdef RECONSTRUCTOR_MKB_KERNEL
-                        _C.addFT(REAL(_W.getByInterpolationFT(oldCor[0],
-                                                              oldCor[1],
-                                                              oldCor[2],
-                                                              LINEAR_INTERP))
-                               * gsl_pow_2(REAL(_ctf[k]->getFTHalf(i, j)))
-                               * _w[k],
-                                 oldCor[0],
-                                 oldCor[1],
-                                 oldCor[2],
-                                 _pf * _a,
-                                 _kernelFT);
+            _F2D.setRL(_F2D.getRL(i, j)
+                     / TIK_RL(NORM(i, j) / PAD_SIZE),
+                       i,
+                       j);
 #endif
-
-#ifdef RECONSTRUCTOR_TRILINEAR_KERNEL
-                        _C.addFT(REAL(_W.getByInterpolationFT(oldCor[0],
-                                                              oldCor[1],
-                                                              oldCor[2],
-                                                              LINEAR_INTERP))
-                               * gsl_pow_2(REAL(_ctf[k]->getFTHalf(i, j)))
-                               * _w[k],
-                                 oldCor[0],
-                                 oldCor[1],
-                                 oldCor[2]);
-#endif
-                    }
-                }
+        }
     }
-    else if (_calMode == PRE_CAL_MODE)
+    else if (_mode == MODE_3D)
     {
-        #pragma omp parallel for
-        for (int k = 0; k < int(_rot.size()); k++)
-            for (int i = 0; i < _nPxl; i++)
-            {
-                vec3 newCor((double)(_iCol[i] * _pf), (double)(_iRow[i] * _pf), 0);
-                vec3 oldCor = _rot[k] * newCor;
-
+        #pragma omp parallel for schedule(dynamic)
+        VOLUME_FOR_EACH_PIXEL_RL(_F3D)
+        {
 #ifdef RECONSTRUCTOR_MKB_KERNEL
-                _C.addFT(REAL(_W.getByInterpolationFT(oldCor[0],
-                                                      oldCor[1],
-                                                      oldCor[2],
-                                                      LINEAR_INTERP))
-                       * gsl_pow_2(REAL(_ctf[k]->iGetFT(_iPxl[i])))
-                       * _w[k],
-                         oldCor[0],
-                         oldCor[1],
-                         oldCor[2],
-                         _pf * _a,
-                         _kernelFT);
+            _F3D.setRL(_F3D.getRL(i, j, k)
+                     / MKB_RL(NORM_3(i, j, k) / PAD_SIZE,
+                              _a * _pf,
+                              _alpha)
+                     * nf,
+                       i,
+                       j,
+                       k);
 #endif
 
 #ifdef RECONSTRUCTOR_TRILINEAR_KERNEL
-                _C.addFT(REAL(_W.getByInterpolationFT(oldCor[0],
-                                                      oldCor[1],
-                                                      oldCor[2],
-                                                      LINEAR_INTERP))
-                       * gsl_pow_2(REAL(_ctf[k]->iGetFT(_iPxl[i])))
-                       * _w[k],
-                         oldCor[0],
-                         oldCor[1],
-                         oldCor[2]);
+            _F3D.setRL(_F3D.getRL(i, j, k)
+                     / TIK_RL(NORM_3(i, j, k) / PAD_SIZE),
+                       i,
+                       j,
+                       k);
 #endif
-            }
+        }
     }
     else
-    {
-        CLOG(FATAL, "LOGGER_SYS") << "Invalid Pre(Post) Calculation Mode in Reconstructor";
-    }
-    
-    ALOG(INFO, "LOGGER_RECO") << "Waiting for Synchronizing all Processes in Hemisphere A";
-    BLOG(INFO, "LOGGER_RECO") << "Waiting for Synchronizing all Processes in Hemisphere B";
+        REPORT_ERROR("INEXISTENT MODE");
 
-    MPI_Barrier(_hemi);
-
-    ALOG(INFO, "LOGGER_RECO") << "Allreducing C";
-    BLOG(INFO, "LOGGER_RECO") << "Allreducing C";
-
-    MPI_Allreduce_Large(&_C[0],
-                        _C.sizeFT(),
-                        MPI_DOUBLE_COMPLEX,
-                        MPI_SUM,
-                        _hemi);
-
-    MPI_Barrier(_hemi);
-
-    ALOG(INFO, "LOGGER_RECO") << "Correcting Convolution Correction of C";
-    BLOG(INFO, "LOGGER_RECO") << "Correcting Convolution Correction of C";
-
-    /***
-    #pragma omp parallel for schedule(dynamic)
-    VOLUME_FOR_EACH_PIXEL_FT(_C)
-        if (QUAD_3(i, j, k) >= gsl_pow_2(_maxRadius * _pf))
-            _C.setFTHalf(COMPLEX(0, 0), i, j, k);
-    ***/
+    ALOG(INFO, "LOGGER_RECO") << "Convolution Kernel Corrected";
+    BLOG(INFO, "LOGGER_RECO") << "Convolution Kernel Corrected";
 
-    _fft.bwExecutePlanMT(_C);
+#endif
 
-    #pragma omp parallel for
-    VOLUME_FOR_EACH_PIXEL_RL(_C)
+    if (_mode == MODE_2D)
     {
-        _C.setRL(_C.getRL(i, j, k)
-               / TIK_RL(NORM_3(i, j, k) / PAD_SIZE),
-                 i,
-                 j,
-                 k);
-    }
-
-    _fft.fwExecutePlanMT(_C);
-
-    _C.clearRL();
-
-    ALOG(INFO, "LOGGER_RECO") << "Adding Wiener Factor to C";
-    BLOG(INFO, "LOGGER_RECO") << "Adding Wiener Factor to C";
-
-    /***
-    #pragma omp parallel for
-    SET_0_FT(_T);
+        dst.clear();
+        dst.alloc(_size, _size, 1, RL_SPACE);
 
-    #pragma omp parallel for schedule(dynamic)
-    VOLUME_FOR_EACH_PIXEL_FT(_T)
-        if (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf))
-        {
-            if ((i % _pf == 0) &&
-                (j % _pf == 0) &&
-                (k % _pf == 0))
-                _T.addFT(_W.getFTHalf(i, j, k),
-                         i,
-                         j,
-                         k,
-                         _pf * _a,
-                         _kernelFT);
-        }
-    ***/
-
-    _T = _W.copyVolume();
-
-    _fft.bwExecutePlanMT(_T);
+        for (int j = -_size / 2; j < _size / 2; j++)
+            for (int i = -_size / 2; i < _size / 2; i++)
+                dst.setRL(_F2D.getRL(i, j), i, j, 0);
 
-    #pragma omp parallel for
-    VOLUME_FOR_EACH_PIXEL_RL(_T)
-    {
-        _T.setRL(_T.getRL(i, j, k)
-               * MKB_RL(NORM_3(i, j, k) / PAD_SIZE,
-                        _a * _pf,
-                        _alpha),
-                 i,
-                 j,
-                 k);
+        _fft.fwExecutePlanMT(_F2D);
+        _F2D.clearRL();
     }
+    else if (_mode == MODE_3D)
+    {
+        VOL_EXTRACT_RL(dst, _F3D, 1.0 / _pf);
+        // dst = _F3D.copyVolume();
 
-    _fft.fwExecutePlanMT(_T);
-    _T.clearRL();
-
-    #pragma omp parallel for
-    FOR_EACH_PIXEL_FT(_C)
-        _C[i] += _T[i];
-
-    /***
-    double blobVol = MKB_BLOB_VOL(_a * _pf, _alpha);
+        _fft.fwExecutePlanMT(_F3D);
+        _F3D.clearRL();
+    }
+    else
+        REPORT_ERROR("INEXISTENT MODE");
 
-    #pragma omp parallel for
-    FOR_EACH_PIXEL_FT(_C)
-        _C[i] += blobVol * _W[i];
-    ***/
+#ifdef RECONSTRUCTOR_REMOVE_NEG
+    ALOG(INFO, "LOGGER_RECO") << "Removing Negative Values";
+    BLOG(INFO, "LOGGER_RECO") << "Removing Negative Values";
 
-    /***
     #pragma omp parallel for
-    FOR_EACH_PIXEL_FT(_C)
-        _C[i] += _W[i] * _T[i];
-        ***/
-
-    ALOG(INFO, "LOGGER_RECO") << "Re-calculating W";
-    BLOG(INFO, "LOGGER_RECO") << "Re-calculating W";
-
-    /***
-    #pragma omp parallel for
-    FOR_EACH_PIXEL_FT(_W)
-        _W[i] /= REAL(_C[i]);
-    ***/
-
-    #pragma omp parallel for schedule(dynamic)
-    VOLUME_FOR_EACH_PIXEL_FT(_W)
-        if (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf))
-        {
-            _W.setFTHalf(_W.getFTHalf(i, j, k)
-                       / REAL(_C.getFTHalf(i, j, k)),
-                         i,
-                         j,
-                         k);
-        }
-
-            /***
-            if (REAL(_C.getFTHalf(i, j, k)) > 1)
-            {
-                _W.setFTHalf(_W.getFTHalf(i, j, k)
-                           / REAL(_C.getFTHalf(i, j, k)),
-                             i,
-                             j,
-                             k);
-            }
-            ***/
-    /***
-        }
-        else
-            _W.setFTHalf(COMPLEX(0, 0), i, j, k);
-            ***/
+    REMOVE_NEG(dst);
+#endif
 }
 
 void Reconstructor::allReduceF()
 {
-    MUL_FT(_F, _W);
+    if (_mode == MODE_2D)
+    {
+        #pragma omp parallel for
+        MUL_FT(_F2D, _W2D);
+    }
+    else if (_mode == MODE_3D)
+    {
+        #pragma omp parallel for
+        MUL_FT(_F3D, _W3D);
+    }
+    else
+        REPORT_ERROR("INEXISTENT MODE");
 
     ALOG(INFO, "LOGGER_RECO") << "Waiting for Synchronizing all Processes in Hemisphere A";
     BLOG(INFO, "LOGGER_RECO") << "Waiting for Synchronizing all Processes in Hemisphere B";
 
     MPI_Barrier(_hemi);
 
-    MPI_Allreduce_Large(&_F[0],
-                        _F.sizeFT(),
-                        MPI_DOUBLE_COMPLEX,
-                        MPI_SUM,
-                        _hemi);
+    if (_mode == MODE_2D)
+        MPI_Allreduce_Large(&_F2D[0],
+                            _F2D.sizeFT(),
+                            MPI_DOUBLE_COMPLEX,
+                            MPI_SUM,
+                            _hemi);
+    else if (_mode == MODE_3D)
+        MPI_Allreduce_Large(&_F3D[0],
+                            _F3D.sizeFT(),
+                            MPI_DOUBLE_COMPLEX,
+                            MPI_SUM,
+                            _hemi);
+    else
+        REPORT_ERROR("INEXISTENT MODE");
 
     MPI_Barrier(_hemi);
 }
@@ -825,11 +921,20 @@ void Reconstructor::allReduceT()
 
     MPI_Barrier(_hemi);
 
-    MPI_Allreduce_Large(&_T[0],
-                        _T.sizeFT(),
-                        MPI_DOUBLE_COMPLEX,
-                        MPI_SUM,
-                        _hemi);
+    if (_mode == MODE_2D)
+        MPI_Allreduce_Large(&_T2D[0],
+                            _T2D.sizeFT(),
+                            MPI_DOUBLE_COMPLEX,
+                            MPI_SUM,
+                            _hemi);
+    else if (_mode == MODE_3D)
+        MPI_Allreduce_Large(&_T3D[0],
+                            _T3D.sizeFT(),
+                            MPI_DOUBLE_COMPLEX,
+                            MPI_SUM,
+                            _hemi);
+    else
+        REPORT_ERROR("INEXISTENT MODE");
 
     MPI_Barrier(_hemi);
 }
@@ -841,64 +946,115 @@ double Reconstructor::checkC() const
 
     int counter = 0;
 
-    #pragma omp parallel for schedule(dynamic)
-    VOLUME_FOR_EACH_PIXEL_FT(_C)
-        if (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf))
-        {
-            #pragma omp critical
-            diff += fabs(ABS(_C.getFT(i, j, k)) - 1);
-            #pragma omp critical
-            counter += 1;
-        }
+    if (_mode == MODE_2D)
+    {
+        #pragma omp parallel for schedule(dynamic)
+        IMAGE_FOR_EACH_PIXEL_FT(_C2D)
+            if (QUAD(i, j) < gsl_pow_2(_maxRadius * _pf))
+            {
+                #pragma omp atomic
+                diff += fabs(ABS(_C2D.getFT(i, j)) - 1);
+                #pragma omp atomic
+                counter += 1;
+            }
+    }
+    else if (_mode == MODE_3D)
+    {
+        #pragma omp parallel for schedule(dynamic)
+        VOLUME_FOR_EACH_PIXEL_FT(_C3D)
+            if (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf))
+            {
+                #pragma omp atomic
+                diff += fabs(ABS(_C3D.getFT(i, j, k)) - 1);
+                #pragma omp atomic
+                counter += 1;
+            }
+    }
+    else
+    {
+        REPORT_ERROR("INEXISTENT MODE");
+        abort();
+    }
 
     return diff / counter;
 #endif
 
 #ifdef RECONSTRUCTOR_CHECK_C_MAX
-    vector<double> diff(_C.sizeFT(), 0);
+    if (_mode == MODE_2D)
+    {
+        vector<double> diff(_C2D.sizeFT(), 0);
+        
+        #pragma omp parallel for schedule(dynamic)
+        IMAGE_FOR_EACH_PIXEL_FT(_C2D)
+            if (QUAD(i, j) < gsl_pow_2(_maxRadius * _pf))
+                diff[_C2D.iFTHalf(i, j)] = fabs(ABS(_C2D.getFT(i, j)) - 1);
 
-    #pragma omp parallel for schedule(dynamic)
-    VOLUME_FOR_EACH_PIXEL_FT(_C)
-        if (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf))
-            diff[_C.iFTHalf(i, j, k)] = fabs(ABS(_C.getFT(i, j, k)) - 1);
+        return *std::max_element(diff.begin(), diff.end());
+    }
+    else if (_mode == MODE_3D)
+    {
+        vector<double> diff(_C3D.sizeFT(), 0);
+
+        #pragma omp parallel for schedule(dynamic)
+        VOLUME_FOR_EACH_PIXEL_FT(_C3D)
+            if (QUAD_3(i, j, k) < gsl_pow_2(_maxRadius * _pf))
+                diff[_C3D.iFTHalf(i, j, k)] = fabs(ABS(_C3D.getFT(i, j, k)) - 1);
 
-    return *std::max_element(diff.begin(), diff.end());
+        return *std::max_element(diff.begin(), diff.end());
+    }
+    else
+    {
+        REPORT_ERROR("INEXISTENT MODE");
+        abort();
+    }
 #endif
 }
 
 void Reconstructor::convoluteC()
 {
-    _fft.bwExecutePlanMT(_C);
-
     double nf = MKB_RL(0, _a * _pf, _alpha);
 
-    #pragma omp parallel for
-    VOLUME_FOR_EACH_PIXEL_RL(_C)
+    if (_mode == MODE_2D)
     {
-        _C.setRL(_C.getRL(i, j, k)
-               * _kernelRL(QUAD_3(i, j, k) / gsl_pow_2(PAD_SIZE))
-               / nf,
-                 i,
-                 j,
-                 k);
-        /***
-        _C.setRL(_C.getRL(i, j, k)
-               * _kernelRL(QUAD_3(i, j, k) / gsl_pow_2(PAD_SIZE)),
-                 i,
-                 j,
-                 k);
-                 ***/
+        _fft.bwExecutePlanMT(_C2D);
+
+        #pragma omp parallel for
+        IMAGE_FOR_EACH_PIXEL_RL(_C2D)
+            _C2D.setRL(_C2D.getRL(i, j)
+                     * _kernelRL(QUAD(i, j) / gsl_pow_2(PAD_SIZE))
+                     / nf,
+                       i,
+                       j);
+
+        _fft.fwExecutePlanMT(_C2D);
+
+        _C2D.clearRL();
     }
+    else if (_mode == MODE_3D)
+    {
+        _fft.bwExecutePlanMT(_C3D);
+
+        #pragma omp parallel for
+        VOLUME_FOR_EACH_PIXEL_RL(_C3D)
+            _C3D.setRL(_C3D.getRL(i, j, k)
+                     * _kernelRL(QUAD_3(i, j, k) / gsl_pow_2(PAD_SIZE))
+                     / nf,
+                       i,
+                       j,
+                       k);
 
-    _fft.fwExecutePlanMT(_C);
+        _fft.fwExecutePlanMT(_C3D);
 
-    _C.clearRL();
+        _C3D.clearRL();
+    }
+    else
+        REPORT_ERROR("INEXISTENT MODE");
 }
 
 void Reconstructor::symmetrizeF()
 {
     if (_sym != NULL)
-        SYMMETRIZE_FT(_F, _F, *_sym, _maxRadius * _pf + 1, SINC_INTERP);
+        SYMMETRIZE_FT(_F3D, _F3D, *_sym, _maxRadius * _pf + 1, SINC_INTERP);
     else
         CLOG(WARNING, "LOGGER_SYS") << "Symmetry Information Not Assigned in Reconstructor";
 }
@@ -906,7 +1062,7 @@ void Reconstructor::symmetrizeF()
 void Reconstructor::symmetrizeT()
 {
     if (_sym != NULL)
-        SYMMETRIZE_FT(_T, _T, *_sym, _maxRadius * _pf + 1, SINC_INTERP);
+        SYMMETRIZE_FT(_T3D, _T3D, *_sym, _maxRadius * _pf + 1, SINC_INTERP);
     else
         CLOG(WARNING, "LOGGER_SYS") << "Symmetry Information Not Assigned in Reconstructor";
 }
diff --git a/testsrc/DirectionalStat.cpp b/testsrc/DirectionalStat.cpp
new file mode 100644
index 0000000..8a7b16e
--- /dev/null
+++ b/testsrc/DirectionalStat.cpp
@@ -0,0 +1,107 @@
+/*******************************************************************************
+ * Author: Mingxu Hu
+ * Dependecy:
+ * Test:
+ * Execution:
+ * Description:
+ * ****************************************************************************/
+
+#include <iostream>
+
+#include "DirectionalStat.h"
+
+#define MU 0
+
+#define KAPPA_0 0
+#define KAPPA_1 0.5
+#define KAPPA_2 1
+#define KAPPA_3 2
+#define KAPPA_4 4
+#define KAPPA_5 8
+#define KAPPA_6 16
+#define KAPPA_7 100000
+
+#define N 1000
+
+//#define TEST_PDF_VMS
+
+#define TEST_SAMPLE_VMS
+
+//#define TEST_INFER_VMS
+
+INITIALIZE_EASYLOGGINGPP
+
+int main(int argc, const char* argv[])
+{
+#ifdef TEST_PDF_VMS
+    for (double theta = -M_PI; theta < M_PI; theta += 0.01)
+        printf("%6f   %6f   %6f   %6f   %6f   %6f\n",
+               theta,
+               pdfVMS(vec2(cos(theta), sin(theta)), vec2(cos(MU), sin(MU)), KAPPA_0),
+               pdfVMS(vec2(cos(theta), sin(theta)), vec2(cos(MU), sin(MU)), KAPPA_1),
+               pdfVMS(vec2(cos(theta), sin(theta)), vec2(cos(MU), sin(MU)), KAPPA_2),
+               pdfVMS(vec2(cos(theta), sin(theta)), vec2(cos(MU), sin(MU)), KAPPA_3),
+               pdfVMS(vec2(cos(theta), sin(theta)), vec2(cos(MU), sin(MU)), KAPPA_4));
+#endif
+
+    mat2 VMS_0 = mat2::Zero(N, 2);
+    mat2 VMS_1 = mat2::Zero(N, 2);
+    mat2 VMS_2 = mat2::Zero(N, 2);
+    mat2 VMS_3 = mat2::Zero(N, 2);
+    mat2 VMS_4 = mat2::Zero(N, 2);
+    mat2 VMS_5 = mat2::Zero(N, 2);
+    mat2 VMS_6 = mat2::Zero(N, 2);
+    mat2 VMS_7 = mat2::Zero(N, 2);
+
+    sampleVMS(VMS_0, vec2(cos(MU), sin(MU)), KAPPA_0, N);
+    sampleVMS(VMS_1, vec2(cos(MU), sin(MU)), KAPPA_1, N);
+    sampleVMS(VMS_2, vec2(cos(MU), sin(MU)), KAPPA_2, N);
+    sampleVMS(VMS_3, vec2(cos(MU), sin(MU)), KAPPA_3, N);
+    sampleVMS(VMS_4, vec2(cos(MU), sin(MU)), KAPPA_4, N);
+    sampleVMS(VMS_5, vec2(cos(MU), sin(MU)), KAPPA_5, N);
+    sampleVMS(VMS_6, vec2(cos(MU), sin(MU)), KAPPA_6, N);
+    sampleVMS(VMS_7, vec2(cos(MU), sin(MU)), KAPPA_7, N);
+
+#ifdef TEST_SAMPLE_VMS
+    for (int i = 0; i < N; i++)
+        printf("%15.6lf %15.6lf   %15.6lf %15.6lf   %15.6lf %15.6f   %15.6lf %15.6lf   %15.6lf %15.6lf   %15.6lf %15.6lf   %15.6lf %15.6lf   %15.6lf %15.6lf\n",
+               VMS_0(i, 0),
+               VMS_0(i, 1),
+               VMS_1(i, 0),
+               VMS_1(i, 1),
+               VMS_2(i, 0),
+               VMS_2(i, 1),
+               VMS_3(i, 0),
+               VMS_3(i, 1),
+               VMS_4(i, 0),
+               VMS_4(i, 1),
+               VMS_5(i, 0),
+               VMS_5(i, 1),
+               VMS_6(i, 0),
+               VMS_6(i, 1),
+               VMS_7(i, 0),
+               VMS_7(i, 1));
+#endif
+
+#ifdef TEST_INFER_VMS
+    vec2 mu;
+    double kappa;
+
+    inferVMS(mu, kappa, VMS_0);
+    printf("mu = (%lf, %lf), kappa = %lf\n", mu(0), mu(1), kappa);
+    inferVMS(mu, kappa, VMS_1);
+    printf("mu = (%lf, %lf), kappa = %lf\n", mu(0), mu(1), kappa);
+    inferVMS(mu, kappa, VMS_2);
+    printf("mu = (%lf, %lf), kappa = %lf\n", mu(0), mu(1), kappa);
+    inferVMS(mu, kappa, VMS_3);
+    printf("mu = (%lf, %lf), kappa = %lf\n", mu(0), mu(1), kappa);
+    inferVMS(mu, kappa, VMS_4);
+    printf("mu = (%lf, %lf), kappa = %lf\n", mu(0), mu(1), kappa);
+    inferVMS(mu, kappa, VMS_5);
+    printf("mu = (%lf, %lf), kappa = %lf\n", mu(0), mu(1), kappa);
+    inferVMS(mu, kappa, VMS_6);
+    printf("mu = (%lf, %lf), kappa = %lf\n", mu(0), mu(1), kappa);
+    inferVMS(mu, kappa, VMS_7);
+    printf("mu = (%lf, %lf), kappa = %lf\n", mu(0), mu(1), kappa);
+#endif
+}
diff --git a/testsrc/FFTTest.cpp b/testsrc/FFTTest.cpp
index 4ef3d82..f61bb37 100644
--- a/testsrc/FFTTest.cpp
+++ b/testsrc/FFTTest.cpp
@@ -14,7 +14,7 @@
 #include "ImageFile.h"
 
 #define N 256
-#define M 10
+#define M 1
 
 INITIALIZE_EASYLOGGINGPP
 
@@ -46,7 +46,6 @@ int main(int argc, char* argv[])
             head.setRL(0, i, j, k);
     }
 
-    /***
     ImageFile imf;
 
     imf.readMetaData(head);
@@ -59,11 +58,15 @@ int main(int argc, char* argv[])
     fft.fwCreatePlanMT(N, N, N);
     fft.bwCreatePlanMT(N, N, N);
 
-    for (int i = 0; i < M; i++)
+    for (int k = 0; k < M; k++)
     {
-        CLOG(INFO, "LOGGER_SYS") << "Executing Plan, Round " << i;
+        CLOG(INFO, "LOGGER_SYS") << "Executing Plan, Round " << k;
 
         fft.fwExecutePlanMT(head);
+
+        FOR_EACH_PIXEL_FT(head)
+            head[i] /= 2;
+
         fft.bwExecutePlanMT(head);
     }
 
@@ -74,7 +77,6 @@ int main(int argc, char* argv[])
 
     imf.readMetaData(head);
     imf.writeVolume("head_2.mrc", head);
-    ***/
 
     fftw_cleanup_threads();
 
diff --git a/testsrc/MaskTest.cpp b/testsrc/MaskTest.cpp
index fdd73a0..1f03efb 100644
--- a/testsrc/MaskTest.cpp
+++ b/testsrc/MaskTest.cpp
@@ -21,8 +21,6 @@
 
 #define N 380
 
-
-
 INITIALIZE_EASYLOGGINGPP
 
 int main(int argc, char* argv[])
diff --git a/testsrc/ParticleTest.cpp b/testsrc/ParticleTest.cpp
index 905869d..34191af 100644
--- a/testsrc/ParticleTest.cpp
+++ b/testsrc/ParticleTest.cpp
@@ -1,4 +1,36 @@
+#include <iostream>
+
+#include "Particle.h"
+
+INITIALIZE_EASYLOGGINGPP
+
+#define N 100
+
+using namespace std;
+
 int main()
 {
+    /***
+    Particle par(MODE_2D, 1, 100, 5);
+
+    display(par);
+    ***/
+
+    /***
+    mat4 r(N, 4);
+
+    sampleVMS(r, vec4(1, 0, 0, 0), 0, N);
+
+    cout << r << endl;
+    ***/
+
+    double x, y, z;
+
+    gsl_rng* engine = get_random_engine();
+
+    //gsl_ran_dir_3d(engine, &x, &y, &z);
+
+    cout << x << ", " << y << ", " << z << endl;
+
     return 0;
 }
diff --git a/testsrc/PreprocessTest.cpp b/testsrc/PreprocessTest.cpp
index 26fe524..f9a933f 100644
--- a/testsrc/PreprocessTest.cpp
+++ b/testsrc/PreprocessTest.cpp
@@ -18,8 +18,6 @@
 #define MICROGRAPH_PATH "/home/humingxu/Micrographs"
 #define STAR_PATH        "/home/humingxu/Star"
 
-
-
 void initPara(PREPROCESS_PARA* para)
 {
      para->nCol = 100;
@@ -230,14 +228,7 @@ int main(int argc, char* argv[])
     Preprocess preprocess(para);
     preprocess.setMPIEnv();
 
-    try
-    {
     	preprocess.run();
-    }
-    catch (Error& err)
-    {
-        std::cout << err;
-    }
 
     MPI_Finalize();
 
diff --git a/testsrc/ProjCTFTest.cpp b/testsrc/ProjCTFTest.cpp
index 57d9c39..9d5a284 100644
--- a/testsrc/ProjCTFTest.cpp
+++ b/testsrc/ProjCTFTest.cpp
@@ -31,61 +31,4 @@ INITIALIZE_EASYLOGGINGPP
 int main(int argc, char* argv[])
 {
     loggerInit(argc, argv);
-
-    FFT fft;
-
-    std::cout << "Define a head." << std::endl;
-
-    Volume head(N, N, N, RL_SPACE);
-
-    VOLUME_FOR_EACH_PIXEL_RL(head)
-    {
-        double ii = i * 0.8;
-        double jj = j * 0.8;
-        double kk = k * 0.8;
-        if ((NORM_3(ii, jj, kk) < N / 8) ||
-            (NORM_3(ii - N / 8, jj, kk - N / 8) < N / 16) ||
-            (NORM_3(ii - N / 8, jj - N / 8, kk - N / 8) < N / 16) ||
-            (NORM_3(ii + N / 8, jj, kk - N / 8) < N / 16) ||
-            (NORM_3(ii + N / 8, jj + N / 8, kk - N / 8) < N / 16) ||
-            ((NORM(ii, jj) < N / 16) &&
-             (kk + N / 16 < 0) &&
-             (kk + 3 * N / 16 > 0)))
-            head.setRL(1, i, j, k);
-        else
-            head.setRL(0, i, j, k);
-    }
-
-    Volume padHead;
-    VOL_PAD_RL(padHead, head, PF);
-
-    fft.fw(padHead);
-
-    Image ctf(N, N, FT_SPACE);
-
-    CTF(ctf,
-        PIXEL_SIZE,
-        VOLTAGE,
-        DEFOCUS,
-        DEFOCUS,
-        THETA,
-        CS);
-
-    Projector projector;
-    projector.setPf(PF);
-    projector.setProjectee(padHead.copyVolume());
-
-    Image image(N, N, FT_SPACE);
-    SET_0_FT(image);
-
-    projector.project(image, 0, 0, 0);
-
-    FOR_EACH_PIXEL_FT(image)
-        image[i] *= gsl_pow_2(REAL(ctf[i]));
-
-    fft.bw(image);
-
-    image.saveRLToBMP("1.bmp");
-
-    return 0;
 }
diff --git a/testsrc/ProjRecoTest.cpp b/testsrc/ProjRecoTest.cpp
index 7ed873c..c2194a3 100644
--- a/testsrc/ProjRecoTest.cpp
+++ b/testsrc/ProjRecoTest.cpp
@@ -47,12 +47,27 @@
 
 #define NOISE_FACTOR 1
 
+#define TEST_2D
+//#define TEST_3D
+
 INITIALIZE_EASYLOGGINGPP
 
 int main(int argc, char* argv[])
 {
     loggerInit(argc, argv);
 
+#ifdef TEST_2D
+
+    MPI_Init(&argc, &argv);
+
+    int commSize, commRank;
+    MPI_Comm_size(MPI_COMM_WORLD, &commSize);
+    MPI_Comm_rank(MPI_COMM_WORLD, &commRank);
+
+#endif
+
+#ifdef TEST_3D
+
     MPI_Init(&argc, &argv);
 
     int commSize, commRank;
@@ -141,7 +156,7 @@ int main(int argc, char* argv[])
     if (commRank == MASTER_ID)
     {
         CLOG(INFO, "LOGGER_SYS") << "Initialising Random Sampling Points";
-        Particle par(M, TRANS_S, 0.01, &sym);
+        Particle par(M, 1, TRANS_S, 0.01, &sym);
         //Particle par(M, TRANS_S, 0.01, NULL);
         save("SamplingPoints.par", par);
 
@@ -293,7 +308,7 @@ int main(int argc, char* argv[])
     if (commRank != MASTER_ID)
     {
         CLOG(INFO, "LOGGER_SYS") << "Loading Sampling Points";
-        Particle par(M, TRANS_S, 0.01, &sym);
+        Particle par(M, 1, TRANS_S, 0.01, &sym);
         load(par, "SamplingPoints.par");
 
         char nameInsert[256];
@@ -415,8 +430,7 @@ int main(int argc, char* argv[])
         projectorNew.setProjectee(padNewRef.copyVolume());
 
         CLOG(INFO, "LOGGER_SYS") << "Loading Sampling Points";
-        Particle par(M, TRANS_S, 0.01, &sym);
-        //Particle par(M, TRANS_S, 0.01, NULL);
+        Particle par(1, M, TRANS_S, 0.01, &sym);
         load(par, "SamplingPoints.par");
 
         #pragma omp parallel for
@@ -510,6 +524,8 @@ int main(int argc, char* argv[])
             imageNew.saveRLToBMP(name);
         }
     }
+
+#endif
     
     return 0;
 }
diff --git a/testsrc/ProjectorTest.cpp b/testsrc/ProjectorTest.cpp
index 9e1e6eb..17a415a 100644
--- a/testsrc/ProjectorTest.cpp
+++ b/testsrc/ProjectorTest.cpp
@@ -47,158 +47,4 @@ int main(int argc, char* argv[])
         else
             head.setRL(0, i, j, k);
     }
-
-    gsl_rng* engine = get_random_engine();
-
-    Volume noise(N, N, N, RL_SPACE);
-    FOR_EACH_PIXEL_RL(noise)
-        noise(i) = gsl_ran_gaussian(engine, 1);
-
-    ADD_RL(head, noise);
-
-    mat33 centre;
-    centre << -1, 0, 0,
-              0, -1, 0,
-              0, 0, -1;
-    /***
-    mat33 centre({{-1, 0, 0},
-                  {0, -1, 0},
-                  {0, 0, -1}});
-                  ***/
-    Volume centreHead(N, N, N, RL_SPACE);
-    VOL_TRANSFORM_MAT_RL(centreHead,
-                         head,
-                         centre,
-                         centreHead.nColRL() / 2 -1,
-                         LINEAR_INTERP);
-
-    ImageFile imf;
-    imf.readMetaData(head);
-    imf.writeVolume("head.mrc", head);
-    imf.readMetaData(centreHead); 
-    imf.writeVolume("centreHead.mrc", centreHead);
-
-    Volume padHead;
-    VOL_PAD_RL(padHead, head, PF);
-    Volume padCentreHead;
-    VOL_PAD_RL(padCentreHead, centreHead, PF);
-    /***
-    imf.readMetaData(padHead);
-    imf.writeVolume("padHead.mrc", padHead);
-    ***/
-
-    FFT fft;
-    fft.fw(padHead);
-    fft.fw(padCentreHead);
-
-    Projector projector;
-    projector.setMaxRadius(N / 4);
-    projector.setPf(PF);
-
-    Image image(N, N, RL_SPACE);
-
-    mat33 rot;
-
-    projector.setProjectee(padHead.copyVolume());
-
-    rotate3D(rot, 0.3, 0.3, 0.3);
-
-    R2R_FT(image,
-           image,
-           projector.project(image, rot));
-    image.saveRLToBMP("Positive.bmp");
-
-    rotate3D(rot, 0.3 + M_PI, 0.3, 0.3);
-
-    R2R_FT(image,
-           image,
-           projector.project(image, rot));
-
-    image.saveRLToBMP("PositiveCounterPart.bmp");
-
-    R2R_FT(image,
-           image,
-           projector.project(image, rot));
-
-    projector.setProjectee(padCentreHead.copyVolume());
-
-    rotate3D(rot, 0.3, 0.3, 0.3);
-    mat33 rot2;
-    rotate3D(rot2, 0, 0, M_PI);
-    std::cout << rot2 << std::endl;
-
-    R2R_FT(image,
-           image,
-           projector.project(image, rot2 * rot));
-    image.saveRLToBMP("Negative.bmp");
-
-    /***
-    rot = rot * mat33({{-1, 0, 0},
-                       {0, -1, 0},
-                       {0, 0, -1}});
-                       ***/
-    //rot *= rot2;
-
-    /***
-    R2R_FT(image,
-           image,
-           projector.project(image, 2 * M_PI - 0.3, M_PI - 0.3, 2 * M_PI - 0.3));
-           ***/
-    /***
-    R2R_FT(image,
-           image,
-           projector.project(image, rot));
-    image.saveRLToBMP("Negative.bmp");
-    ***/
-
-    Image img(N, N, FT_SPACE);
-
-    CLOG(INFO, "LOGGER_SYS") << "START";
-
-    char name[FILE_NAME_LENGTH];
-
-    try
-    {
-    for (int k = 0; k < M; k++)
-        for (int j = 0; j < M; j++)
-            for (int i = 0; i < M; i++)
-            {
-                SET_0_FT(img);
-                printf("%02d %02d %02d\n", i, j, k);
-                /***
-                projector.project(img,
-                                  2 * M_PI * i / M,
-                                  M_PI * j / M,
-                                  2 * M_PI * k / M,
-                                  10,
-                                  10);
-                ***/
-                projector.project(img,
-                                  2 * M_PI * i / M,
-                                  M_PI * j / M,
-                                  2 * M_PI * k / M);
-
-                sprintf(name, "%02d%02d%02dFT.bmp", i, j, k);
-                img.saveFTToBMP(name, 0.1);
-
-                fft.bw(img);
-
-                sprintf(name, "%02d%02d%02dRL.bmp", i, j, k);
-                img.saveRLToBMP(name);
-
-                sprintf(name, "%02d%02d%02dRL.mrc", i, j, k);
-                imf.readMetaData(img);
-                imf.writeImage(name, img);
-
-                fft.fw(img);
-            }
-    }
-    catch (Error& err)
-    {
-        std::cout << err << std::endl;
-    }
-
-    CLOG(INFO, "LOGGER_SYS") << "END";
-
-    return 0;
 }
diff --git a/testsrc/RandomTest.cpp b/testsrc/RandomTest.cpp
new file mode 100644
index 0000000..d1d4a8b
--- /dev/null
+++ b/testsrc/RandomTest.cpp
@@ -0,0 +1,31 @@
+/*******************************************************************************
+ * Author: Mingxu Hu
+ * Dependecy:
+ * Test:
+ * Execution:
+ * Description:
+ * ****************************************************************************/
+
+#include <iostream>
+
+#include "Random.h"
+
+#define N 20
+#define M 10
+
+#define TEST_DISCRETE_FLAT
+
+INITIALIZE_EASYLOGGINGPP
+
+int main(int argc, const char* argv[])
+{
+    gsl_rng* engine = get_random_engine();
+
+#ifdef TEST_DISCRETE_FLAT
+    for (int i = 0; i < M; i++)
+    {
+        //std::cout << gsl_rng_get(engine) % N << std::endl;
+        std::cout << gsl_rng_uniform_int(engine, N) << std::endl;
+    }
+#endif
+}
diff --git a/testsrc/ReconstructorTest.cpp b/testsrc/ReconstructorTest.cpp
index b07337f..0e0cd7a 100644
--- a/testsrc/ReconstructorTest.cpp
+++ b/testsrc/ReconstructorTest.cpp
@@ -18,139 +18,98 @@
 
 #define N 256
 #define M 32
-//#define M 16
-
-
 
 INITIALIZE_EASYLOGGINGPP
 
 int main(int argc, char* argv[])
 {
-    /***
     loggerInit(argc, argv);
 
     MPI_Init(&argc, &argv);
 
+    fftw_init_threads();
+
     int commSize, commRank;
     MPI_Comm_size(MPI_COMM_WORLD, &commSize);
     MPI_Comm_rank(MPI_COMM_WORLD, &commRank);
 
-    // std::cout << "0: commRank = " << commRank << std::endl;
-    Volume head(N, N, N, RL_SPACE);
-    VOLUME_FOR_EACH_PIXEL_RL(head)
+    Image head(N, N, RL_SPACE);
+
+    IMAGE_FOR_EACH_PIXEL_RL(head)
     {
-        if ((NORM_3(i, j, k) < N / 8) ||
-            (NORM_3(i - N / 8, j, k - N / 8) < N / 16) ||
-            (NORM_3(i + N / 8, j, k - N / 8) < N / 16) ||
-            ((NORM(i, j) < N / 16) &&
-             (k + N / 16 < 0) &&
-             (k + 3 * N / 16 > 0)))
-            head.setRL(1, i, j, k);
+        if ((NORM(i, j) < N / 8) ||
+            (NORM(i - N / 8, j - N / 8) < N / 16) ||
+            (NORM(i + N / 8, j - N / 8) < N / 16))
+            head.setRL(1, i, j);
         else
-            head.setRL(0, i, j, k);
+            head.setRL(0, i, j);
     }
 
     if (commRank == MASTER_ID)
-    {
-        ImageFile imf;
-        imf.readMetaData(head);
-        imf.display();
-        imf.writeVolume("head.mrc", head);
-    }
+        head.saveRLToBMP("head.bmp");
 
     printf("head defined\n");
 
-    Volume padHead;
-    VOL_PAD_RL(padHead, head, 2);
-    normalise(padHead);
+    FFT fft;
+    fft.fw(head);
 
-    std::cout << "Adding Noise" << std::endl;
-    Volume noise(2 * N, 2 * N, 2 * N, RL_SPACE);
-    gsl_rng* engine = get_random_engine();
-    FOR_EACH_PIXEL_RL(noise)
-        noise(i) = gsl_ran_gaussian(engine, 5);
-    ADD_RL(padHead, noise);
+    Projector projector;
+    projector.setMode(MODE_2D);
+    projector.setProjectee(head.copyImage());
 
-    printf("padHead: mean = %f, stddev = %f, maxValue = %f\n",
-           gsl_stats_mean(&padHead(0), 1, padHead.sizeRL()),
-           gsl_stats_sd(&padHead(0), 1, padHead.sizeRL()),
-           padHead(cblas_idamax(padHead.sizeRL(), &padHead(0), 1)));
+    Image projectee = projector.projectee2D().copyImage();
 
-    FFT fft;
-    fft.fw(padHead);
-    printf("FFT Done\n");
+    fft.bw(projectee);
 
-    Projector projector;
-    projector.setProjectee(padHead.copyVolume());
+    projectee.saveRLToBMP("projectee.bmp");
 
     char name[256];
 
     Image image(N, N, FT_SPACE);
-    // Image image(N, N, RL_SPACE);
-    ***/
 
-    Symmetry sym("C2");
+    Image ctf(N, N, FT_SPACE);
 
-    boost::container::vector< boost::movelib::unique_ptr<Reconstructor> > reco;
+    SET_1_FT(ctf);
 
-    reco.push_back(boost::movelib::unique_ptr<Reconstructor>(new Reconstructor()));
-    reco[0]->init(N, 2, &sym);
+    Reconstructor reconstructor(MODE_2D, N, 2, NULL);
 
-    //Reconstructor reconstructor(N, 2, &sym);
-
-    /***
     reconstructor.setMPIEnv();
 
-    printf("Set Symmetry Done\n");
+    reconstructor.setMaxRadius(13);
 
-    try
-    {
     if (commRank != MASTER_ID)
     {
-        if (commRank == 1)
-            timing();
-
         printf("Projection and Insertion\n");
 
         for (int k = M / (commSize - 1) * (commRank - 1);
                  k < M / (commSize - 1) * commRank;
                  k++)
-            for (int j = 0; j < M / 2; j++)
-                for (int i = 0; i < M / 2; i++)
-                {
-                    SET_0_FT(image);
-
-                    printf("%02d %02d %02d\n", i, j, k);
-                    sprintf(name, "%02d%02d%02d.bmp", i, j, k);
-                    Coordinate5D coord(2 * M_PI * i / M,
-                                       2 * M_PI * j / M,
-                                       2 * M_PI * k / M,
-                                       0,
-                                       0);
-                    projector.project(image, coord);
-
-                    fft.bw(image);
-                    
-                    printf("image: mean = %f, stddev = %f, maxValue = %f\n",
-                           gsl_stats_mean(&image(0), 1, image.sizeRL()),
-                           gsl_stats_sd(&image(0), 1, image.sizeRL()),
-                           image(cblas_idamax(image.sizeRL(), &image(0), 1)));
-
-                    fft.fw(image);
-
-                    reconstructor.insert(image, coord, 1);
-                }
+        {
+            SET_0_FT(image);
+
+            printf("%02d\n", k);
+            sprintf(name, "%02d.bmp", k);
+
+            double phi = 2 * M_PI / M * k;
+
+            mat22 rot;
+
+            rotate2D(rot, phi);
+
+            projector.project(image, rot);
+
+            fft.bw(image);
+
+            image.saveRLToBMP(name);
+
+            fft.fw(image);
+
+            reconstructor.insert(image, ctf, rot, vec2(0, 0), 1);
         }
-        if (commRank == 1)
-            timing();
-    }
-    }
-    catch (Error& err)
-    {
-        std::cout << err << std::endl;
     }
 
-    Volume result;
+    Image result;
+
     if (commRank != MASTER_ID)
     {
         if (commRank == HEMI_A_LEAD)
@@ -161,60 +120,13 @@ int main(int argc, char* argv[])
         if (commRank == HEMI_A_LEAD)
             CLOG(INFO, "LOGGER_SYS") << "End Reconstruction";
 
-        printf("result: mean = %f, stddev = %f, maxValue = %f\n",
-               gsl_stats_mean(&result(0), 1, result.sizeRL()),
-               gsl_stats_sd(&result(0), 1, result.sizeRL()),
-               result(cblas_idamax(result.sizeRL(), &result(0), 1)));
-
-        if (commRank == 1)
+        if (commRank == HEMI_A_LEAD)
         {
-            ImageFile imf;
-            imf.readMetaData(result);
-            imf.writeVolume("result.mrc", result);
+            result.saveRLToBMP("result.bmp");
         }
     }
 
-    if (commRank == 1)
-        timing();
-
-    if (commRank != MASTER_ID)
-    {
-        fft.fw(result);
-        projector.setProjectee(result.copyVolume());
-        for (int k = M / (commSize - 1) * (commRank - 1);
-                 k < M / (commSize - 1) * commRank;
-                 k++)
-            for (int j = 0; j < M / 2; j++)
-                for (int i = 0; i < M / 2; i++)
-                {
-                    SET_0_FT(image);
-
-                    printf("%02d %02d %02d\n", i, j, k);
-                    sprintf(name, "%02d%02d%02d.bmp", i, j, k);
-                    Coordinate5D coord(2 * M_PI * i / M,
-                                       2 * M_PI * j / M,
-                                       2 * M_PI * k / M,
-                                       0,
-                                       0);
-                    projector.project(image, coord);
-
-                    fft.bw(image);
-
-                    printf("image: mean = %f, stddev = %f, maxValue = %f\n",
-                           gsl_stats_mean(&image(0), 1, image.sizeRL()),
-                           gsl_stats_sd(&image(0), 1, image.sizeRL()),
-                           image(cblas_idamax(image.sizeRL(), &image(0), 1)));
-
-                    fft.fw(image);
-                }
-    }
-
-    //MPI_Comm_free(&world);
-    //MPI_Comm_free(&workers);
-    //MPI_Group_free(&worker_group);
-    //MPI_Group_free(&world_group);
-
     MPI_Finalize();
+
     return 0;
-    ***/
 }
diff --git a/testsrc/SymmetryTest.cpp b/testsrc/SymmetryTest.cpp
index f05ddfc..3f54a89 100644
--- a/testsrc/SymmetryTest.cpp
+++ b/testsrc/SymmetryTest.cpp
@@ -17,8 +17,6 @@ int main(int argc, const char* argv[])
 {
     loggerInit(argc, argv);
 
-    try
-    {
         Symmetry sym("C15");
         display(sym);
 
@@ -37,9 +35,4 @@ int main(int argc, const char* argv[])
 
         for (int i = 0; i < (int)sr.size(); i++)
             std::cout << sr[i] << std::endl;
-    }
-    catch (Error& error)
-    {
-        std::cout << error;
-    }
 }
